<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="https://jaydenchang.gitee.io/images/Jayden.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="https://jaydenchang.gitee.io/images/Jayden.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://jaydenchang.gitee.io/images/Jayden.jpg">
  <link rel="mask-icon" href="https://jaydenchang.gitee.io/images/Jayden.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jaydenchang.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="从零实现一个Docker">
<meta property="og:type" content="article">
<meta property="og:title" content="自己动手写Docker学习笔记">
<meta property="og:url" content="https://jaydenchang.top/post/0x0035.html">
<meta property="og:site_name" content="Jayden&#39;s Blog">
<meta property="og:description" content="从零实现一个Docker">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jaydenchang.gitee.io/images/images/0x0035/demo_1.png">
<meta property="og:image" content="http://jaydenchang.gitee.io/images/images/0x0035/demo_sh.png">
<meta property="og:image" content="http://jaydenchang.gitee.io/images/images/0x0035/7.1.1-veth.png">
<meta property="og:image" content="http://jaydenchang.gitee.io/images/images/0x0035/7.1.1-bridge.png">
<meta property="og:image" content="http://jaydenchang.gitee.io/images/images/0x0035/7.1.2-route.png">
<meta property="article:published_time" content="2023-05-20T16:00:00.000Z">
<meta property="article:modified_time" content="2023-05-22T07:14:35.991Z">
<meta property="article:author" content="Jayden Chang">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jaydenchang.gitee.io/images/images/0x0035/demo_1.png">


<link rel="canonical" href="https://jaydenchang.top/post/0x0035.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://jaydenchang.top/post/0x0035.html","path":"/post/0x0035.html","title":"自己动手写Docker学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>自己动手写Docker学习笔记 | Jayden's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Jayden's Blog" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Jayden's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">15</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">8</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">53</span></a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E5%89%8D%E8%A8%80"><span class="nav-text">零、前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%A6%82%E5%BF%B5%E7%AF%87"><span class="nav-text">一、概念篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">1. 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kernel"><span class="nav-text">1.1 kernel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#namespace"><span class="nav-text">1.2 namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#uts-namespace"><span class="nav-text">1.2.1 UTS Namespace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ipc-namespace"><span class="nav-text">1.2.2 IPC Namespace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pid-namespace"><span class="nav-text">1.2.3 PID Namespace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mount-namespace"><span class="nav-text">1.2.4 Mount Namespace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#user-namespace"><span class="nav-text">1.2.5 User Namespace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#network-namespace"><span class="nav-text">1.2.6 Network Namespace</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux-cgroups"><span class="nav-text">1.3 Linux Cgroups</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#cgroups-%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="nav-text">1.3.1 Cgroups 的三个组件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%99%E4%B8%89%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%85%B3%E8%81%94"><span class="nav-text">1.3.2 这三个组件的关联</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cgroup-%E5%92%8C-subsystem-%E5%92%8C-hierarchy-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-text">1.3.3 cgroup 和 subsystem 和 hierarchy 之间的联系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cgroup-%E7%9A%84-kernel-%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.3.4 cgroup 的 kernel 接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#docker-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-cgroups-%E7%9A%84"><span class="nav-text">1.3.5 docker 是怎么使用 Cgroups 的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#demo"><span class="nav-text">1.4 Demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ufs"><span class="nav-text">1.5 UFS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ufs-%E6%A6%82%E5%BF%B5"><span class="nav-text">1.5.1 UFS 概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#aufs"><span class="nav-text">1.5.2 AUFS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#docker-%E5%92%8C-aufs"><span class="nav-text">1.5.3 docker 和 AUFS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#image-layer"><span class="nav-text">1.5.4 image layer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-aufs"><span class="nav-text">1.5.5 实现一个 AUFS</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%AE%B9%E5%99%A8%E7%AF%87"><span class="nav-text">二、容器篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#linux-%E7%9A%84-proc-%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-text">2. Linux 的 &#x2F;proc 文件夹</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pid"><span class="nav-text">2.1 PID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="nav-text">2.2 一些重要的目录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">3. 简单实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-text">3.1 工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-text">3.2 实现代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#runcommand"><span class="nav-text">3.2.1 runCommand</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#run"><span class="nav-text">3.2.2 run</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#newprocess"><span class="nav-text">3.2.3 NewProcess</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#init"><span class="nav-text">3.2.4 init</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#initprocess"><span class="nav-text">3.2.5 InitProcess</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99-docker-run-%E5%A2%9E%E5%8A%A0%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E5%8A%9F%E8%83%BD"><span class="nav-text">4. 给 docker run 增加对容器的资源限制功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#subsystem.go"><span class="nav-text">4.1 subsystem.go</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memorysubsystem"><span class="nav-text">4.2 MemorySubsystem</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#name"><span class="nav-text">4.2.1 Name()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#set"><span class="nav-text">4.2.2 Set()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#addprocess"><span class="nav-text">4.2.3 AddProcess()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#removecgroup"><span class="nav-text">4.2.4 RemoveCgroup()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpusubsystem"><span class="nav-text">4.3 CPUSubsystem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpusetsubsystem"><span class="nav-text">4.4 CPUSetSubsystem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getcgrouppath"><span class="nav-text">4.5 GetCgroupPath()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cgroupsmanager.go"><span class="nav-text">4.6 cgroupsManager.go</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%8F%82%E6%95%B0"><span class="nav-text">4.7 管道处理多个容器参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#containerinit.go"><span class="nav-text">4.7.1 container&#x2F;init.go</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dockercommandrun.go"><span class="nav-text">4.7.2 dockerCommand&#x2F;run.go</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#command.go"><span class="nav-text">4.7.3 command.go</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#main.go"><span class="nav-text">4.7.4 main.go</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C-demo"><span class="nav-text">4.8 运行 demo</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E9%95%9C%E5%83%8F%E7%AF%87"><span class="nav-text">三、镜像篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E9%95%9C%E5%83%8F"><span class="nav-text">5. 构造镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-aufs-%E5%86%85%E6%A0%B8"><span class="nav-text">5.1 编译 aufs 内核</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E4%BB%A3%E7%A0%81%E5%BA%93"><span class="nav-text">5.1.1 准备代码库</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-busybox-%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="nav-text">5.2 使用 busybox 创建容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#busybox"><span class="nav-text">5.2.1 busybox</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pivot_root"><span class="nav-text">5.2.2 pivot_root</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8-aufs-%E5%8C%85%E8%A3%85-busybox"><span class="nav-text">5.2.3 用 AUFS 包装 busybox</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-volume-%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-text">5.3 实现 volume 数据卷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85"><span class="nav-text">5.4 简单镜像打包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E8%BF%9B%E9%98%B6"><span class="nav-text">6. 构建容器进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="nav-text">6.1 实现容器后台运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-text">6.2 实现查看运行中的容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#name-%E6%A0%87%E7%AD%BE"><span class="nav-text">6.2.1 name 标签</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-docker-ps"><span class="nav-text">6.2.2 实现 docker ps</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span class="nav-text">6.3 查看容器日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8-namespace"><span class="nav-text">6.4 进入容器 Namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#setns"><span class="nav-text">6.4.1 setns</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cgo"><span class="nav-text">6.4.2 Cgo</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">6.4.3 实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="nav-text">6.5 停止容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="nav-text">6.6 删除容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AE%B9%E5%99%A8%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F"><span class="nav-text">6.7 通过容器制作镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E6%8C%87%E5%AE%9A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%BF%90%E8%A1%8C"><span class="nav-text">6.8 实现容器指定环境变量运行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-runcommand"><span class="nav-text">6.8.1 修改 runCommand</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-run-%E5%87%BD%E6%95%B0"><span class="nav-text">6.8.2 修改 Run 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-newparentprocess-%E5%87%BD%E6%95%B0"><span class="nav-text">6.8.3 修改 NewParentProcess 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-exec-%E5%91%BD%E4%BB%A4"><span class="nav-text">6.8.4 修改 exec 命令</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E7%BD%91%E7%BB%9C%E7%AF%87"><span class="nav-text">四、网络篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C"><span class="nav-text">7. 容器网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="nav-text">7.1 网络虚拟化技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#linux-%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87"><span class="nav-text">7.1.1 Linux 虚拟网络设备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linux-%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="nav-text">7.1.2 Linux 路由表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linux-iptables"><span class="nav-text">7.1.3 Linux iptables</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-text">7.2 构建容器网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="nav-text">7.2.1 基本模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="nav-text">7.2.2 调用关系</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D"><span class="nav-text">7.3 容器地址分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-text">7.3.1 数据结构定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D"><span class="nav-text">7.3.2 地址分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E9%87%8A%E6%94%BE"><span class="nav-text">7.3.3 地址释放</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-bridge-%E7%BD%91%E7%BB%9C"><span class="nav-text">7.4 创建 bridge 网络</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-bridge-driver-create"><span class="nav-text">7.4.1 实现 Bridge Driver Create</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bridge-driver-%E5%88%9D%E5%A7%8B%E5%8C%96-linux-bridge"><span class="nav-text">7.4.2 Bridge Driver 初始化 Linux Bridge</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bridge-driver-delete-%E5%AE%9E%E7%8E%B0"><span class="nav-text">7.4.3 Bridge Driver Delete 实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-bridge-%E7%BD%91%E7%BB%9C%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="nav-text">7.5 在 bridge 网络创建容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E5%AE%B9%E5%99%A8%E7%AB%AF%E7%82%B9"><span class="nav-text">7.5.1 挂载容器端点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E8%A1%A5-bug"><span class="nav-text">7.5.2 修补 bug</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-text">7.5.3 测试</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-text">参考链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jayden Chang"
      src="https://jaydenchang.gitee.io/images/Jayden.jpg">
  <p class="site-author-name" itemprop="name">Jayden Chang</p>
  <div class="site-description" itemprop="description">身在井隅，心向星光。眼中有诗，自在远方。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/JaydenChang" title="Github → https:&#x2F;&#x2F;github.com&#x2F;JaydenChang" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang44378@163.com" title="E-Mail → mailto:zhang44378@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/jaydenchang" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;jaydenchang" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/JaydenChang7" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;JaydenChang7" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/@jaydenchang7" title="YouTuBe → https:&#x2F;&#x2F;www.youtube.com&#x2F;@jaydenchang7" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTuBe</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/jaydenchang7" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;jaydenchang7" rel="noopener me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://500px.com.cn/jaydenchang" title="500px → https:&#x2F;&#x2F;500px.com.cn&#x2F;jaydenchang" rel="noopener me" target="_blank"><i class="fa-brands fa-500px fa-fw"></i>500px</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jaydenchang.top/post/0x0035.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://jaydenchang.gitee.io/images/Jayden.jpg">
      <meta itemprop="name" content="Jayden Chang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jayden's Blog">
      <meta itemprop="description" content="身在井隅，心向星光。眼中有诗，自在远方。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="自己动手写Docker学习笔记 | Jayden's Blog">
      <meta itemprop="description" content="从零实现一个Docker">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          自己动手写Docker学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-21 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-21T00:00:00+08:00">2023-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BackEnd/" itemprop="url" rel="index"><span itemprop="name">BackEnd</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>118k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:47</span>
    </span>
</div>

            <div class="post-description">从零实现一个Docker</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="零前言">零、前言</h2>
<p>本文为《自己动手写 Docker》的学习，对于各位学习 docker 的同学非常友好，非常建议买一本来学习。</p>
<p>书中有摘录书中的一些知识点，不过限于篇幅，没有全部摘录 <del>(主要也是懒)</del>。项目仓库地址为：<a target="_blank" rel="noopener" href="https://github.com/JaydenChang/simple-docker">JaydenChang/simple-docker (github.com)</a></p>
<h2 id="一概念篇">一、概念篇</h2>
<h3 id="基础知识">1. 基础知识</h3>
<h4 id="kernel">1.1 kernel</h4>
<p>kernel (内核) 指大多数操作系统的核心部分，由操作系统中用于管理存储器、文件、外设和系统资源的部分组成。操作系统内核通常运行进程，并提供进程间通信。</p>
<h4 id="namespace">1.2 namespace</h4>
<p>namespace 是 Linux 自带的功能来隔离内核资源的机制。</p>
<p>Linux 中有 6 种 namespace</p>
<h5 id="uts-namespace">1.2.1 UTS Namespace</h5>
<p>UTS，UNIX Time Sharing，用于隔离 nodeName (主机名) 和 domainName (域名)。在该 Namespace 下修改 hostname 不会影相其他的 Namespace。</p>
<h5 id="ipc-namespace">1.2.2 IPC Namespace</h5>
<p>IPC，Inter-Process Communication (进程间通讯)，用于隔离 System V IPC 和 POSIX message queues (一种消息队列，结构为链表)。</p>
<p>两种 IPC 本质上差不多，System V IPC 随内核持续，POSIX IPC 随进程持续。</p>
<h5 id="pid-namespace">1.2.3 PID Namespace</h5>
<p>PID，Process IDs，用于隔绝 PID。同样的进程，在不同 Namespace 里是不同的 PID。新建的 PID Namespace 里第一个 PID 是1。</p>
<h5 id="mount-namespace">1.2.4 Mount Namespace</h5>
<p>用于隔绝文件系统，挂载了某一目录，在这个 Namespace 下就会把这个目录当作根目录，我们看到的文件系统树就会以这个目录为根目录。</p>
<p>mount 操作本身不会影响到外部，docker 中的 volume 也用到了这个特性。</p>
<h5 id="user-namespace">1.2.5 User Namespace</h5>
<p>用于 隔离用户组 ID。</p>
<h5 id="network-namespace">1.2.6 Network Namespace</h5>
<p>每个 Namespace 都有一套自己的网络设备，可以使用相同的端口号，映射到 host 的不同端口。</p>
<h4 id="linux-cgroups">1.3 Linux Cgroups</h4>
<p>Cgroups 全称为 Control Groups，是 Linux 内核提供的物理资源隔离机制。</p>
<h5 id="cgroups-的三个组件">1.3.1 Cgroups 的三个组件</h5>
<ul>
<li>cgroup：一个 cgroup 包含一组进程，且可以有 subsystem 的参数配置，以关联一组 subsystem。</li>
<li>subsystem：一组资源控制的模块。</li>
<li>hierarchy：把一组 cgroups 串成一个树状结构，以提供继承的功能。</li>
</ul>
<h5 id="这三个组件的关联">1.3.2 这三个组件的关联</h5>
<p>Linux 有一些限制：</p>
<ul>
<li>首先，创建一个 hierarchy。这个 hierarchy 有一个 cgroup 根节点，所有的进程都会被加到这个根节点上，所有在这个 hierarchy 上创建的节点都是这个根节点的子节点。</li>
<li>一个 subsystem 只能加到一个 hierarchy 上。</li>
<li>但是一个 subsystem 可以加到同一个 hierarchy 的多个 cgroups 上。</li>
<li>一个 hierarchy 可以有多个 subsystem。</li>
<li>一个进程可以在多个 cgroups 中，但是这些 cgroup 必须在不同的 hierarchy 中。</li>
<li>一个进程 fork 出子进程时，父进程和子进程属于同一个 cgroup。</li>
</ul>
<h5 id="cgroup-和-subsystem-和-hierarchy-之间的联系">1.3.3 cgroup 和 subsystem 和 hierarchy 之间的联系</h5>
<ul>
<li>hierarchy 就是一颗 cgroups 树，由多个 cgroups 构成。每一个 hierarchy 建立时会包含 ==<em>所有</em>== 的Linux 进程。这里的 “所有” 就是当前系统运行中的所有进程，每个 hierarchy 上的全部进程都是一样的，不同的 hierarchy 指的其实只是不同的分组方式，这也是为什么一个进程可以存在于多个 hierarchy 上；准确来说，一个进程一定会同时存在于所有的 hierarchy 上，区别在被放在的 cgroup 可能会有差异。</li>
<li>Linux 的 subsystem 只有一个的说法，没有一种的说法，也就是在一个 hierarchy 上使用了 memory subsystem，那么在其他 hierarchy 就不能使用 memory subsystem 了。</li>
<li>subsystem 是一种资源控制器，有很多个 subsystem，每个 subsystem 控制不同的资源。subsystem 和 cgroups 关联。新建一个 cgroups 文件夹时，里面会自动生成一堆配置文件，那个就是 subsystem 配置文件。但 <code>subsystem 配置文件</code> 不是 <code>subsystem</code>，就像 <code>.git</code> 不是 <code>git</code> 一样，就像没安装 git 也可以从别人那里获得 <code>.git</code> 文件夹，只是不能用罢了。<code>subsystem 配置文件</code> 也是如此，新建一个 cgroup 就会生成 <code>cgroup 配置文件</code>，但并不代表你关联了一个 subsystem。只有当改变了一个 <code>cgroup 配置文件</code>，里面要限制某种资源时，就会自动关联到这个被限制的资源所对应的 subsystem 上。</li>
<li>假设我的 Linux 有 12 个 subsystem，也就是说我最多只能建 12 个 hierarchy (不加 subsystem 的情况下可以建更多 hierarchy，这样 cgroup 就变成纯分组使用)。每一个 hierarchy 上一个 subsystem。如果在某个 hierarchy 放多个 subsystem，能建立的 hierarchy就更少了。</li>
<li>subsystem 和 cgroup 是关联的，不是和 hierarchy 关联的，但经常看到有人说把某个 subsystem 和某个 hierarchy 关联。实质上一般指的是 hierarchy 中的某一个 cgroup 或多个 cgroup 关联。</li>
</ul>
<h5 id="cgroup-的-kernel-接口">1.3.4 cgroup 的 kernel 接口</h5>
<p>kernel 接口，就是在 Linux 上调用 api 来控制 cgroups。</p>
<ol type="1">
<li><p>首先创建一个 hierarchy，而 hierarchy 要挂载到一个目录上，这里创建一个目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir hierarchy-test</code></pre></li>
<li><p>然后挂载：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo mount -t cgroup -o none,name&#x3D;hierarchy-test hierarchy-test .&#x2F;hierarchy-test</code></pre></li>
<li><p>可以在这个目录下看到一大堆文件，这些文件就是 cgroup 根节点的配置。</p></li>
<li><p>然后在这个目录下创建新的空目录，会发现，新的目录里也会有很多 cgroup 配置文件，这些目录已成为 cgroup 根节点的子节点 cgroup。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
├── tasks
└── temp  # 这是新创建的文件夹
    ├── cgroup.clone_children
    ├── cgroup.procs
    ├── notify_on_release
    └── tasks</code></pre></li>
<li><p>在 cgroup 中添加和移动进程：系统的所有进程都会被放到根节点中，可以根据需要移动进程：</p>
<ul>
<li><p>只需将进程 ID 写到对应的 cgroup 的 tasks 文件即可。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo sh -c &quot;echo $$ &gt;&gt; tasks&quot;</code></pre>
<p>该命令就是将当前终端的这个进程加到当前所在的 cgroup 的目录的 tasks 文件中。</p></li>
</ul></li>
<li><p>通过 subsystem 限制 cgroup 中进程的资源：</p>
<ul>
<li>上面的方法有个问题，因为这个 hierarchy 没有关联到任何 subsystem，因此不能够控制资源。</li>
<li>不过其实系统会自动给每个 subsystem 创建一个 hierarchy，所以通过控制这个 hierarchy 里的配置，可以达到控制进程的目的。</li>
</ul></li>
</ol>
<h5 id="docker-是怎么使用-cgroups-的">1.3.5 docker 是怎么使用 Cgroups 的</h5>
<p>docker 会给每个容器创建一个 cgroup，再限制该 cgroup 的资源，从而达到限制容器的资源的作用。</p>
<p>其实写了这么多，综合上面的前置知识，不难猜测，docker 的原理是：隔离主机。</p>
<h4 id="demo">1.4 Demo</h4>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io&#x2F;ioutil&quot;
	&quot;os&quot;
	&quot;os&#x2F;exec&quot;
	&quot;path&quot;
	&quot;strconv&quot;
	&quot;syscall&quot;
)

const cgroupMemoryHierarchyCount &#x3D; &quot;&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&quot;

func main() &#123;
    &#x2F;&#x2F; 第二次会运行这段代码
    &#x2F;&#x2F; 这段代码运行的地方就可以看做是一个简易的容器
    &#x2F;&#x2F; 这里只是对进程进行了隔离
    &#x2F;&#x2F; 但是可以看到 pid 已经变成了 1，因为我们有 PID Namespace
    if os.Args[0] &#x3D;&#x3D; &quot;&#x2F;proc&#x2F;self&#x2F;exe&quot; &#123;
        fmt.Printf(&quot;current pid %d\n&quot;, syscall.Getpid())
        cmd :&#x3D; exec.Command(&quot;sh&quot;, &quot;-c&quot;, &#96;stress --vm-bytes 200m --vm-keep -m 1&#96;)
        cmd.SysProcAttr &#x3D; &amp;syscall.SysProcAttr&#123;&#125;
        cmd.Stdin &#x3D; os.Stdin
        cmd.Stdout &#x3D; os.Stdout
        cmd.Stderr &#x3D; os.Stderr
        if err :&#x3D; cmd.Run(); err !&#x3D; nil &#123;
            fmt.Println(err)
            os.Exit(1)
        &#125;
    &#125;
    
    &#x2F;&#x2F; 第一次运行这段
    &#x2F;&#x2F; **command 设置为当前进程，也就是这个 go 程序本身，也就是说 cmd.Start() 会再次运行该程序
    cmd :&#x3D; exec.Command(&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot;)
    &#x2F;&#x2F; 在 start 之前，修改 cmd 的各种配置，也就是第二次运行这个程序的时候的配置
	&#x2F;&#x2F; 创建 namespace
    cmd.SysProcAttr &#x3D; &amp;syscall.SysProcAttr &#123;
        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,
    &#125;
    cmd.Stdin &#x3D; os.Stdin
    cmd.Stdout &#x3D; os.Stdout
    cmd.Stderr &#x3D; os.Stderr
    
    &#x2F;&#x2F; 因为之后要打印 process 的 id，所以用 start
    &#x2F;&#x2F; 如果这里用 run 的话，那么 else 里的代码永远不会执行，因为 stress 永远不会结束
    if err :&#x3D; cmd.Start(); err !&#x3D; nil &#123;
        fmt.Println(&quot;Error&quot;, err)
        os.Exit(1)
    &#125; else &#123;
        &#x2F;&#x2F; 打印 new process id
        fmt.Printf(&quot;%v\n&quot;, cmd.Process.Pid)
        
        &#x2F;&#x2F; 接下来三段对 cgroup 操作
        &#x2F;&#x2F; the hierarchy has been already created by linux on the memory subsystem
        &#x2F;&#x2F; create a sub cgroup   
        os.Mkdir(path.Join(
            cgroupMemoryHierarchyCount,
            &quot;testMemoryLimit&quot;,
        ), 0755)
        
        &#x2F;&#x2F; place container process in this cgroup
        ioutil.WriteFile(path.Join(
            cgroupMemoryHierarchyCount,
            &quot;testMemoryLimit&quot;,
            &quot;tasks&quot;,
        ), []byte(strconv.Itoa(cmd.Process.Pid)), 0644)
        
        &#x2F;&#x2F; restrict the stress process on this cgroup
        ioutil.WriteFile(path.Join(
        	cgroupMemoryHierarchyCount,
            &quot;testMemoryLimit&quot;,
            &quot;memory.limit_int_bytes&quot;,
        ), []byte(&quot;100m&quot;), 0644)
        
        &#x2F;&#x2F; cmd.Start() 不会等待进程结束，所以需要手动等待
        &#x2F;&#x2F; 如果不加的话，由于主进程结束了，子进程也会被强行结束
        cmd.Process.Wait()
    &#125;
&#125;</code></pre>
<h4 id="ufs">1.5 UFS</h4>
<h5 id="ufs-概念">1.5.1 UFS 概念</h5>
<p>UFS，Union File System，联合文件系统。docker 在下载一个 image 文件时，会看到一次下载很多个文件，这就是 UFS。它是一种分层、轻量、高性能的文件系统。UFS 类似 git，每次修改文件时，都是一次提交，并有记录，修改都反映在一个新的文件上，而不是修改旧文件。</p>
<p>UFS 允许多个不同目录挂载到同一个虚拟文件系统下，这就是为什么 image 之间可以共享文件，以及继承镜像的原因。</p>
<h5 id="aufs">1.5.2 AUFS</h5>
<p>AUFS，Advanced Union File System，是 UFS 的一个改动版本。</p>
<p>笔者本身使用的是 WSL 做日常开发，WSL 内核不支持 AUFS，后面会提到更换内核。</p>
<h5 id="docker-和-aufs">1.5.3 docker 和 AUFS</h5>
<p>docker 在早期使用 AUFS，直到现在也可以选择作为一种存储驱动类型。</p>
<h5 id="image-layer">1.5.4 image layer</h5>
<p>image 由多层 read-only layer 构成。</p>
<p>当启动一个 container 时，就会在 image 上再加一层 init layer，init layer 也是 read-only 的，用于储存容器的环境配置。此外，docker 还会创建一个 read-write 的 layer，用于执行所有的写操作。</p>
<p>当停止容器时，这个 read-write layer 依然保留，只有删除 container 时才会被删除。</p>
<p>那么，怎么删除旧文件呢？</p>
<p>docker 会在 read-write layer 生成一个 <code>.wh.&lt;fileName&gt;</code> 文件来隐藏要删除的文件。</p>
<h5 id="实现一个-aufs">1.5.5 实现一个 AUFS</h5>
<p>我们先创建一个如下的文件夹结构：</p>
<pre class="line-numbers language-none"><code class="language-none">.
├── container-layer
│   └── container.txt
├── image-layer
│   └── image.txt
└── mnt</code></pre>
<p>然后挂载到 mnt 文件夹上：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo mount -t aufs -o dirs&#x3D;.&#x2F;container-layer:.&#x2F;image-layer none .&#x2F;mnt</code></pre>
<p>如果没有手动添加权限的话，默认 dirs 左边第一个文件夹有 write-read 权限，其他都是 read-only。</p>
<p>我们可以发现，imageLayer1 和 writeLayer 的文件出现在 mnt 文件夹下：</p>
<pre class="line-numbers language-none"><code class="language-none">.
├── container-layer
│   └── container.txt
├── image-layer
│   └── image.txt
└── mnt
    ├── container.txt
    └── image.txt</code></pre>
<p>然后我们修改一下 image.txt 的内容，然后再看看整个目录，会发现，<code>container-layer</code> 目录下多了一个 <code>image.txt</code>，然后我们看看 <code>container-layer</code> 的 <code>image.txt</code> 的内容，有添加前后的的文字。</p>
<p>也就是说，实际上，当修改某一个 layer 的时候，实际上不会改变这个 layer，而是将其复制到 container-layer 中，然后再修改这个新的文件。</p>
<h2 id="二容器篇">二、容器篇</h2>
<h3 id="linux-的-proc-文件夹">2. Linux 的 /proc 文件夹</h3>
<h4 id="pid">2.1 PID</h4>
<p>在 <code>/proc</code> 文件夹下可以看到很多文件夹的名字都是个数字，其实就是个 PID。是 Linux 为每个进程创建的空间。</p>
<h4 id="一些重要的目录">2.2 一些重要的目录</h4>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;proc&#x2F;N # PID 为 N 的进程
&#x2F;proc&#x2F;N&#x2F;cmdline # 进程的启动命令
&#x2F;proc&#x2F;N&#x2F;cwd # 链接到进程的工作目录
&#x2F;proc&#x2F;N&#x2F;environ  # 进程的环境变量列表
&#x2F;proc&#x2F;N&#x2F;exe # 链接到进程的执行命令
&#x2F;proc&#x2F;N&#x2F;fd # 包含进程相关的所有文件描述符
&#x2F;proc&#x2F;N&#x2F;maps # 与进程相关的内存映射信息
&#x2F;proc&#x2F;N&#x2F;mem # 进程持有的内存，不可读
&#x2F;proc&#x2F;N&#x2F;root # 链接到进程的根目录
&#x2F;proc&#x2F;N&#x2F;stat # 进程的状态
&#x2F;proc&#x2F;N&#x2F;statm # 进程的内存状态
&#x2F;proc&#x2F;N&#x2F;status # 比上面两个更可读
&#x2F;proc&#x2F;self # 链接到当前正在运行的进程</code></pre>
<h3 id="简单实现">3. 简单实现</h3>
<h4 id="工具">3.1 工具</h4>
<p>获取帮助编写 command line app 的工具：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go get github.com&#x2F;urfave&#x2F;cli </code></pre>
<h4 id="实现代码">3.2 实现代码</h4>
<p>代码结构：</p>
<pre class="line-numbers language-none"><code class="language-none">.
├── command.go
├── container
│   └── init.go
├── dockerCommand
│   └── run.go
├── go.mod
├── go.sum
└── main.go</code></pre>
<h5 id="runcommand">3.2.1 runCommand</h5>
<p><code>command.go</code> 用于放置各种 command 命令，这里先只写一个 runCommand 命令。</p>
<p>首先用 urfave/cli 创建一个 runCommand 命令：</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; command.go
var runCommand &#x3D; cli.Command&#123;
    Name:  &quot;run&quot;,
    Usage: &quot;Create a container&quot;,
    Flags: []cli.Flag&#123;
        &#x2F;&#x2F; integrate -i and -t for convenience
        &amp;cli.BoolFlag&#123;
            Name:  &quot;it&quot;,
            Usage: &quot;open an interactive tty(pseudo terminal)&quot;,
        &#125;,
    &#125;,
    Action: func(context *cli.Context) error &#123;
        args :&#x3D; context.Args()
        if len(args) &#x3D;&#x3D; 0 &#123;
            return errors.New(&quot;Run what?&quot;)
        &#125;
        cmdArray :&#x3D; args.Get(0)        &#x2F;&#x2F; command

        &#x2F;&#x2F; check whether type &#96;-it&#96;
        tty :&#x3D; context.Bool(&quot;it&quot;) &#x2F;&#x2F; presudo terminal

                &#x2F;&#x2F; 这个函数在下面定义
        dockerCommand.Run(tty, cmdArray)

        return nil
    &#125;,
&#125;</code></pre>
<h5 id="run">3.2.2 run</h5>
<p>上面的 Run 函数在 <code>dockerCommand/run.go</code> 下定义。当运行 <code>docker run</code> 时，实际上主要是 Action 下的这个函数在工作：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; dockerCommand&#x2F;run.go
&#x2F;&#x2F; This is the function what &#96;docker run&#96; will call
func Run(tty bool, cmdArray string) &#123;

	&#x2F;&#x2F; this is &quot;docker init &lt;cmdArray&gt;&quot;
	initProcess :&#x3D; container.NewProcess(tty, cmdArray)

	&#x2F;&#x2F; start the init process
	if err :&#x3D; initProcess.Start(); err !&#x3D; nil&#123;
		logrus.Error(err)
	&#125;

	initProcess.Wait()
	os.Exit(-1)
&#125;</code></pre>
<p>但其实这个函数做的也只是去跑一个 initProcess。这个 command process 在另一个包里定义。</p>
<h5 id="newprocess">3.2.3 NewProcess</h5>
<p>上面提到的 <code>container.NewProcess</code> 在 <code>container/init.go</code> 里定义：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; container&#x2F;init.go
func NewProcess(tty bool, cmdArray string) *exec.Cmd &#123;

	&#x2F;&#x2F; create a new command which run itself
	&#x2F;&#x2F; the first arguments is &#96;init&#96; which is the below exported function
	&#x2F;&#x2F; so, the &lt;cmd&gt; will be interpret as &quot;docker init &lt;cmdArray&gt;&quot;
	args :&#x3D; []string&#123;&quot;init&quot;, cmdArray&#125;
	cmd :&#x3D; exec.Command(&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot;, args...)

	&#x2F;&#x2F; new namespaces, thanks to Linux
	cmd.SysProcAttr &#x3D; &amp;syscall.SysProcAttr&#123;
		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWNET,
	&#125;

	&#x2F;&#x2F; this is what presudo terminal means
	&#x2F;&#x2F; link the container&#39;s stdio to os
	if tty &#123;
		cmd.Stdin &#x3D; os.Stdin
		cmd.Stdout &#x3D; os.Stdout
		cmd.Stderr &#x3D; os.Stderr
	&#125;

	return cmd
&#125;</code></pre>
<p>这个函数的作用是生成一个新的 command process，但这个 command 是 <code>/proc/self/exe</code> 这个程序本身，也就是，我们最后生成的可执行文件，但这次我们不运行 <code>docker run</code>，而是 <code>docker init</code>，这个 init 命令在下面定义。</p>
<h5 id="init">3.2.4 init</h5>
<p>initCommand 和 runCommand 在同一个文件里定义，也是一个 command，但是注意这个 command 不面向用户，只用于协助 runCommand。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; command.go
&#x2F;&#x2F; docker init, but cannot be used by user
var initCommand &#x3D; cli.Command&#123;
	Name:  &quot;init&quot;,
	Usage: &quot;init a container&quot;,
	Action: func(context *cli.Context) error &#123;
		logrus.Infof(&quot;Start initiating...&quot;)
		cmdArray :&#x3D; context.Args().Get(0)
		logrus.Infof(&quot;container command: %v&quot;, cmdArray)
		return container.InitProcess(cmdArray, nil)
	&#125;,
&#125;</code></pre>
<p>这里使用了 container.InitProcess 函数，这个函数是真正用于容器初始化的函数。</p>
<h5 id="initprocess">3.2.5 InitProcess</h5>
<p>这里的是 InitProcess，也就是容器初始化的步骤。</p>
<p>注意 syscall.Exec 这里：</p>
<ul>
<li>就是 <code>mount /</code> 并指定 private，不然容器里的 proc 会使用外面的 proc，即使在不同 namespace 下。</li>
<li>所以如果没有加这一段，其实退出容器后还需要在外面再次 mount proc 才能使用 ps 等命令</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; already in container
&#x2F;&#x2F; initiate the container
func InitProcess(cmdArray string, args []string) error &#123;

	defaultMountFlags :&#x3D; syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV
        
        &#x2F;&#x2F; mount
	if err :&#x3D; syscall.Mount(&quot;&quot;, &quot;&#x2F;&quot;, &quot;&quot;, syscall.MS_PRIVATE|syscall.MS_REC, &quot;&quot;); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mount &#x2F; fails: %v&quot;, err)
		return err
	&#125;
        
	&#x2F;&#x2F; mount proc filesystem
	syscall.Mount(&quot;proc&quot;, &quot;&#x2F;proc&quot;, &quot;proc&quot;, uintptr(defaultMountFlags), &quot;&quot;)
	argv :&#x3D; []string&#123;cmdArray&#125;
	if err :&#x3D; syscall.Exec(cmdArray, argv, os.Environ()); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mount &#x2F;proc fails: %v&quot;, err)
	&#125;
	
	return nil
&#125;</code></pre>
<p>一般来说，我们都是想要这个 cmdArray 作为 PID=1 的进程。but，我们有 initProcess 本身的存在，所以 PID = 1 的其实是 initProcess，那如何让 cmdArray 作为 PID=1 的存在呢？</p>
<p>这里有一个 syscall.Exec 神器，Exec 内部会调用 kernel 的 execve 函数，这个函数会把当前进程上运行的程序替换为另一个程序，这正是我们想要的，在不改变 PID 的情况下，替换程序 (即使 kill PID 为 1 的进程，新创建的进程也会是 PID=2)。</p>
<p>为什么要第一个命令的 PID 为 1？</p>
<ul>
<li>因为这样，退出这个进程后，容器就会因为没有前台进程，而自动退出，这也是 docker 的特性。</li>
</ul>
<h3 id="给-docker-run-增加对容器的资源限制功能">4. 给 docker run 增加对容器的资源限制功能</h3>
<p>这里要用到 subsystem 的知识。</p>
<h4 id="subsystem.go">4.1 subsystem.go</h4>
<ul>
<li>根据 subsystem 的特性，和接口很搭。</li>
<li>此外再定义一个 ResourceConfig 的类型，用于放置资源控制的配置。</li>
<li>subsystemInstance 里包括 3 个 subsystem，分别对 memory，cpu，cpushare 进行限制。因为我们只需要对整个容器进行限制，所以这一套 3 个够了。</li>
</ul>
<p>看到这里，有个 cpu，cpushare，cpuset 等等，有点晕，查了下，有关 CPU 的 cgroup subsystem，这里列举常见的 3 个：</p>
<ul>
<li>cpu：经常看到的 cpushares 在其麾下，share 即相对权重的 cpu 调度，用来限制 cgroup 的 cpu 的使用率</li>
<li>cpuacct：统计 cgroup 的 cpu 使用率</li>
<li>cpuset：在多核机器上设置 cgroups 可使用的 cpu 核心数和内存</li>
</ul>
<p>通常前两者可以合体</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package subsystems

type ResourceConfig struct &#123;
	MemoryLimit string
	CPUShare string
	CPUSet string
&#125;

type Subsystem interface &#123;
	&#x2F;&#x2F; return the name of which type of subsystem
	Name() string
	&#x2F;&#x2F; set a resource limit on a cgroup
	Set(cgroupPath string, res *ResourceConfig) error
	&#x2F;&#x2F; add a processs with the pid to a group
	AddProcess(cgroupPath string, pid int) error
	&#x2F;&#x2F; remove a cgroup
	RemoveCgroup(cgroupPath string) error
&#125;

&#x2F;&#x2F; instance of a subsystems
var SubsystemsInstance &#x3D; []Subsystem&#123;
	&amp;CPU&#123;&#125;,
	&amp;CPUSet&#123;&#125;,
	&amp;Memory&#123;&#125;,
&#125;</code></pre>
<h4 id="memorysubsystem">4.2 MemorySubsystem</h4>
<h5 id="name">4.2.1 Name()</h5>
<p>很简单，返回 “memory” 字符串，表示这个 subsystem 是 memorySubsystem。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (ms *MemorySubsystem) Name() string &#123;
    return &quot;memory&quot;
&#125;</code></pre>
<h5 id="set">4.2.2 Set()</h5>
<p>Set() 用于对 cgroup 设置资源限制，因此参数为 cgroup 的 path 和 resourceConfig。</p>
<ol type="1">
<li>其中 <code>GetCgroupPath</code> 后面会提及，作用是获取这个 subsystem 所挂载的 hierarchy 上的虚拟文件系统下的 从group 路径。</li>
<li>获取到 cgroupPath 在虚拟文件系统中的位置后，只需要写入 "memory.limit_in_bytes" 文件中即可。</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; set the memory limit to this cgroup with cgroupPath
func (ms *Memory) Set(cgroupPath string, res *ResourceConfig) error  &#123;
	if subsystemCgroupPath, err :&#x3D; GetCgroupPath(ms.Name(), cgroupPath, true); err !&#x3D; nil &#123;
		return err
	&#125; else &#123;
		if err :&#x3D; ioutil.WriteFile(path.Join(subsystemCgroupPath, &quot;memory.limit_in_bytes&quot;), []byte(res.MemoryLimit), 0644); err !&#x3D; nil &#123;
			return fmt.Errorf(&quot;set cgroup memory fail: %v&quot;, err)
		&#125;
	&#125;
	return nil
&#125;</code></pre>
<h5 id="addprocess">4.2.3 AddProcess()</h5>
<ol type="1">
<li>和上面基本一样，只不过是写到 tasks 里。</li>
<li>pid 变成 byte slice 之前要用 Itoa 转化一下。</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (ms *Memory) AddProcess(cgroupPath string, pid int) error &#123;
	if subsystemCgroupPath, err :&#x3D; GetCgroupPath(ms.Name(), cgroupPath, false); err !&#x3D; nil &#123;
		return err
	&#125; else &#123;
		if err :&#x3D; ioutil.WriteFile(path.Join(subsystemCgroupPath, &quot;tasks&quot;), []byte(strconv.Itoa(pid)), 0644); err !&#x3D; nil &#123;
			return fmt.Errorf(&quot;cgroup add process fail: %v&quot;, err)
		&#125;
	&#125;
	return nil
&#125;</code></pre>
<h5 id="removecgroup">4.2.4 RemoveCgroup()</h5>
<ol type="1">
<li>使用 <code>os.Remove</code> 可以移除参数所指定的文件或文件夹。</li>
<li>这里移除整个 cgroup 文件夹，就等于是删除 cgroup 了。</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (ms *Memory) RemoveCgroup(cgroupPath string) error &#123;
	if subsystemCgroupPath, err :&#x3D; GetCgroupPath(ms.Name(), cgroupPath, false); err !&#x3D; nil &#123;
		return err
	&#125; else &#123;
		return os.Remove(subsystemCgroupPath)
	&#125;
&#125;</code></pre>
<h4 id="cpusubsystem">4.3 CPUSubsystem</h4>
<p>这里的设计和上面没什么区别，直接贴参考代码</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; cpu.go
func (c *CPU) Name() string &#123;
	return &quot;CPUShare&quot;
&#125;

func (c *CPU) Set(cgroupPath string, res *ResourceConfig) error &#123;
	if subsystemCgroupPath, err :&#x3D; GetCgroupPath(c.Name(), cgroupPath, true); err !&#x3D; nil &#123;
		return err
	&#125; else &#123;
		if err :&#x3D; ioutil.WriteFile(path.Join(subsystemCgroupPath, &quot;cpu.shares&quot;), []byte(res.CPUShare), 0644); err !&#x3D; nil &#123;
			return fmt.Errorf(&quot;set cpu share limit failed: %s&quot;, err)
		&#125;
	&#125;
	return nil
&#125;

func (c *CPU) AddProcess(cgroupPath string, pid int) error &#123;
	if subsystemCgroupPath, err :&#x3D; GetCgroupPath(c.Name(), cgroupPath, false); err !&#x3D; nil &#123;
		return err
	&#125; else &#123;
		if err :&#x3D; ioutil.WriteFile(path.Join(subsystemCgroupPath, &quot;tasks&quot;), []byte(strconv.Itoa(pid)), 0644); err !&#x3D; nil &#123;
			return fmt.Errorf(&quot;cgroup add cpu process failed: %v&quot;, err)
		&#125;
	&#125;
	return nil
&#125;

func (c *CPU) RemoveCgroup(cgroupPath string) error &#123;
	if subsystemCgroupPath, err :&#x3D; GetCgroupPath(c.Name(), cgroupPath, false); err !&#x3D; nil &#123;
		return err
	&#125; else &#123;
		return os.Remove(subsystemCgroupPath)
	&#125;
&#125;</code></pre>
<h4 id="cpusetsubsystem">4.4 CPUSetSubsystem</h4>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; cpuset.go
func (c *CPUSet) Name() string &#123;
	return &quot;CPUSet&quot;
&#125;

func (c *CPUSet) Set(cgroupPath string, res *ResourceConfig) error &#123;
	if subsystemCgroupPath, err :&#x3D; GetCgroupPath(c.Name(), cgroupPath, true); err !&#x3D; nil &#123;
		return err
	&#125; else &#123;
		if err :&#x3D; ioutil.WriteFile(path.Join(subsystemCgroupPath, &quot;cpuset.cpus&quot;), []byte(res.CPUSet), 0644); err !&#x3D; nil &#123;
			return fmt.Errorf(&quot;set cgroup cpuset failed: %v&quot;, err)
		&#125;
	&#125;
	return nil
&#125;

func (c *CPUSet) AddProcess(cgroupPath string, pid int) error &#123;
	if subsystemCgroupPath, err :&#x3D; GetCgroupPath(c.Name(), cgroupPath, false); err !&#x3D; nil &#123;
		return err
	&#125; else &#123;
		if err :&#x3D; ioutil.WriteFile(path.Join(subsystemCgroupPath, &quot;tasks&quot;), []byte(strconv.Itoa(pid)), 0644); err !&#x3D; nil &#123;
			return fmt.Errorf(&quot;cgroup add cpuset process failed: %v&quot;, err)
		&#125;
	&#125;
	return nil
&#125;

func (c *CPUSet) RemoveCgroup(cgroupPath string) error &#123;
	if subsystemCgroupPath, err :&#x3D; GetCgroupPath(c.Name(), cgroupPath, false); err !&#x3D; nil &#123;
		return err
	&#125; else &#123;
		return os.Remove(path.Join(subsystemCgroupPath))
	&#125;
&#125;</code></pre>
<h4 id="getcgrouppath">4.5 GetCgroupPath()</h4>
<p><code>GetCgroupPath()</code> 用于获取某个 subsystem 所挂载的 hierarchy 上的虚拟文件系统 (挂载后的文件夹) 下的 cgroup 的路径。通过对这个目录的改写来改动 cgroup。</p>
<p>首先我们抛开 cgroup，在此之前我们要知道 这个 hierarchy 的 cgroup 根节点的路径。那可以在 <code>/proc/self/mountinfo</code> 中获取。</p>
<p>下面是一些实现细节：</p>
<ol type="1">
<li>首先定义一个 <code>FindCgroupMountpoint()</code> 来找到 cgroup 的根节点。</li>
<li>然后在 <code>GetCgroupPath</code> 将其和 cgroup 的相对路径拼接从而获取 cgroup 的路径。如果 <code>autoCreate</code> 为 true 且该路径不存在，那么就新建一个 cgroup。(在 hierarchy 环境下，mkdir 其实会隐式地创建一个 cgroup，其中包括很多配置文件)</li>
</ol>
<blockquote>
<p><a href="#1.3.4 cgroup 的 kernel 接口">点击这里回顾</a></p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; as the function name shows, find the root path of hierarchy
func FindCgroupMountpoint(subsystemName string) string  &#123;
	f, err :&#x3D; os.Open(&quot;&#x2F;proc&#x2F;self&#x2F;mountinfo&quot;)
    &#x2F;&#x2F; get info about mount relate to current process
	if err !&#x3D; nil &#123;
		return &quot;&quot;
	&#125;

	defer f.Close()

	scanner :&#x3D; bufio.NewScanner(f)
	for scanner.Scan() &#123;
		txt :&#x3D; scanner.Text()
		fields :&#x3D; strings.Split(txt, &quot; &quot;)
		&#x2F;&#x2F; find whether &quot;subsystemName&quot; appear in the last field
		&#x2F;&#x2F; if so, then the fifth field is the path
		for _, opt :&#x3D; range strings.Split(fields[len(fields)-1], &quot;,&quot;) &#123;
			if opt &#x3D;&#x3D; subsystemName &#123;
				return fields[4]
			&#125;
		&#125;
	&#125;
	return &quot;&quot;
&#125;

&#x2F;&#x2F; get the absolute path of a cgroup
func GetCgroupPath(subsystemName string, cgroupPath string, autoCreate bool) (string, error)  &#123;
	cgroupRootPath :&#x3D; FindCgroupMountpoint(subsystemName)
	expectedPath :&#x3D; path.Join(cgroupRootPath, cgroupPath)
	
	&#x2F;&#x2F; find the cgroup or create a new cgroup
	if _, err :&#x3D; os.Stat(expectedPath); err &#x3D;&#x3D; nil  || (autoCreate &amp;&amp; os.IsNotExist(err)) &#123;
		if os.IsNotExist(err) &#123;
			if err :&#x3D; os.Mkdir(expectedPath, 0755); err !&#x3D; nil &#123;
				return &quot;&quot;, fmt.Errorf(&quot;error when create cgroup: %v&quot;, err)
			&#125;
		&#125;
		return expectedPath, nil
	&#125; else &#123;
		return &quot;&quot;, fmt.Errorf(&quot;cgroup path error: %v&quot;, err)
	&#125;
&#125;</code></pre>
<h4 id="cgroupsmanager.go">4.6 cgroupsManager.go</h4>
<ol type="1">
<li>定义 CgroupManager 类型，其中的 path 要注意是相对路径，相对于 hierarchy 的 root path。所以一个 CgroupManager 是有可能表示多个 cgroups 的，或准确说，和对应的 hierarchy root path 的相对路径一样的多个 cgroups。</li>
<li>因为上述原因，<code>Set()</code> 可能会创建多个 cgroups，如果 subsystems 们在不同的 hierarchy 就会这样。</li>
<li>这也是为什么 <code>AddProcess()</code> 和 <code>Remove()</code> 要在每个 subsystem 上执行一遍。因为这些 subsystem 可能存在于不同的 hierarchies。</li>
<li>注意 <code>Set()</code> 和 <code>AddProcess()</code> 都不是返回错误，而是发出警告，然后返回 nil。因为有些时候用户只指定某一个限制，例如 memory，那样的话修改 cpu 等其实会报错 (正常的报错)，因此我们不 return err 来退出。</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package cgroups

import &quot;simple-docker&#x2F;subsystem&quot;

type CgroupManager struct &#123;
	Path     string &#x2F;&#x2F; relative path, relative to the root path of the hierarchy
					&#x2F;&#x2F; so this may cause more than one cgroup in different hierarchies
	Resource *subsystems.ResourceConfig
&#125;

func NewCgroupManager(path string) *CgroupManager &#123;
	return &amp;CgroupManager&#123;
		Path: path,
	&#125;
&#125;

&#x2F;&#x2F; set the three resource config subsystems to the cgroup(will create if the cgroup path is not existed)
&#x2F;&#x2F; this may generate more than one cgroup, because those subsystem may appear in different hierarchies
func (cm CgroupManager) Set(res *subsystems.ResourceConfig) error &#123;
	for _, subsystem :&#x3D; range subsystems.SubsystemsInstance &#123;
		if err :&#x3D; subsystem.Set(cm.Path, res); err !&#x3D; nil &#123;
			logrus.Warnf(&quot;set resource fail: %v&quot;, err)
		&#125;
	&#125;
	return nil
&#125;

&#x2F;&#x2F; add process to the cgroup path
&#x2F;&#x2F; why should we iterate all the subsystems? we have only one cgroup
&#x2F;&#x2F; because those subsystems may appear at different hierarchies, which will then cause more than one cgroup, 1-3 in this case.
func (cm *CgroupManager) AddProcess(pid int) error &#123;
	for _, subsystem :&#x3D; range subsystems.SubsystemsInstance &#123;
		if err :&#x3D; subsystem.AddProcess(cm.Path, pid); err !&#x3D; nil &#123;
			logrus.Warn(&quot;app process fail: %v&quot;, err)
		&#125;
	&#125;
	return nil
&#125;

&#x2F;&#x2F; delete the cgroup(s)
func (cm *CgroupManager) Remove() error &#123;
	for _, subsystem :&#x3D; range subsystems.SubsystemsInstance &#123;
		if err:&#x3D; subsystem.RemoveCgroup(cm.Path); err !&#x3D; nil &#123;
			return err
		&#125;
	&#125;
	return nil
&#125;</code></pre>
<h4 id="管道处理多个容器参数">4.7 管道处理多个容器参数</h4>
<p>限制容器运行的命令不再像是 <code>/bin/sh</code> 这种单个参数，而是多个参数，因此需要使用管道来对多个参数进行处理。那么需要修改以下文件：</p>
<h5 id="containerinit.go">4.7.1 container/init.go</h5>
<ol type="1">
<li>管道原理和 channel 很像，read 端和 write 端会在另一边没响应时堵塞。</li>
<li>使用 <code>os.Pipe()</code> 获取管道。返回的 readPipe 和 writePipe 都是 <code>*os.File</code> 类型。</li>
<li>如何把管道传给子进程 (也就是容器进程) 变成了一个难题，这里用到了 <code>ExtraFile</code> 这个参数来解决。cmd 会带着参数里的文件来创建新的进程。(这里除了 ExtraFile，还会有类似 StandardFile，也就是 stdin，stdout，stderr)</li>
<li>这里把 read 端传给容器进程，然后 write 端保留在父进程上。</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func NewParentProcess(tty bool) (*exec.Cmd, *os.File) &#123;
	readPipe, writePipe, err :&#x3D; os.Pipe()
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;new pipe error: %v&quot;, err)
		return nil, nil
	&#125;

	&#x2F;&#x2F; create a new command which run itself
	cmd :&#x3D; exec.Command(&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot;, &quot;init&quot;)

	&#x2F;&#x2F; new namespaces
	cmd.SysProcAttr &#x3D; &amp;syscall.SysProcAttr&#123;
		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWNET,
	&#125;

	&#x2F;&#x2F; link the container&#39;s stdio to os
	if tty &#123;
		cmd.Stdin &#x3D; os.Stdin
		cmd.Stdout &#x3D; os.Stdout
		cmd.Stderr &#x3D; os.Stderr
	&#125;

	cmd.ExtraFiles &#x3D; []*os.File&#123;readPipe&#125;
	return cmd, writePipe
&#125;</code></pre>
<p>除了 <code>NewProcess()</code>，<code>InitProcess()</code> 也要改变下。</p>
<ol type="1">
<li>使用 readCommand 来读取 pipe。</li>
<li>实际运行中，当进程运行到 <code>readCommand()</code> 时会堵塞，直到 write 端传数据进来。</li>
<li>因此不用担心我们在容器运行后再传输参数。因为再读取完参数之前，<code>InitProcess()</code> 也不会运行到 <code>syscall.Exec()</code> 这一步。</li>
<li>这里添加了 lookPath，这个是用于解决每次我们都要输入 <code>/bin/ls</code> 的麻烦，这个函数会帮我们找到参数命令的绝对路径。也就是说，只要输入 ls 即可，lookPath 会自动找到 <code>/bin/ls</code>。然后我们再把这个 path 作为 <code>argv()</code> 传给 <code>syscall.Exec</code></li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; already in container
&#x2F;&#x2F; initialize the container
func InitProcess() error &#123;
	cmdArray :&#x3D; readCommand()
	if len(cmdArray) &#x3D;&#x3D; 0 &#123;
		return fmt.Errorf(&quot;init process fails, cmdArray is nil&quot;)
	&#125;

	defaultMountFlags :&#x3D; syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV

	&#x2F;&#x2F; mount proc filesystem
	syscall.Mount(&quot;proc&quot;, &quot;&#x2F;proc&quot;, &quot;proc&quot;, uintptr(defaultMountFlags), &quot;&quot;)
	path, err :&#x3D; exec.LookPath(cmdArray[0])
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;initProcess look path failed: %v&quot;, err)
		return err
	&#125;

	&#x2F;&#x2F; log path info
	logrus.Infof(&quot;find path: %v&quot;, path)
	if err :&#x3D; syscall.Exec(path, cmdArray, os.Environ()); err !&#x3D; nil &#123;
		logrus.Errorf(err.Error())
	&#125;
	return nil
&#125;

func readCommand() []string &#123;
	pipe :&#x3D; os.NewFile(uintptr(3), &quot;pipe&quot;)
	msg, err :&#x3D; ioutil.ReadAll(pipe)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;read pipe failed: %v&quot;, err)
		return nil
	&#125;
	return strings.Split(string(msg), &quot; &quot;)
&#125;</code></pre>
<h5 id="dockercommandrun.go">4.7.2 dockerCommand/run.go</h5>
<ol type="1">
<li>在 run.go 向 writePipe 写入参数，这样容器就会获取到参数。</li>
<li>关闭 pipe，使得 init 进程继续进行。</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Run(tty bool, cmdArray []string, res *subsystem.ResourceConfig) &#123;
	initProcess, writePipe :&#x3D; container.NewProcess(tty)

	&#x2F;&#x2F; start the init process
	if err :&#x3D; initProcess.Start(); err !&#x3D; nil &#123;
		logrus.Error(err)
	&#125;

	&#x2F;&#x2F; create container manager to control resource config on all hierarchies
	cm :&#x3D; cgroups.NewCgroupManager(&quot;simple-docker&quot;)
	defer cm.Remove()
	cm.Set(res)
	cm.AddProcess(initProcess.Process.Pid)

	&#x2F;&#x2F; send command to write side
	sendInitCommand(cmdArray, writePipe)

	initProcess.Wait()
	os.Exit(-1)
&#125;

func sendInitCommand(cmdArray []string, writePipe *os.File) &#123;
	cmdString :&#x3D; strings.Join(cmdArray, &quot; &quot;)
	logrus.Infof(&quot;whole init command is: %v&quot;, cmdString)
	writePipe.WriteString(cmdString)
	writePipe.Close()
&#125;</code></pre>
<h5 id="command.go">4.7.3 command.go</h5>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var RunCommand &#x3D; cli.Command&#123;
	Name:  &quot;run&quot;,
	Usage: &quot;Create a container&quot;,
	Flags: []cli.Flag&#123;
		&amp;cli.BoolFlag&#123;
			Name:  &quot;it&quot;,
			Usage: &quot;open a interactive tty(pre sudo terminal)&quot;,
		&#125;,
		&amp;cli.StringFlag&#123;
			Name: &quot;m&quot;,
			Usage: &quot;limit the memory&quot;,
		&#125;,
		&amp;cli.StringFlag&#123;
			Name: &quot;cpu&quot;,
			Usage: &quot;limit the cpu amount&quot;,
		&#125;,
		&amp;cli.StringFlag&#123;
			Name: &quot;cpushare&quot;,
			Usage:&quot;limit the cpu share&quot;,
		&#125;,
	&#125;,
	Action: func(context *cli.Context) error &#123;
		args :&#x3D; context.Args()
		if len(args) &#x3D;&#x3D; 0 &#123;
			return errors.New(&quot;run what?&quot;)
		&#125;
		cmdArray :&#x3D; make([]string,len(args)) &#x2F;&#x2F; command		
		copy(cmdArray,args)

		&#x2F;&#x2F; checkout whether type &#96;-it&#96;
		tty :&#x3D; context.Bool(&quot;it&quot;) &#x2F;&#x2F; pre sudo terminal

		&#x2F;&#x2F; get the resource config
		resourceConfig :&#x3D; subsystem.ResourceConfig &#123;
			MemoryLimit: context.String(&quot;m&quot;),
			CPUShare: context.String(&quot;cpushare&quot;),
			CPUSet: context.String(&quot;cpu&quot;),
		&#125;

		dockerCommand.Run(tty, cmdArray, &amp;resourceConfig)
		return nil
	&#125;,
&#125;

&#x2F;&#x2F; docker init, but cannot be used by user
var InitCommand &#x3D; cli.Command&#123;
	Name:  &quot;init&quot;,
	Usage: &quot;init a container&quot;,
	Action: func(context *cli.Context) error &#123;
		logrus.Infof(&quot;start initializing...&quot;)
		return container.InitProcess()
	&#125;,
&#125;</code></pre>
<h5 id="main.go">4.7.4 main.go</h5>
<p>除了上面的修改，我们还要定义一个程序的入口：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
	&quot;os&quot;
	&quot;github.com&#x2F;sirupsen&#x2F;logrus&quot;
	&quot;github.com&#x2F;urfave&#x2F;cli&quot;
)

const usage &#x3D; &#96;Usage&#96;

func main() &#123;
	app :&#x3D; cli.NewApp()
	app.Name &#x3D; &quot;simple-docker&quot;
	app.Usage &#x3D; usage
	app.Commands &#x3D; []cli.Command&#123;
		RunCommand,
		InitCommand,
	&#125;
	app.Before &#x3D; func(context *cli.Context) error &#123;
		logrus.SetFormatter(&amp;logrus.JSONFormatter&#123;&#125;)
		logrus.SetOutput(os.Stdout)
		return nil
	&#125;
	if err :&#x3D; app.Run(os.Args); err !&#x3D; nil &#123;
		logrus.Fatal(err)
	&#125;
&#125;</code></pre>
<h4 id="运行-demo">4.8 运行 demo</h4>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run . run -it stress -m 100m --vm-bytes 200m --vm-keep -m 1</code></pre>
<p>效果如下：</p>
<p><img src="http://jaydenchang.gitee.io/images/images/0x0035/demo_1.png" /></p>
<p>不过这个运行方式不能进行交互，我们可以使用这个命令来验证我们写的 docker 是否与宿主机隔离：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run . run -it &#x2F;bin&#x2F;sh</code></pre>
<p><img src="http://jaydenchang.gitee.io/images/images/0x0035/demo_sh.png" /></p>
<p>可以看到，pid，ipc，network 方面都与宿主机进行了隔离。</p>
<h2 id="三镜像篇">三、镜像篇</h2>
<h3 id="构造镜像">5. 构造镜像</h3>
<h4 id="编译-aufs-内核">5.1 编译 aufs 内核</h4>
<p>因为电脑硬盘空间不太够，就不使用虚拟机来做实验了，笔者这里使用 WSL2 来完成后续工作，然而，WSL2 Kernel 没有把 aufs 编译进去，那只能换内核了，查阅资料，有两种更换内核的方法：</p>
<ul>
<li><p>直接替换 <code>C:\System32\lxss\tools\kernel</code> 文件</p></li>
<li><p>在 users 目录下新建 <code>.wslconfig</code> 文件：</p>
<pre class="line-numbers language-none"><code class="language-none">[wsl2]
kernel&#x3D;&quot;要替换kernel的路径&quot;</code></pre></li>
</ul>
<p>很明显，我是不会满足于使用别人编译好的内核的，那我也来动手做一个。</p>
<h5 id="准备代码库">5.1.1 准备代码库</h5>
<p>我们先在 WSL 上准备好相关软件包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt update #更新源
apt install build-essential flex bison libssl-dev libelf-dev gcc make</code></pre>
<p>编译内核需要从 GitHub 上 clone 微软官方的 WSL 代码和 AUFS-Standalone 的代码库</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;WSL2-Linux-Kernel kernel
git clone https:&#x2F;&#x2F;github.com&#x2F;sfjro&#x2F;aufs-standalone aufs5</code></pre>
<p>然后查看 WSL 内核版本：在 wsl 下运行命令 <code>uname -r</code></p>
<p>例如我的内核版本是 5.15.19，那 kernel 和 aufs 都要切换到相应的分支去 (kernel 默认就是 5.15.19，故不用切换)</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd aufs5
git checkout aufs5.15.36</code></pre>
<p>然后退回到 kernel 文件夹给代码打补丁：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat ..&#x2F;aufs5&#x2F;aufs5-mmap.patch | patch -p1
cat ..&#x2F;aufs5&#x2F;aufs5-base.patch | patch -p1
cat ..&#x2F;aufs5&#x2F;aufs5-kbuild.patch | patch -p1</code></pre>
<p>三个 Patch 的顺序无关。</p>
<p>然后再复制一点配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp ..&#x2F;aufs5&#x2F;Documentation . -r
cp ..&#x2F;aufs5&#x2F;fs&#x2F; . -r
cp ..&#x2F;aufs5&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;aufs_type.h .&#x2F;include&#x2F;uapi&#x2F;linux</code></pre>
<p>接下来我们来修改一下编译配置，在 <code>Microsoft/config-wsl</code> 中任意位置增加一行：</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">CONFIG_AUFS_FS&#x3D;y</code></pre>
<p>最后，就可以开始编译了！</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make KCONFIG_CONFIG&#x3D;Microsoft&#x2F;config-wsl -j8</code></pre>
<p>过程中会问你一些问题，我除了 AUFS Debug 都选了 y。</p>
<p>最后会在当前目录生成 <code>vmlinuz</code>，在 <code>arch/x86/boot</code> 下生成 <code>bzImage</code>。</p>
<p>关闭 WSL 后更换内核，重启 WSL 输入 <code>grep aufs /proc/filesystems</code>验证结果，如果出现 aufs 的字样，说明操作成功。</p>
<h4 id="使用-busybox-创建容器">5.2 使用 busybox 创建容器</h4>
<h5 id="busybox">5.2.1 busybox</h5>
<p>先在 docker 获取 busybox 镜像并打包成一个 tar 包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull busybox
docker run -d busybox top -b
docker export -o busybox.tar &lt;container_id&gt;</code></pre>
<p>将其复制到 WSL 下并解压。</p>
<h5 id="pivot_root">5.2.2 pivot_root</h5>
<p>pivot_root 是一个系统调用，作用是改变当前 root 文件系统。pivot_root 可以将当前进程的 root 文件系统移动到 put_old 文件夹，然后使 new_root 成为新的 root 文件系统。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func pivotRoot(root string) error &#123;
	&#x2F;&#x2F; remount the root dir, in order to make current root and old root in different file systems
	if err :&#x3D; syscall.Mount(root, root, &quot;bind&quot;, syscall.MS_BIND|syscall.MS_REC, &quot;&quot;); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;mount rootfs to itself error: %v&quot;, err)
	&#125;

	&#x2F;&#x2F; create &#39;rootfs&#x2F;.pivot_root&#39; to store old_root
	pivotDir :&#x3D; filepath.Join(root, &quot;.pivot_root&quot;)
	if err :&#x3D; os.Mkdir(pivotDir, 0777); err !&#x3D; nil &#123;
		return err
	&#125;

	&#x2F;&#x2F; pivot_root mount on new rootfs, old_root mount on rootfs&#x2F;.pivot_root
	if err :&#x3D; syscall.PivotRoot(root, pivotDir); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;pivot_root %v&quot;, err)
	&#125;

	&#x2F;&#x2F; change current work dir to root dir
	if err :&#x3D; syscall.Chdir(&quot;&#x2F;&quot;); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;chdir &#x2F; %v&quot;, err)
	&#125;

	pivotDir &#x3D; filepath.Join(&quot;&#x2F;&quot;, &quot;.pivot_root&quot;)
	&#x2F;&#x2F; umount rootfs&#x2F;.rootfs_root
	if err :&#x3D; syscall.Unmount(pivotDir, syscall.MNT_DETACH); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;umount pivot_root dir %v&quot;, err)
	&#125;

	&#x2F;&#x2F; del the temporary dir
	return os.Remove(pivotDir)
&#125;</code></pre>
<p>有了这个函数就可以在 init 容器进程时，进行一系列的 mount 操作：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func setUpMount() error &#123;
	&#x2F;&#x2F; get current path
	pwd, err :&#x3D; os.Getwd()
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;get current location error: %v&quot;, err)
		return err
	&#125;
	logrus.Infof(&quot;current location: %v&quot;, pwd)
	pivotRoot(pwd)

	&#x2F;&#x2F; mount proc
	defaultMountFlags :&#x3D; syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV
	if err :&#x3D; syscall.Mount(&quot;proc&quot;, &quot;&#x2F;proc&quot;, &quot;proc&quot;, uintptr(defaultMountFlags), &quot;&quot;); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mount &#x2F;proc failed: %v&quot;, err)
		return err
	&#125;

	if err :&#x3D; syscall.Mount(&quot;tmpfs&quot;, &quot;&#x2F;dev&quot;, &quot;tmpfs&quot;, syscall.MS_NOSUID|syscall.MS_STRICTATIME, &quot;mode&#x3D;755&quot;); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mount &#x2F;dev failed: %v&quot;, err)
		return err
	&#125;
	return nil
&#125;</code></pre>
<p>tmpfs 是一种基于内存的文件系统，用 RAM 或 swap 分区来存储。</p>
<p>在 <code>NewParentProcess()</code> 中加一句 <code>cmd.Dir="/root/busybox"</code>。</p>
<p>写完上述函数，然后在 <code>initProcess()</code> 中调用一下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">if err :&#x3D; setUpMount(); err !&#x3D; nil &#123;
    logrus.Errorf(&quot;initProcess look path failed: %v&quot;, err)
&#125;</code></pre>
<p>然后来运行测试一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Jayden: ~# go run . run -it sh
###### dividing live	
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Start initiating...&quot;,&quot;time&quot;:&quot;2023-05-04T11:27:04+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: sh&quot;,&quot;time&quot;:&quot;2023-05-04T11:27:04+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;current location: &#x2F;root&#x2F;busybox&quot;,&quot;time&quot;:&quot;2023-05-04T11:27:04+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Find path: &#x2F;bin&#x2F;sh&quot;,&quot;time&quot;:&quot;2023-05-04T11:27:04+08:00&quot;&#125;
&#x2F; #</code></pre>
<p>可以看到，容器当前目录被虚拟定位到了根目录，其实是在宿主机上映射的 <code>/root/busybox</code>。</p>
<h5 id="用-aufs-包装-busybox">5.2.3 用 AUFS 包装 busybox</h5>
<p>前面提到了，docker 使用 AUFS 存储镜像和容器。docker 在使用镜像启动一个容器时，会新建 2 个 layer：write layer 和 container-init-layer。write layer 是容器唯一的可读写层，container-init-layer 是为容器新建的只读层，用来存储容器启动时传入的系统信息。</p>
<ul>
<li><code>CreateReadOnlyLayer()</code> 新建 <code>busybox</code> 文件夹，解压 <code>busybox.tar</code> 到 <code>busybox</code> 目录下，作为容器只读层。</li>
<li><code>CreateWriteLayer()</code> 新建一个 <code>writeLayer</code> 文件夹，作为容器唯一可写层。</li>
<li><code>CreateMountPoint()</code> 先创建了 <code>mnt</code> 文件夹作为挂载点，再把 <code>writeLayer</code> 目录和 <code>busybox</code> 目录 mount 到 <code>mnt</code> 目录下。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; extra tar to &#39;busybox&#39;, used as the read only layer for container
func CreateReadOnlyLayer(rootURL string) &#123;
	busyboxURL :&#x3D; rootURL + &quot;busybox&#x2F;&quot;
	busyboxTarURL :&#x3D; rootURL + &quot;busybox.tar&quot;
	exist, err :&#x3D; PathExists(busyboxURL)

	if err !&#x3D; nil &#123;
		logrus.Infof(&quot;fail to judge whether dir %s exists. %v&quot;, busyboxURL, err)
	&#125;
	if !exist &#123;
		if err :&#x3D; os.Mkdir(busyboxURL, 0777); err !&#x3D; nil &#123;
			logrus.Errorf(&quot;mkdir dir %s error. %v&quot;, busyboxURL, err)
		&#125;
		if _, err :&#x3D; exec.Command(&quot;tar&quot;, &quot;-xvf&quot;, busyboxTarURL, &quot;-C&quot;, busyboxURL).CombinedOutput(); err !&#x3D; nil &#123;
			logrus.Errorf(&quot;unTar dir %s error %v&quot;, busyboxTarURL, err)
		&#125;
	&#125;
&#125;

&#x2F;&#x2F; create a unique folder as writeLayer
func CreateWriteLayer(rootURL string) &#123;
	writeURL :&#x3D; rootURL + &quot;writeLayer&#x2F;&quot;
	if err :&#x3D; os.Mkdir(writeURL, 0777); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mkdir dir %s error %v&quot;, writeURL, err)
	&#125;
&#125;

func CreateMountPoint(rootURL string, mntURL string) &#123;
	&#x2F;&#x2F; create mnt folder as mount point
	if err :&#x3D; os.Mkdir(mntURL, 0777); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mkdir dir %s error %v&quot;, mntURL, err)
	&#125;
	&#x2F;&#x2F; mount &#39;writeLayer&#39; and &#39;busybox&#39; to &#39;mnt&#39;
	dirs :&#x3D; &quot;dirs&#x3D;&quot; + rootURL + &quot;writeLayer:&quot; + rootURL + &quot;busybox&quot;
	cmd :&#x3D; exec.Command(&quot;mount&quot;, &quot;-t&quot;, &quot;aufs&quot;, &quot;-o&quot;, dirs, &quot;none&quot;, mntURL)
	cmd.Stdout &#x3D; os.Stdout
	cmd.Stderr &#x3D; os.Stderr
	if err :&#x3D; cmd.Run(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;%v&quot;, err)
	&#125;
&#125;

func NewWorkSpace(rootURL, mntURL string) &#123;
	CreateReadOnlyLayer(rootURL)
	CreateWriteLayer(rootURL)
	CreateMountPoint(rootURL, mntURL)
&#125;</code></pre>
<p>接下来在 <code>NewParentProcess()</code> 将容器使用的宿主机目录 <code>/root/busybox</code> 替换为 <code>/root/mnt</code>，这样使用 AUFS 系统启动容器的代码就完成了。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">cmd.ExtraFiles &#x3D; []*os.File&#123;readPipe&#125;
mntURL :&#x3D; &quot;&#x2F;root&#x2F;mnt&#x2F;&quot;
rootURL :&#x3D; &quot;&#x2F;root&#x2F;&quot;
NewWorkSpace(rootURL, mntURL)
cmd.Dir &#x3D; mntURL
return cmd, writePipe</code></pre>
<p>docker 会在删除容器时，把容器对应的 write layer 和 container-init-layer 删除，而保留镜像中所有的内容。</p>
<ul>
<li><code>DeleteMountPoint()</code> 中 umount <code>mnt</code> 目录。</li>
<li>删除 <code>mnt</code> 目录。</li>
<li>在 <code>DeleteWriteLayer()</code> 删除 <code>writeLayer</code> 文件夹。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func DeleteMountPoint(rootURL string, mntURL string) &#123;
	cmd :&#x3D; exec.Command(rootURL, mntURL)
	cmd.Stdout &#x3D; os.Stdout
	cmd.Stderr &#x3D; os.Stderr
	if err :&#x3D; cmd.Run(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;%v&quot;, err)
	&#125;
	if err :&#x3D; os.RemoveAll(mntURL); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;remove dir %s error %v&quot;, mntURL, err)
	&#125;
&#125;

func DeleteWriteLayer(rootURL string) &#123;
	writeURL :&#x3D; rootURL + &quot;writeLayer&#x2F;&quot;
	if err :&#x3D; os.RemoveAll(writeURL); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;remove dir %s error %v&quot;, writeURL, err)
	&#125;
&#125;

func DeleteWorkSpace(rootURL, mntURL string) &#123;
	DeleteMountPoint(rootURL, mntURL)
	DeleteWriteLayer(rootURL)
&#125;</code></pre>
<p>现在来启动一个容器测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Jayden: ~# go run . run -it sh
dirs&#x3D;&#x2F;root&#x2F;writeLayer:&#x2F;root&#x2F;busybox
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Start initiating...&quot;,&quot;time&quot;:&quot;2023-05-04T15:16:43+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: sh&quot;,&quot;time&quot;:&quot;2023-05-04T15:16:43+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;current location: &#x2F;root&#x2F;mnt&quot;,&quot;time&quot;:&quot;2023-05-04T15:16:43+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Find path: &#x2F;bin&#x2F;sh&quot;,&quot;time&quot;:&quot;2023-05-04T15:16:43+08:00&quot;&#125;
&#x2F; #</code></pre>
<p>测试在容器内创建文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F; # mkdir aaa
&#x2F; # touch aaa&#x2F;test.txt</code></pre>
<p>此时我们可以在宿主机终端查看 <code>/root/mnt/writeLayer</code>，可以看到刚才新建的 <code>aaa</code> 文件夹和 <code>test.txt</code>，在我们退出容器后，<code>/root/mnt</code> 文件夹被删除，伴随着刚才创建的文件夹和文件都被删除，而作为镜像的 busybox 仍被保留，且内容未被修改。</p>
<h4 id="实现-volume-数据卷">5.3 实现 volume 数据卷</h4>
<p>上节实现了容器和镜像的分离，但是如果容器退出，容器可写层的所有内容就会被删除，这里使用 volume 来实现容器数据持久化。</p>
<p>先在 <code>command.go</code> 里添加 <code>-v</code> 标签：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var RunCommand &#x3D; cli.Command&#123;
	Name:  &quot;run&quot;,
	Usage: &quot;Create a container&quot;,
	Flags: []cli.Flag&#123;
		&#x2F;&#x2F; integrate -i and -t for convenience
		&amp;cli.BoolFlag&#123;
			Name:  &quot;it&quot;,
			Usage: &quot;open an interactive tty(pseudo terminal)&quot;,
		&#125;,
		&amp;cli.StringFlag&#123;
			Name:  &quot;m&quot;,
			Usage: &quot;limit the memory&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;cpu&quot;,
			Usage: &quot;limit the cpu amount&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;cpushare&quot;,
			Usage: &quot;limit the cpu share&quot;,
		&#125;,
         &#x2F;&#x2F; add &#96;-v&#96; tag
         &amp;cli.StringFlag&#123;
			Name:  &quot;v&quot;,
			Usage: &quot;volume&quot;,
		&#125;,
	&#125;,
	Action: func(context *cli.Context) error &#123;
		args :&#x3D; context.Args()
		if len(args) &lt;&#x3D; 0 &#123;
			return errors.New(&quot;run what?&quot;)
		&#125;

		&#x2F;&#x2F; 转化 cli.Args 为 []string
		cmdArray :&#x3D; make([]string, len(args)) &#x2F;&#x2F; command
		copy(cmdArray, args)

		&#x2F;&#x2F; check whether type &#96;-it&#96;
		tty :&#x3D; context.Bool(&quot;it&quot;) &#x2F;&#x2F; presudo terminal

		&#x2F;&#x2F; get the resource config
		resourceConfig :&#x3D; subsystem.ResourceConfig&#123;
			MemoryLimit: context.String(&quot;m&quot;),
			CPUShare:    context.String(&quot;cpushare&quot;),
			CPUSet:      context.String(&quot;cpu&quot;),
		&#125;
         &#x2F;&#x2F; send volume args to Run()
		volume :&#x3D; context.String(&quot;v&quot;)
		dockerCommand.Run(tty, cmdArray, &amp;resourceConfig,volume)

		return nil
	&#125;,
&#125;</code></pre>
<p>在 <code>Run()</code> 中，把 volume 传给创建容器的 <code>NewParentProcess()</code> 和删除容器文件系统的 <code>DeleteWorkSpace()</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Run(tty bool, cmdArray []string, res *subsystem.ResourceConfig, volume string) &#123;

	&#x2F;&#x2F; this is &quot;docker init &lt;cmdArray&gt;&quot;
	initProcess, writePipe :&#x3D; container.NewParentProcess(tty, volume)
	if initProcess &#x3D;&#x3D; nil &#123;
		logrus.Errorf(&quot;new parent process error&quot;)
		return
	&#125;

	&#x2F;&#x2F; start the init process
	if err :&#x3D; initProcess.Start(); err !&#x3D; nil &#123;
		logrus.Error(err)
	&#125;

	&#x2F;&#x2F; create container manager to control resource config on all hierarchies
	cm :&#x3D; cgroup.NewCgroupManager(&quot;simple-docker-container&quot;)
	defer cm.Remove()
	cm.Set(res)
	cm.AddProcess(initProcess.Process.Pid)

	&#x2F;&#x2F; send command to write side
	&#x2F;&#x2F; will close the plug
	sendInitCommand(cmdArray, writePipe)

	initProcess.Wait()
	rootURL :&#x3D; &quot;&#x2F;root&#x2F;&quot;
	mntURL :&#x3D; &quot;&#x2F;root&#x2F;mnt&#x2F;&quot;
	container.DeleteWorkSpace(rootURL, mntURL, volume)
	os.Exit(0)
&#125;</code></pre>
<p>在 <code>NewWorkSpace()</code> 中，继续把 volume 传给创建容器文件系统的 <code>NewWorkSapce()</code>。</p>
<p>创建容器文件系统过程如下：</p>
<ul>
<li>创建只读层。</li>
<li>创建容器读写层。</li>
<li>创建挂载点并把只读层和读写层挂载到挂载点上。</li>
<li>判断 volume 是否为空，如果是，说明用户没有使用挂载标签，结束创建过程。</li>
<li>不为空，就用 <code>volumeURLExtract()</code> 解析。</li>
<li>当 <code>volumeURLExtract()</code> 返回字符数组长度为 2，且数据元素均不为空时，则执行 <code>MountVolume()</code> 来挂载数据卷。
<ul>
<li>否则提示用户创建数据卷输入值不对。</li>
</ul></li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func NewWorkSpace(rootURL, mntURL, volume string) &#123;
	CreateReadOnlyLayer(rootURL)
	CreateWriteLayer(rootURL)
	CreateMountPoint(rootURL, mntURL)
	if volume !&#x3D; &quot;&quot; &#123;
		volumeURLs :&#x3D; volumeUrlExtract(volume)
		length :&#x3D; len(volumeURLs)
		if length &#x3D;&#x3D; 2 &amp;&amp; volumeURLs[0] !&#x3D; &quot;&quot; &amp;&amp; volumeURLs[1] !&#x3D; &quot;&quot; &#123;
			MountVolume(rootURL, mntURL, volumeURLs)
			logrus.Infof(&quot;%q&quot;, volumeURLs)
		&#125; else &#123;
			logrus.Infof(&quot;volume parameter input is not correct&quot;)
		&#125;
	&#125;
&#125;

func volumeUrlExtract(volume string) []string &#123;
	&#x2F;&#x2F; divide volume by &quot;:&quot;
	return strings.Split(volume, &quot;:&quot;)
&#125;</code></pre>
<p>挂载数据卷过程如下：</p>
<ul>
<li>读取宿主机文件目录 URL，创建宿主机文件目录 (<code>/root/$&#123;parentURL&#125;</code>)</li>
<li>读取容器挂载点 URL，在容器文件系统里创建挂载点 (<code>/root/mnt/$&#123;containerURL&#125;</code>)</li>
<li>把宿主机文件目录挂载到容器挂载点，这样启动容器的过程，对数据卷的处理就完成了。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func MountVolume(rootURL, mntURL string, volumeURLs []string) &#123;
	&#x2F;&#x2F; create host file catalog
	parentURL :&#x3D; volumeURLs[0]
	if err :&#x3D; os.Mkdir(parentURL, 0777); err !&#x3D; nil &#123;
		logrus.Infof(&quot;mkdir parent dir %s error. %v&quot;, parentURL, err)
	&#125;
	&#x2F;&#x2F; create mount point in container file system
	containerURL :&#x3D; volumeURLs[1]
	containerVolumeURL :&#x3D; mntURL + containerURL
	if err :&#x3D; os.Mkdir(containerVolumeURL, 0777); err !&#x3D; nil &#123;
		logrus.Infof(&quot;mkdir container dir %s error. %v&quot;, containerVolumeURL, err)
	&#125;
	&#x2F;&#x2F; mount host file catalog to mount point in container
	dirs :&#x3D; &quot;dirs&#x3D;&quot; + parentURL
	cmd :&#x3D; exec.Command(&quot;mount&quot;, &quot;-t&quot;, &quot;aufs&quot;, &quot;-o&quot;, dirs, &quot;none&quot;, containerVolumeURL)
	cmd.Stdout &#x3D; os.Stdout
	cmd.Stderr &#x3D; os.Stderr
	if err :&#x3D; cmd.Run(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mount volume failed. %v&quot;, err)
	&#125;
&#125;</code></pre>
<p>删除容器文件系统过程如下：</p>
<ul>
<li>在 volume 不为空，且使用 <code>volumeURLExtract()</code> 解析 volume 字符串返回的字符数组长度为 2，数据元素均不为空时，才执行 <code>DeleteMountPointWithVolume()</code> 来处理。</li>
<li>其余情况仍使用前面的 <code>DeleteMountPoint()</code>。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func DeleteWorkSpace(rootURL, mntURL, volume string) &#123;
	if volume !&#x3D; &quot;&quot; &#123;
		volumeURLs :&#x3D; volumeUrlExtract(volume)
		length :&#x3D; len(volumeURLs)
		if length &#x3D;&#x3D; 2 &amp;&amp; volumeURLs[0] !&#x3D; &quot;&quot; &amp;&amp; volumeURLs[1] !&#x3D; &quot;&quot; &#123;
			DeleteMountPointWithVolume(rootURL, mntURL, volumeURLs)
		&#125; else &#123;
			DeleteMountPoint(rootURL, mntURL)
		&#125;
	&#125; else &#123;
		DeleteMountPoint(rootURL, mntURL)
	&#125;
	DeleteWriteLayer(rootURL)
&#125;</code></pre>
<p><code>DeleteMountPointWithVolume()</code> 处理逻辑如下：</p>
<ul>
<li>卸载 volume 挂载点的文件系统 (<code>/root/mnt/$&#123;containerURL&#125;</code>)，保证整个容器挂载点没有再被使用。</li>
<li>卸载整个容器文件系统挂载点 (<code>/root/mnt</code>)。</li>
<li>删除容器文件系统挂载点。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func DeleteMountPointWithVolume(rootURL, mntURL string, volumeURLs []string) &#123;
	&#x2F;&#x2F; umount volume point in container
	containerURL :&#x3D; mntURL + volumeURLs[1]
	cmd :&#x3D; exec.Command(&quot;umount&quot;, containerURL)
	cmd.Stdout &#x3D; os.Stdout
	cmd.Stderr &#x3D; os.Stderr
	if err :&#x3D; cmd.Run(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;umount volume failed. %v&quot;, err)
	&#125;
	&#x2F;&#x2F; umount the whole point of the container
	cmd &#x3D; exec.Command(&quot;umount&quot;, mntURL)
	cmd.Stdout &#x3D; os.Stdout
	cmd.Stderr &#x3D; os.Stderr
	if err :&#x3D; cmd.Run(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;umount mountpoint failed. %v&quot;, err)
	&#125;
	if err :&#x3D; os.RemoveAll(mntURL); err !&#x3D; nil &#123;
		logrus.Infof(&quot;remove mountpoint dir %s error %v&quot;, mntURL, err)
	&#125;
&#125;</code></pre>
<p>接下来启动容器测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -it -v &#x2F;root&#x2F;volume:&#x2F;containerVolume sh
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;[\&quot;&#x2F;root&#x2F;volume\&quot; \&quot;&#x2F;containerVolume\&quot;]&quot;,&quot;time&quot;:&quot;2023-05-05T09:25:43+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: sh&quot;,&quot;time&quot;:&quot;2023-05-05T09:25:43+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Start initiating...&quot;,&quot;time&quot;:&quot;2023-05-05T09:25:43+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;current location: &#x2F;root&#x2F;mnt&quot;,&quot;time&quot;:&quot;2023-05-05T09:25:43+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Find path: &#x2F;bin&#x2F;sh&quot;,&quot;time&quot;:&quot;2023-05-05T09:25:43+08:00&quot;&#125;
&#x2F; # ls
bin              dev              home             lib64            root             tmp              var
containerVolume  etc              lib              proc             sys              usr
&#x2F; #</code></pre>
<p>进入 <code>containerVolume</code>，创建一个 文本文件，并随便写点东西：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd containerVolume
echo -e &quot;test&quot; &gt;&gt; test.txt</code></pre>
<p>此时我们能在宿主机的 <code>/root/volume</code> 找到我们刚才创建的文本文件。退出容器后，volume 文件夹也没有被删除。再次进入容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">r# go run . run -it -v &#x2F;root&#x2F;volume:&#x2F;containerVolume sh
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;mkdir parent dir &#x2F;root&#x2F;volume error. mkdir &#x2F;root&#x2F;volume: file exists&quot;,&quot;time&quot;:&quot;2023-05-05T09:29:24+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;[\&quot;&#x2F;root&#x2F;volume\&quot; \&quot;&#x2F;containerVolume\&quot;]&quot;,&quot;time&quot;:&quot;2023-05-05T09:29:24+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: sh&quot;,&quot;time&quot;:&quot;2023-05-05T09:29:24+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Start initiating...&quot;,&quot;time&quot;:&quot;2023-05-05T09:29:24+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;current location: &#x2F;root&#x2F;mnt&quot;,&quot;time&quot;:&quot;2023-05-05T09:29:24+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Find path: &#x2F;bin&#x2F;sh&quot;,&quot;time&quot;:&quot;2023-05-05T09:29:24+08:00&quot;&#125;
&#x2F; # ls
bin              dev              home             lib64            root             tmp              var
containerVolume  etc              lib              proc             sys              usr
&#x2F; # ls containerVolume&#x2F;
test.txt</code></pre>
<p>此时这里会提示 volume 文件夹存在，我们在 <code>test.txt</code> 内追加内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd containerVolume
echo -e &quot;###&quot; &gt;&gt; test.txt</code></pre>
<p>此时再次退出容器，能看到修改过后的文件内容，可以看到 volume 文件夹没有被删除。</p>
<h4 id="简单镜像打包">5.4 简单镜像打包</h4>
<p>容器在退出时会删除所有可写层的内容，commit 命令可以把运行状态容器的内容存储为镜像保存下来。</p>
<p>在 <code>main.go</code> 里添加 <code>commit</code> 命令：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">app.Commands &#x3D; []cli.Command&#123;
    InitCommand,
    RunCommand,
    CommitCommand,
&#125;</code></pre>
<p>然后在 <code>command.go</code> 里实现 <code>CommitCommand</code> 命令：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var CommitCommand &#x3D; cli.Command&#123;
	Name:  &quot;commit&quot;,
	Usage: &quot;commit a container into image&quot;,
	Action: func(context *cli.Context) error &#123;
		if len(context.Args()) &lt; 1 &#123;
			return fmt.Errorf(&quot;missing container name&quot;)
		&#125;
		imageName :&#x3D; context.Args()[0]
		&#x2F;&#x2F; commitContainer(containerName)
		commitContainer(imageName)
		return nil
	&#125;,
&#125;</code></pre>
<p>添加 <code>commit.go</code>，通过 <code>commitContainer()</code> 实现将容器文件系统打包成 <code>$&#123;imagename&#125;.tar</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
	&quot;os&#x2F;exec&quot;

	&quot;github.com&#x2F;sirupsen&#x2F;logrus&quot;
)

func commitContainer(imageName string) &#123;
	mntURL :&#x3D; &quot;&#x2F;root&#x2F;mnt&quot;
	imageTar :&#x3D; &quot;&#x2F;root&#x2F;&quot; + imageName + &quot;.tar&quot;
	if _, err :&#x3D; exec.Command(&quot;tar&quot;, &quot;-czf&quot;, imageTar, &quot;-C&quot;, mntURL, &quot;.&quot;).CombinedOutput(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;tar folder %s error %v&quot;, mntURL, err)
	&#125;
&#125;</code></pre>
<p>运行测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -it sh</code></pre>
<p>然后在另一个终端运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . commit image</code></pre>
<p>这时候可以在 root 目录下看到多了一个 <code>image.tar</code> ，解压后可以发现压缩包的内容和 <code>/root/mnt</code> 一致。</p>
<blockquote>
<p>tips：一定要先运行容器！如果不运行容器直接打包，会提示 <code>/root/mnt</code> 不存在。</p>
</blockquote>
<h3 id="构建容器进阶">6. 构建容器进阶</h3>
<h4 id="实现容器后台运行">6.1 实现容器后台运行</h4>
<p>容器，放在操作系统层面，就是一个进程，当前运行命令的 simple-docker 是主进程，容器是当前 simple-docker 进程 fork 出来的子进程。子进程的结束和父进程的运行是一个异步的过程，即父进程不会知道子进程在什么时候结束。如果创建子进程时，父进程退出，那这个子进程就是孤儿进程 (没人管)，此时进程号为 1 的进程 init 就会接受这些孤儿进程。</p>
<p>先在 <code>command.go</code> 添加 <code>-d</code> 标签，表示这个容器启动时在后台运行：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var RunCommand &#x3D; cli.Command&#123;
	Name:  &quot;run&quot;,
	Usage: &quot;Create a container&quot;,
	Flags: []cli.Flag&#123;
		&#x2F;&#x2F; integrate -i and -t for convenience
		&amp;cli.BoolFlag&#123;
			Name:  &quot;it&quot;,
			Usage: &quot;open an interactive tty(pseudo terminal)&quot;,
		&#125;,
		&amp;cli.StringFlag&#123;
			Name:  &quot;m&quot;,
			Usage: &quot;limit the memory&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;cpu&quot;,
			Usage: &quot;limit the cpu amount&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;cpushare&quot;,
			Usage: &quot;limit the cpu share&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;v&quot;,
			Usage: &quot;volume&quot;,
		&#125;, &amp;cli.BoolFlag&#123;
			Name: &quot;d&quot;,
			Usage :&quot;detach container&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name: &quot;cpuset&quot;,
			Usage: &quot;limit the cpuset&quot;,
		&#125;,
	&#125;,
	Action: func(context *cli.Context) error &#123;
		args :&#x3D; context.Args()
		if len(args) &lt;&#x3D; 0 &#123;
			return errors.New(&quot;run what?&quot;)
		&#125;

		&#x2F;&#x2F; 转化 cli.Args 为 []string
		cmdArray :&#x3D; make([]string, len(args)) &#x2F;&#x2F; command
		copy(cmdArray, args)

		&#x2F;&#x2F; check whether type &#96;-it&#96;
		tty :&#x3D; context.Bool(&quot;it&quot;) &#x2F;&#x2F; presudo terminal
		detach :&#x3D; context.Bool(&quot;d&quot;) &#x2F;&#x2F; detach container

         &#x2F;&#x2F; tty cannot work with detach
		if tty &amp;&amp; detach &#123;
			return fmt.Errorf(&quot;it and d paramter cannot both privided&quot;)
		&#125;

		&#x2F;&#x2F; get the resource config
		resourceConfig :&#x3D; subsystem.ResourceConfig&#123;
			MemoryLimit: context.String(&quot;m&quot;),
			CPUShare:    context.String(&quot;cpushare&quot;),
			CPUSet:      context.String(&quot;cpu&quot;),
		&#125;
		volume :&#x3D; context.String(&quot;v&quot;)
		dockerCommand.Run(tty, cmdArray, &amp;resourceConfig, volume)

		return nil
	&#125;,
&#125;</code></pre>
<p>然后也要修改一下 <code>run.go</code> 的 <code>Run()</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Run(tty bool, cmdArray []string, res *subsystem.ResourceConfig, volume string) &#123;

	&#x2F;&#x2F; this is &quot;docker init &lt;cmdArray&gt;&quot;
	initProcess, writePipe :&#x3D; container.NewParentProcess(tty, volume)
	if initProcess &#x3D;&#x3D; nil &#123;
		logrus.Errorf(&quot;new parent process error&quot;)
		return
	&#125;

	&#x2F;&#x2F; start the init process
	if err :&#x3D; initProcess.Start(); err !&#x3D; nil &#123;
		logrus.Error(err)
	&#125;

	&#x2F;&#x2F; create container manager to control resource config on all hierarchies
	cm :&#x3D; cgroup.NewCgroupManager(&quot;simple-docker-container&quot;)
	defer cm.Remove()
	cm.Set(res)
	cm.AddProcess(initProcess.Process.Pid)

	&#x2F;&#x2F; send command to write side
	&#x2F;&#x2F; will close the plug
	sendInitCommand(cmdArray, writePipe)

    &#x2F;&#x2F; if background process, parent process won&#39;t wait
	if tty &#123;
		initProcess.Wait()
	&#125;
	rootURL :&#x3D; &quot;&#x2F;root&#x2F;&quot;
	mntURL :&#x3D; &quot;&#x2F;root&#x2F;mnt&#x2F;&quot;
	container.DeleteWorkSpace(rootURL, mntURL, volume)
	os.Exit(0)
&#125;</code></pre>
<p>测试一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -d top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-05T15:32:44+08:00&quot;&#125;</code></pre>
<p>根据书上的提示，<code>ps -ef</code> 用来查找 top 进程：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ps -ef | grep top
root        3713     751  0 14:42 pts&#x2F;2    00:00:00 top</code></pre>
<p>前面几次运行命令，都找不到 top 这个进程，于是我后面多跑了几次，终于看到了这个进程。。。</p>
<p>可以看到，top 命令的进程正在运行着，不过运行环境是 WSL，父进程 id 不是 1，然后 <code>ps -ef</code> 查看一下，top 的父进程是一个 bash 进程，而 bash 进程的父进程是一个 init 进程，这样应该算过了吧 (偶尔的一两次不严谨)。</p>
<h4 id="实现查看运行中的容器">6.2 实现查看运行中的容器</h4>
<h5 id="name-标签">6.2.1 name 标签</h5>
<p>前面创建的容器里，所有关于容器的信息，例如 PID、容器创建时间、容器运行命令等，都没有记录，这导致容器运行完后就在也不知道它的信息了，因此要把这部分信息保留。先在 <code>command.go</code> 里加一个 name 标签，方便用户指定容器的名字：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var RunCommand &#x3D; cli.Command&#123;
	Name:  &quot;run&quot;,
	Usage: &quot;Create a container&quot;,
	Flags: []cli.Flag&#123;
		&#x2F;&#x2F; integrate -i and -t for convenience
		&amp;cli.BoolFlag&#123;
			Name:  &quot;it&quot;,
			Usage: &quot;open an interactive tty(pseudo terminal)&quot;,
		&#125;,
		&amp;cli.StringFlag&#123;
			Name:  &quot;m&quot;,
			Usage: &quot;limit the memory&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;cpu&quot;,
			Usage: &quot;limit the cpu amount&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;cpushare&quot;,
			Usage: &quot;limit the cpu share&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;v&quot;,
			Usage: &quot;volume&quot;,
		&#125;, &amp;cli.BoolFlag&#123;
			Name: &quot;d&quot;,
			Usage :&quot;detach container&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name: &quot;cpuset&quot;,
			Usage: &quot;limit the cpuset&quot;,
		&#125;, &amp;cli.StringFlag &#123;
			Name: &quot;name&quot;,
			Usage: &quot;container name&quot;,
		&#125;,
	&#125;,
	Action: func(context *cli.Context) error &#123;
		args :&#x3D; context.Args()
		if len(args) &lt;&#x3D; 0 &#123;
			return errors.New(&quot;run what?&quot;)
		&#125;

		&#x2F;&#x2F; 转化 cli.Args 为 []string
		cmdArray :&#x3D; make([]string, len(args)) &#x2F;&#x2F; command
		copy(cmdArray, args)

		&#x2F;&#x2F; check whether type &#96;-it&#96;
		tty :&#x3D; context.Bool(&quot;it&quot;) &#x2F;&#x2F; presudo terminal
		detach :&#x3D; context.Bool(&quot;d&quot;) &#x2F;&#x2F; detach container

		if tty &amp;&amp; detach &#123;
			return fmt.Errorf(&quot;it and d paramter cannot both privided&quot;)
		&#125;

		&#x2F;&#x2F; get the resource config
		resourceConfig :&#x3D; subsystem.ResourceConfig&#123;
			MemoryLimit: context.String(&quot;m&quot;),
			CPUShare:    context.String(&quot;cpushare&quot;),
			CPUSet:      context.String(&quot;cpu&quot;),
		&#125;
		volume :&#x3D; context.String(&quot;v&quot;)
		containerName :&#x3D; context.String(&quot;name&quot;)
		dockerCommand.Run(tty, cmdArray, &amp;resourceConfig, volume, containerName)

		return nil
	&#125;,
&#125;</code></pre>
<p>添加一个方法来记录容器的相关信息，这里用先用一个 10 位的数字来表示容器的 id：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func randStringBytes(n int) string &#123;
	letterBytes :&#x3D; &quot;1234567890&quot;
	rand.Seed(time.Now().UnixNano())
	b :&#x3D; make([]byte, n)
	for i :&#x3D; range b &#123;
		b[i] &#x3D; letterBytes[rand.Intn(len(letterBytes))]
	&#125;
	return string(b)
&#125;</code></pre>
<p>这里用时间戳为种子，每次生成一个 10 以内的数字作为 letterBytes 数组的下标，最后拼成整个容器的 id。容器的信息默认保存在 <code>/var/run/simple-docker/$&#123;containerName&#125;/config.json</code>，容器基本格式如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type ContainerInfo struct &#123;
	Pid         string &#96;json:&quot;pid&quot;&#96;
	Id          string &#96;json:&quot;id&quot;&#96;
	Name        string &#96;json:&quot;name&quot;&#96;
	Command     string &#96;json:&quot;command&quot;&#96; &#x2F;&#x2F; the command that init process execute
	CreatedTime string &#96;json:&quot;created_time&quot;&#96;
	Status      string &#96;json:&quot;status&quot;&#96;
&#125;

var (
	RUNNING             string &#x3D; &quot;running&quot;
	STOP                string &#x3D; &quot;stopped&quot;
	Exit                string &#x3D; &quot;exited&quot;
	DefaultInfoLocation string &#x3D; &quot;&#x2F;var&#x2F;run&#x2F;simple-docker&#x2F;%s&quot;
	ConfigName          string &#x3D; &quot;config.json&quot;
)</code></pre>
<p>下面是记录容器信息：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func recordContainerInfo(containerPID int, commandArray []string, containerName string) (string, error) &#123;
	&#x2F;&#x2F; create an ID that length is 10
	id :&#x3D; randStringBytes(10)
	createTime :&#x3D; time.Now().Format(&quot;2006-01-02 15:04:05&quot;) &#x2F;&#x2F; format must like this
	command :&#x3D; strings.Join(commandArray, &quot;&quot;)
	&#x2F;&#x2F; if containerName is nil, make containerID as name
	if containerName &#x3D;&#x3D; &quot;&quot; &#123;
		containerName &#x3D; id
	&#125;
	containerInfo :&#x3D; &amp;container.ContainerInfo&#123;
		Id:          id,
		Pid:         strconv.Itoa(containerPID),
		Command:     command,
		CreatedTime: createTime,
		Status:      container.RUNNING,
		Name:        containerName,
	&#125;
	&#x2F;&#x2F; trun containerInfo info string
	jsonBytes, err :&#x3D; json.Marshal(containerInfo)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;record container info error: %v&quot;, err)
		return &quot;&quot;, err
	&#125;
	jsonStr :&#x3D; string(jsonBytes)

	&#x2F;&#x2F; container path
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerName)
	if err :&#x3D; os.MkdirAll(dirURL, 0622); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mkdir error %s error: %v&quot;, dirURL, err)
		return &quot;&quot;, err
	&#125;
	fileName :&#x3D; dirURL + &quot;&#x2F;&quot; + container.ConfigName
	&#x2F;&#x2F; create config.json
	file, err :&#x3D; os.Create(fileName)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;create %s error %v&quot;, fileName, err)
		return &quot;&quot;, err
	&#125;
	defer file.Close()
	&#x2F;&#x2F; write jsonify data to file
	if _, err :&#x3D; file.WriteString(jsonStr); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;write %s error %v&quot;, fileName, err)
		return &quot;&quot;, err
	&#125;
	return containerName, nil
&#125;</code></pre>
<p>这里格式化的时间必须是 <code>2006-01-02 15:04:05</code>，不然格式化后的时间会是几千年后 doge。</p>
<p>详细可以看这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fangford/article/details/107728458">goland时间格式化time.Now().Format_golang time.now().format_好狗不见的博客-CSDN博客</a></p>
<p>在主函数加上调用：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Run(tty bool, cmdArray []string, res *subsystem.ResourceConfig, volume, containerName string) &#123;

	&#x2F;&#x2F; this is &quot;docker init &lt;cmdArray&gt;&quot;
	initProcess, writePipe :&#x3D; container.NewParentProcess(tty, volume)
	if initProcess &#x3D;&#x3D; nil &#123;
		logrus.Errorf(&quot;new parent process error&quot;)
		return
	&#125;

	&#x2F;&#x2F; start the init process
	if err :&#x3D; initProcess.Start(); err !&#x3D; nil &#123;
		logrus.Error(err)
	&#125;
	&#x2F;&#x2F; container info
	containerName, err :&#x3D; recordContainerInfo(initProcess.Process.Pid, cmdArray, containerName)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;record container info error: %v&quot;, err)
		return
	&#125;

	&#x2F;&#x2F; create container manager to control resource config on all hierarchies
	cm :&#x3D; cgroup.NewCgroupManager(&quot;simple-docker-container&quot;)
	defer cm.Remove()
	cm.Set(res)
	cm.AddProcess(initProcess.Process.Pid)

	&#x2F;&#x2F; send command to write side
	&#x2F;&#x2F; will close the plug
	sendInitCommand(cmdArray, writePipe)

	if tty &#123;
		initProcess.Wait()
		deleteContainerInfo(containerName)
	&#125;
	rootURL :&#x3D; &quot;&#x2F;root&#x2F;&quot;
	mntURL :&#x3D; &quot;&#x2F;root&#x2F;mnt&#x2F;&quot;
	container.DeleteWorkSpace(rootURL, mntURL, volume)
	os.Exit(0)
&#125;</code></pre>
<p>如果创建 tty 方式的容器，在容器退出后，就会删除相关信息：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func deleteContainerInfo(containerID string) &#123;
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerID)
	if err :&#x3D; os.RemoveAll(dirURL); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;remove dir %s error %v&quot;, dirURL, err)
	&#125;
&#125;</code></pre>
<p>测试一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -d top
# go run . run -d --name jay top</code></pre>
<p>执行完成后，可以在 <code>/var/run/simple-docker/</code> 找到两个文件夹，一个是随机 id，一个是 jay，文件夹下各有一个 <code>config.json</code>，记录了容器的相关信息。</p>
<h5 id="实现-docker-ps">6.2.2 实现 docker ps</h5>
<p>在 <code>main.go</code> 加一个 <code>listCommand</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">app.Commands &#x3D; []cli.Command&#123;
    RunCommand,
    InitCommand,
    CommitCommand,
    ListCommand,
&#125;</code></pre>
<p>在 <code>command.go</code> 添加定义：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var ListCommand &#x3D; cli.Command&#123;
	Name: &quot;ps&quot;,
	Usage: &quot;list all the containers&quot;,
	Action: func(context *cli.Context) error &#123;
		ListContainers()
		return nil
	&#125;,
&#125;</code></pre>
<p>新建一个 <code>list.go</code>，实现记录列出容器信息：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func ListContainers() &#123;
	&#x2F;&#x2F; get the path that store the info of the container
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, &quot;&quot;)
	dirURL &#x3D; dirURL[:len(dirURL)-1]
	&#x2F;&#x2F; read all the files in the directory
	files, err :&#x3D; ioutil.ReadDir(dirURL)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;read dir %s error %v&quot;, dirURL, err)
		return
	&#125;
	var containers []*container.ContainerInfo
	for _, file :&#x3D; range files &#123;
		tmpContainer, err :&#x3D; getContainerInfo(file)
		&#x2F;&#x2F; .Println(tmpContainer)
		if err !&#x3D; nil &#123;
			logrus.Errorf(&quot;get container info error %v&quot;, err)
			continue
		&#125;
		containers &#x3D; append(containers, tmpContainer)
	&#125;
	&#x2F;&#x2F; use tabwriter.NewWriter to print the containerInfo
	w :&#x3D; tabwriter.NewWriter(os.Stdout, 12, 1, 3, &#39; &#39;, 0)
	fmt.Fprintf(w, &quot;ID\tNAME\tPID\tSTATUS\tCOMMAND\tCREATED\n&quot;)
	for _, item :&#x3D; range containers &#123;
		fmt.Fprintf(w, &quot;%s\t%s\t%s\t%s\t%s\t%s\n&quot;,
			item.Id, item.Name, item.Pid, item.Status, item.Command, item.CreatedTime)
	&#125;
	&#x2F;&#x2F; refresh stdout 
	if err :&#x3D; w.Flush(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;flush stdout error %v&quot;,err)
		return
	&#125;
&#125;

func getContainerInfo(file os.FileInfo) (*container.ContainerInfo, error) &#123;
	containerName :&#x3D; file.Name()
	&#x2F;&#x2F; create the absolute path
	configFileDir :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerName)
	configFileDir &#x3D; configFileDir + &quot;&#x2F;&quot; + container.ConfigName
	&#x2F;&#x2F; read config.json
	content, err :&#x3D; ioutil.ReadFile(configFileDir)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;read file %s error %v&quot;, configFileDir, err)
		return nil, err
	&#125;
	var containerInfo container.ContainerInfo
	&#x2F;&#x2F; turn json to containerInfo
	if err :&#x3D; json.Unmarshal(content, &amp;containerInfo); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;unmarshal json error %v&quot;, err)
		return nil, err
	&#125;
	return &amp;containerInfo, nil
&#125;</code></pre>
<p>接上小节的测试，我们运行以下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -d top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-05T19:29:11+08:00&quot;&#125;
# go run . run -d --name jay top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-05T19:29:25+08:00&quot;&#125;
# go run . ps
ID           NAME         PID         STATUS      COMMAND     CREATED
6675792962   6675792962   4317        running     top         2023-05-05 19:29:11
5553437308   jay          4404        running     top         2023-05-05 19:29:25</code></pre>
<p>现在就可以通过 ps 来看到所有创建的容器状态和它们的 init 进程 id 了。</p>
<h4 id="查看容器日志">6.3 查看容器日志</h4>
<p>在 <code>main.go</code> 加一个 <code>logCommand</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">app.Commands &#x3D; []cli.Command&#123;
    RunCommand,
    InitCommand,
    CommitCommand,
    ListCommand,
    LogCommand,
&#125;</code></pre>
<p>然后在 <code>command.go</code> 里添加 <code>logCommand</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var LogCommand &#x3D; cli.Command&#123;
	Name:  &quot;logs&quot;,
	Usage: &quot;print logs of a container&quot;,
	Action: func(context *cli.Context) error &#123;
		if len(context.Args()) &lt; 1 &#123;
			return fmt.Errorf(&quot;missing container name&quot;)
		&#125;
		contianerName :&#x3D; context.Args()[0]
		logContainer(contianerName)
		return nil
	&#125;,
&#125;</code></pre>
<p>新建一个 <code>log.go</code>，定义 <code>logContainer()</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func logContainer(containerName string) &#123;
	&#x2F;&#x2F; get the log path
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerName)
	logFileLocation :&#x3D; dirURL + &quot;&#x2F;&quot; + container.ContainerLogFile
	&#x2F;&#x2F; open log file
	file, err :&#x3D; os.Open(logFileLocation)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;log container open file %s error: %v&quot;, logFileLocation, err)
		return
	&#125;
	defer file.Close()
	&#x2F;&#x2F; read log file content
	content, err :&#x3D; ioutil.ReadAll(file)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;log container read file %s error: %v&quot;, logFileLocation, err)
		return
	&#125;
	&#x2F;&#x2F; use Fprint to transfer content to stdout
	fmt.Fprint(os.Stdout, string(content))
&#125;	</code></pre>
<p>测试一下，先用 detach 方式创建一个容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -d --name jay top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-06T14:26:32+08:00&quot;&#125;
# go run . ps
ID           NAME        PID         STATUS      COMMAND     CREATED
1837062451   jay         2065        running     top         2023-05-06 14:26:32
# go run . logs jay
Mem: 3265116K used, 4568420K free, 3256K shrd, 71432K buff, 1135692K cached
CPU:  0.3% usr  0.2% sys  0.0% nic 99.3% idle  0.0% io  0.0% irq  0.0% sirq
Load average: 0.03 0.09 0.08 1&#x2F;521 5
PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND</code></pre>
<p>可以看到，logs 命令成功运行并输出容器的日志。(这里之前出现过前几次创建容器，而后台却没运行的情况，导致一开始运行 logs 时报错了，建议在运行 logs 前多检查下 top 是否后台运行中)</p>
<h4 id="进入容器-namespace">6.4 进入容器 Namespace</h4>
<p>在 6.3 小节里，实现了查看后台运行的容器的日志，但是容器一旦创建后，就无法再次进入容器，这一次来实现进入容器内部的功能，也就是 exec。</p>
<h5 id="setns">6.4.1 setns</h5>
<p>setns 是一个系统调用，可根据提供的 PID 再次进入到指定的 Namespace。它要先打开 <code>/proc/$&#123;pid&#125;/ns</code> 文件夹下对应的文件，然后使当前进程进入到指定的 Namespace 中。对于 go 来说，一个有多线程的进程使无法使用 setns 调用进入到对应的命名空间的，go 没启动一个程序就会进入多线程状态，因此无法简单在 go 里直接调用系统调用，这里还需要借助 C 来实现这个功能。</p>
<h5 id="cgo">6.4.2 Cgo</h5>
<p>在 go 里写 C：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package rand
&#x2F;*
#include &lt;stdlib.h&gt;
*&#x2F;
import &quot;C&quot;

func Random() int &#123;
    return int(C.random())
&#125;

func Seed(i int) &#123;
    C.srandom(C.uint(i))
&#125;</code></pre>
<h5 id="实现">6.4.3 实现</h5>
<p>先使用 C 根据 PID进入对应 Namespace：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package nsenter

&#x2F;*
#define _GNU_SOURCE
#include &lt;errno.h&gt;
#include &lt;sched.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

&#x2F;&#x2F; if this package is quoted, this function will run automatic
__attribute__((constructor)) void enter_namespace(void)
&#123;
    char *simple_docker_pid;
    &#x2F;&#x2F; get pid from system environment
    simple_docker_pid &#x3D; getenv(&quot;simple_docker_pid&quot;);
    if (simple_docker_pid)
    &#123;
        fprintf(stdout, &quot;got simple docker pid&#x3D;%s\n&quot;, simple_docker_pid);
    &#125;
    else
    &#123;
        fprintf(stdout, &quot;missing simple docker pid env skip nsenter&quot;);
        &#x2F;&#x2F; if no specified pid, the func will exit
        return;
    &#125;

    char *simple_docker_cmd;
    simple_docker_cmd &#x3D; getenv(&quot;simple_docker_cmd&quot;);
    if (simple_docker_cmd)
    &#123;
        fprintf(stdout, &quot;got simple docker cmd&#x3D;%s\n&quot;, simple_docker_cmd);
    &#125;
    else
    &#123;
        fprintf(stdout, &quot;missing simple docker cmd env skip nsenter&quot;);
        &#x2F;&#x2F; if no specified cmd, the func will exit
        return;
    &#125;
    int i;
    char nspath[1024];

    char *namespace[] &#x3D; &#123;&quot;ipc&quot;, &quot;uts&quot;, &quot;net&quot;, &quot;pid&quot;, &quot;mnt&quot;&#125;;

    for (i &#x3D; 0; i &lt; 5; i++)
    &#123;
        &#x2F;&#x2F; create the target path, like &#x2F;proc&#x2F;pid&#x2F;ns&#x2F;ipc
        sprintf(nspath, &quot;&#x2F;proc&#x2F;%s&#x2F;ns&#x2F;%s&quot;, simple_docker_pid, namespace[i]);
        int fd &#x3D; open(nspath, O_RDONLY);
		printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; %d %s\n&quot;, fd, nspath);
        &#x2F;&#x2F; call sentns and enter the target namespace
        if (setns(fd, 0) &#x3D;&#x3D; -1)
        &#123;
            fprintf(stderr, &quot;setns on %s namespace failed: %s\n&quot;, namespace[i], strerror(errno));
        &#125;
        else
        &#123;
            fprintf(stdout, &quot;setns on %s namespace succeeded\n&quot;, namespace[i]);
        &#125;
        close(fd);
    &#125;
    &#x2F;&#x2F; run command in target namespace
    int res &#x3D; system(simple_docker_cmd);
    exit(0);
    return;
&#125;
*&#x2F;

import &quot;C&quot;</code></pre>
<p>那如何使用这段代码呢，只需要在要加载的地方引用这个 package 即可，我这里是 <code>nenster</code> 。</p>
<p>其实也可以，单独放在一个 C 文件里，go 文件可以这样写：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package nsenter

import &quot;C&quot;</code></pre>
<p>下面增加 <code>ExecCommand</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var ExecCommand &#x3D; cli.Command&#123;
	Name:  &quot;exec&quot;,
	Usage: &quot;exec a command into container&quot;,
	Action: func(context *cli.Context) error &#123;
		if os.Getenv(ENV_EXEC_PID) !&#x3D; &quot;&quot; &#123;
			logrus.Infof(&quot;pid callback pid %v&quot;, os.Getgid())
			return nil
		&#125;
		if len(context.Args()) &lt; 2 &#123;
			return fmt.Errorf(&quot;missing container name or command&quot;)
		&#125;
		containerName :&#x3D; context.Args()[0]
		cmdArray :&#x3D; make([]string, len(context.Args())-1)
		for i, v :&#x3D; range context.Args().Tail() &#123;
			cmdArray[i] &#x3D; v
		&#125;
		ExecContainer(containerName, cmdArray)
		return nil
	&#125;,
&#125;</code></pre>
<p>新建一个 <code>exec.go</code> 下面实现获取容器名和需要的命令，并且在这里引用 <code>nsenter</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">const ENV_EXEC_PID &#x3D; &quot;simple_docker_pid&quot;
const ENV_EXEC_CMD &#x3D; &quot;simple_docker_cmd&quot;

func getContainerPidByName(containerName string) (string, error) &#123;
	&#x2F;&#x2F; get the path that store container info
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerName)
	configFilePath :&#x3D; dirURL + &quot;&#x2F;&quot; + container.ConfigName
	&#x2F;&#x2F; read files in target path
	contentBytes, err :&#x3D; ioutil.ReadFile(configFilePath)
	if err !&#x3D; nil &#123;
		return &quot;&quot;, err
	&#125;
	var containerInfo container.ContainerInfo
	&#x2F;&#x2F; unmarshal json to containerInfo
	if err :&#x3D; json.Unmarshal(contentBytes, &amp;containerInfo); err !&#x3D; nil &#123;
		return &quot;&quot;, err
	&#125;
	return containerInfo.Pid, nil
&#125;

func ExecContainer(containerName string, comArray []string) &#123;
	&#x2F;&#x2F; get the pid according the containerName
	pid, err :&#x3D; getContainerPidByName(containerName)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;exec container getContainerPidByName %s error %v&quot;, containerName, err)
		return
	&#125;
	&#x2F;&#x2F; divide command by blank space and combine as a string
	cmdStr :&#x3D; strings.Join(comArray, &quot; &quot;)
	logrus.Infof(&quot;container pid %s&quot;, pid)
	logrus.Infof(&quot;command %s&quot;, cmdStr)

	cmd :&#x3D; exec.Command(&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot;, &quot;exec&quot;)
	cmd.Stdin &#x3D; os.Stdin
	cmd.Stdout &#x3D; os.Stdout
	cmd.Stderr &#x3D; os.Stderr

	err &#x3D; os.Setenv(ENV_EXEC_PID, pid)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;set env exec pid %s error %v&quot;, pid, err)
	&#125;
	err &#x3D; os.Setenv(ENV_EXEC_CMD, cmdStr)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;set env exec command %s error %v&quot;, cmdStr, err)
	&#125;

	if err :&#x3D; cmd.Run(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;exec container %s error %v&quot;, containerName, err)
	&#125;
&#125;</code></pre>
<p>测试一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run --name jay -d top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-07T13:23:09+08:00&quot;&#125;
# go run . ps
ID           NAME        PID         STATUS      COMMAND     CREATED
6530018751   jay         146639      running     top         2023-05-07 13:23:09
# go run . logs jay
Mem: 4355160K used, 3478372K free, 3272K shrd, 208844K buff, 1581396K cached
CPU:  1.2% usr  0.6% sys  0.0% nic 97.9% idle  0.0% io  0.0% irq  0.1% sirq
Load average: 0.12 0.14 0.16 1&#x2F;574 6
  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND
# go run . exec jay sh
&#x2F; # ls
bin    dev    etc    home   lib    lib64  proc   root   sys    tmp    usr    var
&#x2F; # ps -ef
PID   USER     TIME  COMMAND
    1 root      0:00 top
   13 root      0:00 sh
   15 root      0:00 ps -ef
&#x2F; #</code></pre>
<p>可以看到，成功进入容器内部，且与宿主机隔离。</p>
<p>这里出现了一个很奇怪的 bug，就是通过 cgo 去 setns，执行到 mnt 时，抛出个错误：<code>Stale file handle</code>，当时找了全网，也找不到答案，于是陷入了两天的痛苦 debug，在重新敲代码时，发现又不报错了，切换回那个有错误的分支，也不报错了。既然暂时找不到错误，先搁着吧，如果有看到这篇文章的朋友，也遇到了这个错误，可以留意下。(感觉会是一个雷)</p>
<p>(应该是容器的 mnt 没有 mount 上去，才会导致 stale file handle)</p>
<h4 id="停止容器">6.5 停止容器</h4>
<p>定义 <code>StopCommand</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var StopCommand &#x3D; cli.Command&#123;
	Name:  &quot;stop&quot;,
	Usage: &quot;stop a container&quot;,
	Action: func(context *cli.Context) error &#123;
		if len(context.Args()) &lt; 1 &#123;
			return fmt.Errorf(&quot;missing container name&quot;)
		&#125;
		containerName :&#x3D; context.Args()[0]
		stopContainer(containerName)
		return nil
	&#125;,
&#125;</code></pre>
<p>然后声明一个函数，通过容器名来获取容器信息：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func getContainerInfoByName(containerName string) (*container.ContainerInfo, error) &#123;
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerName)
	configFilePath :&#x3D; dirURL + &quot;&#x2F;&quot; + container.ConfigName
	contentBytes, err :&#x3D; ioutil.ReadFile(configFilePath)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;read config file %s error %v&quot;, configFilePath, err)
		return nil, err
	&#125;
	var containerInfo container.ContainerInfo
	&#x2F;&#x2F; unmarshal json to container info
	if err :&#x3D; json.Unmarshal(contentBytes, &amp;containerInfo); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;unmarshal json to container info error %v&quot;, err)
		return nil, err
	&#125;
	return &amp;containerInfo, nil
&#125;</code></pre>
<p>然后是停止容器：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func stopContainer(containerName string) &#123;
	&#x2F;&#x2F; get pid by containerName
	pid, err :&#x3D; getContainerPidByName(containerName)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;get container pid by name %s error %v&quot;, containerName, err)
		return
	&#125;
	&#x2F;&#x2F; turn pid(string) to int
	pidInt, err :&#x3D; strconv.Atoi(pid)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;convert pid from string to int error %v&quot;, err)
		return
	&#125;
	&#x2F;&#x2F; kill container main process
	if err :&#x3D; syscall.Kill(pidInt, syscall.SIGTERM); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;stop container %s error %v&quot;, containerName, err)
		return
	&#125;
	&#x2F;&#x2F; get info of the container
	containerInfo, err :&#x3D; getContainerInfoByName(containerName)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;get container info by name %s error %v&quot;, containerName, err)
		return
	&#125;
	&#x2F;&#x2F; process is killed, update process status
	containerInfo.Status &#x3D; container.STOP
	containerInfo.Pid &#x3D; &quot; &quot;
	&#x2F;&#x2F; update info to json
	nweContentBytes, err :&#x3D; json.Marshal(containerInfo)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;json marshal %s error %v&quot;, containerName, err)
		return
	&#125;
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerName)
	configFilePath :&#x3D; dirURL + &quot;&#x2F;&quot; + container.ConfigName
	&#x2F;&#x2F; overwrite containerInfo
	if err :&#x3D; ioutil.WriteFile(configFilePath, nweContentBytes, 0622); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;write config file %s error %v&quot;, configFilePath, err)
	&#125;
&#125;</code></pre>
<p>测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . stop jay
# go run . ps
ID           NAME        PID         STATUS      COMMAND     CREATED
6883605813   jay                     stopped     top
# ps -ef | grep top
root       43588     761  0 20:00 pts&#x2F;0    00:00:00 grep --color&#x3D;auto top</code></pre>
<p>可以看到，jay 这个进程被停止了，且 pid 号设为空。</p>
<h4 id="删除容器">6.6 删除容器</h4>
<p>定义 <code>RemoveCommand</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var RemoveCommand &#x3D; cli.Command&#123;
	Name:  &quot;rm&quot;,
	Usage: &quot;remove a container&quot;,
	Action: func(context *cli.Context) error &#123;
		if len(context.Args()) &lt; 1 &#123;
			return fmt.Errorf(&quot;missing container name&quot;)
		&#125;
		containerName :&#x3D; context.Args()[0]
		removeContainer(containerName)
		return nil
	&#125;,
&#125;</code></pre>
<p>实现删除容器：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func removeContainer(containerName string) &#123;
	containerInfo, err :&#x3D; getContainerInfoByName(containerName)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;get container %s info failed: %v&quot;, containerName, err)
		return
	&#125;
	&#x2F;&#x2F; only remove the stopped container
	if containerInfo.Status !&#x3D; container.STOP &#123;
		logrus.Errorf(&quot;cannot remove running container %s&quot;, containerName)
		return
	&#125;
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerName)
	&#x2F;&#x2F; remove all the info including sub dir
	if err :&#x3D; os.RemoveAll(dirURL); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;cannot remove dir %s error: %v&quot;, dirURL, err)
		return
	&#125;
&#125;</code></pre>
<p>测试一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . rm jay
# go run . ps
ID          NAME        PID         STATUS      COMMAND     CREATED</code></pre>
<p>可以看到，jay 这个容器被删除了。</p>
<h4 id="通过容器制作镜像">6.7 通过容器制作镜像</h4>
<p>这一节，根据书上的内容，有许多函数需要改动。建议这里对着作者给出的源码 debug，书上有部分内容有明显错误。</p>
<p>之前的文件系统如下：</p>
<ul>
<li>只读层：busybox，只读，容器系统的基础</li>
<li>可写层：writeLayer，容器内部的可写层</li>
<li>挂载层：mnt，挂载外部的文件系统，类似虚拟机的文件共享</li>
</ul>
<p>修改后的文件系统如下：</p>
<ul>
<li>只读层：不变</li>
<li>可写层：再加容器名为目录进行隔离，也就是 <code>writeLayer/$&#123;containerName&#125;</code></li>
<li>挂载层：再加容器名为目录进行隔离，也就是 <code>mnt/$&#123;containerName&#125;</code></li>
</ul>
<p>因此，本节要实现为每个容器分配单独的隔离文件系统，以及实现对不同容器打包镜像。</p>
<p><strong>修改 <code>run.go</code></strong></p>
<p>在 Run 函数参数列表添加一个 <code>imageName</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Run(tty bool, cmdArray []string, res *subsystem.ResourceConfig, volume, containerName, imageName string) &#123;
	containerID :&#x3D; randStringBytes(10)
	if containerName &#x3D;&#x3D; &quot;&quot; &#123;
		containerName &#x3D; containerID
	&#125;
	&#x2F;&#x2F; this is &quot;docker init &lt;cmdArray&gt;&quot;
	initProcess, writePipe :&#x3D; container.NewParentProcess(tty, volume, containerName, imageName)
	if initProcess &#x3D;&#x3D; nil &#123;
		logrus.Errorf(&quot;new parent process error&quot;)
		return
	&#125;

	&#x2F;&#x2F; start the init process
	if err :&#x3D; initProcess.Start(); err !&#x3D; nil &#123;
		logrus.Error(err)
	&#125;
	&#x2F;&#x2F; container info
	containerName, err :&#x3D; recordContainerInfo(initProcess.Process.Pid, cmdArray, containerName, volume)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;record container info error: %v&quot;, err)
		return
	&#125;

	&#x2F;&#x2F; create container manager to control resource config on all hierarchies
	cm :&#x3D; cgroups.NewCgroupManager(&quot;simple-docker-container&quot;)
	defer cm.Remove()
	cm.Set(res)
	cm.AddProcess(initProcess.Process.Pid)

	&#x2F;&#x2F; send command to write side
	&#x2F;&#x2F; will close the plug
	sendInitCommand(cmdArray, writePipe)

	if tty &#123;
		initProcess.Wait()
		deleteContainerInfo(containerName)
		container.DeleteWorkSpace(volume, containerName)
	&#125;
	os.Exit(0)
&#125;</code></pre>
<p>同时也在 <code>command.go</code> 的 runCommand 里修改：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">Action: func(context *cli.Context) error &#123;
		args :&#x3D; context.Args()
		if len(args) &lt;&#x3D; 0 &#123;
			return errors.New(&quot;run what?&quot;)
		&#125;

		&#x2F;&#x2F; 转化 cli.Args 为 []string
		cmdArray :&#x3D; make([]string, len(args)) &#x2F;&#x2F; command
		copy(cmdArray, args)

		&#x2F;&#x2F; check whether type &#96;-it&#96;
		tty :&#x3D; context.Bool(&quot;it&quot;)   &#x2F;&#x2F; presudo terminal
		detach :&#x3D; context.Bool(&quot;d&quot;) &#x2F;&#x2F; detach container

		if tty &amp;&amp; detach &#123;
			return fmt.Errorf(&quot;it and d paramter cannot both privided&quot;)
		&#125;

		&#x2F;&#x2F; get the resource config
		resourceConfig :&#x3D; subsystem.ResourceConfig&#123;
			MemoryLimit: context.String(&quot;m&quot;),
			CPUShare:    context.String(&quot;cpushare&quot;),
			CPUSet:      context.String(&quot;cpu&quot;),
		&#125;
		volume :&#x3D; context.String(&quot;v&quot;)
		containerName :&#x3D; context.String(&quot;name&quot;)
		imageName :&#x3D; cmdArray[0]
		cmdArray &#x3D; cmdArray[1:]
		Run(tty, cmdArray, &amp;resourceConfig, volume, containerName, imageName)

		return nil
	&#125;,</code></pre>
<p>在 <code>recordContainerInfo</code> 函数的参数列表添加 volume：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func recordContainerInfo(containerPID int, commandArray []string, containerName, volume string) (string, error) &#123;
	&#x2F;&#x2F; create an ID that length is 10
	id :&#x3D; randStringBytes(10)
	createTime :&#x3D; time.Now().Format(&quot;2006-01-02 15:04:05&quot;)
	command :&#x3D; strings.Join(commandArray, &quot;&quot;)
	&#x2F;&#x2F; if containerName is nil, make containerID as name
	if containerName &#x3D;&#x3D; &quot;&quot; &#123;
		containerName &#x3D; id
	&#125;
	containerInfo :&#x3D; &amp;container.ContainerInfo&#123;
		Id:          id,
		Pid:         strconv.Itoa(containerPID),
		Command:     command,
		CreatedTime: createTime,
		Status:      container.RUNNING,
		Name:        containerName,
		Volume:      volume,
	&#125;
	&#x2F;&#x2F; trun containerInfo info string
	jsonBytes, err :&#x3D; json.Marshal(containerInfo)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;record container info error: %v&quot;, err)
		return &quot;&quot;, err
	&#125;
	jsonStr :&#x3D; string(jsonBytes)

	&#x2F;&#x2F; container path
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerName)
	if err :&#x3D; os.MkdirAll(dirURL, 0622); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mkdir error %s error: %v&quot;, dirURL, err)
		return &quot;&quot;, err
	&#125;
	fileName :&#x3D; dirURL + &quot;&#x2F;&quot; + container.ConfigName
	&#x2F;&#x2F; create config.json
	file, err :&#x3D; os.Create(fileName)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;create %s error %v&quot;, fileName, err)
		return &quot;&quot;, err
	&#125;
	defer file.Close()
	&#x2F;&#x2F; write jsonify data to file
	if _, err :&#x3D; file.WriteString(jsonStr); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;write %s error %v&quot;, fileName, err)
		return &quot;&quot;, err
	&#125;
	return containerName, nil
&#125;</code></pre>
<p>给 ContainerInfo 添加 Volume 成员：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type ContainerInfo struct &#123;
	Pid         string &#96;json:&quot;pid&quot;&#96;        &#x2F;&#x2F;容器的init进程在宿主机上的 PID
	Id          string &#96;json:&quot;id&quot;&#96;         &#x2F;&#x2F;容器Id
	Name        string &#96;json:&quot;name&quot;&#96;       &#x2F;&#x2F;容器名
	Command     string &#96;json:&quot;command&quot;&#96;    &#x2F;&#x2F;容器内init运行命令
	CreatedTime string &#96;json:&quot;createTime&quot;&#96; &#x2F;&#x2F;创建时间
	Status      string &#96;json:&quot;status&quot;&#96;     &#x2F;&#x2F;容器的状态
	Volume      string &#96;json:&quot;volume&quot;&#96;
&#125;</code></pre>
<p>然后将 <code>RootURL</code>，<code>MntURL</code>，<code>WriteLayer</code> 设为常量：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var (
	RUNNING             string &#x3D; &quot;running&quot;
	STOP                string &#x3D; &quot;stopped&quot;
	Exit                string &#x3D; &quot;exited&quot;
	DefaultInfoLocation string &#x3D; &quot;&#x2F;var&#x2F;run&#x2F;simple-docker&#x2F;%s&#x2F;&quot;
	ConfigName          string &#x3D; &quot;config.json&quot;
	ContainerLogFile    string &#x3D; &quot;container.log&quot;
	RootURL             string &#x3D; &quot;&#x2F;root&#x2F;&quot;
	MntURL              string &#x3D; &quot;&#x2F;root&#x2F;mnt&#x2F;%s&#x2F;&quot;
	WriteLayerURL       string &#x3D; &quot;&#x2F;root&#x2F;writeLayer&#x2F;%s&quot;
)</code></pre>
<p>相应地，<code>NewParentProcess</code> 函数也要修改：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func NewParentProcess(tty bool, volume string, containerName, imageName string) (*exec.Cmd, *os.File) &#123;
	readPipe, writePipe, err :&#x3D; os.Pipe()

	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;New Pipe Error: %v&quot;, err)
		return nil, nil
	&#125;
	&#x2F;&#x2F; create a new command which run itself
	&#x2F;&#x2F; the first arguments is &#96;init&#96; which is in the &quot;container&#x2F;init.go&quot; file
	&#x2F;&#x2F; so, the &lt;cmd&gt; will be interpret as &quot;docker init &lt;cmdArray&gt;&quot;
	cmd :&#x3D; exec.Command(&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot;, &quot;init&quot;)

	cmd.SysProcAttr &#x3D; &amp;syscall.SysProcAttr&#123;
		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS |
			syscall.CLONE_NEWNET | syscall.CLONE_NEWIPC,
	&#125;
	cmd.Stdin &#x3D; os.Stdin
	if tty &#123;
		cmd.Stdout &#x3D; os.Stdout
		cmd.Stderr &#x3D; os.Stderr
	&#125; else &#123;
		dirURL :&#x3D; fmt.Sprintf(DefaultInfoLocation, containerName)
		if err :&#x3D; os.MkdirAll(dirURL, 0622); err !&#x3D; nil &#123;
			logrus.Errorf(&quot;NewParentProcess mkdir %s error %v&quot;, dirURL, err)
			return nil, nil
		&#125;
		stdLogFilePath :&#x3D; dirURL + ContainerLogFile
		stdLogFile, err :&#x3D; os.Create(stdLogFilePath)
		if err !&#x3D; nil &#123;
			logrus.Errorf(&quot;NewParentProcess create file %s error %v&quot;, stdLogFilePath, err)
			return nil, nil
		&#125;
		cmd.Stdout &#x3D; stdLogFile
	&#125;
	cmd.ExtraFiles &#x3D; []*os.File&#123;readPipe&#125;
	NewWorkSpace(volume, imageName, containerName)
	cmd.Dir &#x3D; fmt.Sprintf(MntURL, containerName)

	return cmd, writePipe
&#125;</code></pre>
<p><code>NewWorkSpace</code> 函数的三个参数分别改为：<code>volume</code>，<code>imageName</code>，<code>containerName</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func NewWorkSpace(volume, imageName, containerName string) &#123;
	CreateReadOnlyLayer(imageName)
	CreateWriteLayer(containerName)
	CreateMountPoint(containerName, imageName)
	if volume !&#x3D; &quot;&quot; &#123;
		volumeURLs :&#x3D; volumeUrlExtract(volume)
		length :&#x3D; len(volumeURLs)
		if length &#x3D;&#x3D; 2 &amp;&amp; volumeURLs[0] !&#x3D; &quot;&quot; &amp;&amp; volumeURLs[1] !&#x3D; &quot;&quot; &#123;
			MountVolume(volumeURLs, containerName)
			logrus.Infof(&quot;%q&quot;, volumeURLs)
		&#125; else &#123;
			logrus.Infof(&quot;volume parameter input is not correct&quot;)
		&#125;
	&#125;
&#125;</code></pre>
<p>下面来修改 <code>CreateReadOnlyLayer</code>，<code>CreateWriteLayer</code>，<code>CreateMountPoint</code> 这三个函数：</p>
<p>首先是 <code>CreateReadOnlyLayer</code>，参数名改为 <code>imageName</code>，镜像解压出来的只读层以 <code>RootURL+imageName</code> 命名：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func CreateReadOnlyLayer(imageName string) error &#123;
	unTarFolderURL :&#x3D; RootURL + &quot;&#x2F;&quot; + imageName + &quot;&#x2F;&quot;
	imageURL :&#x3D; RootURL + &quot;&#x2F;&quot; + imageName + &quot;.tar&quot;
	exist, err :&#x3D; PathExists(unTarFolderURL)

	if err !&#x3D; nil &#123;
		logrus.Infof(&quot;fail to judge whether dir %s exists. %v&quot;, unTarFolderURL, err)
		return err
	&#125;
	if !exist &#123;
		if err :&#x3D; os.MkdirAll(unTarFolderURL, 0777); err !&#x3D; nil &#123;
			logrus.Errorf(&quot;mkdir dir %s error. %v&quot;, unTarFolderURL, err)
			return err
		&#125;
		if _, err :&#x3D; exec.Command(&quot;tar&quot;, &quot;-xvf&quot;, imageURL, &quot;-C&quot;, unTarFolderURL).CombinedOutput(); err !&#x3D; nil &#123;
			logrus.Errorf(&quot;unTar dir %s error %v&quot;, unTarFolderURL, err)
			return err
		&#125;
	&#125;
	return nil
&#125;</code></pre>
<p><code>CreateWriteLayer</code> 为每个容器创建一个读写层，把参数改为 containerName，容器读写层修改为 <code>WriteLayerURL+containerName</code> 命名：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func CreateWriteLayer(containerName string) &#123;
	writeUrl :&#x3D; fmt.Sprintf(WriteLayerURL, containerName)
	if err :&#x3D; os.MkdirAll(writeUrl, 0777); err !&#x3D; nil &#123;
		logrus.Infof(&quot;Mkdir write layer dir %s error. %v&quot;, writeUrl, err)
	&#125;
&#125;</code></pre>
<p><code>CreateMountPoint</code> 创建容器根目录，然后把镜像只读层和容器读写层挂载到容器根目录，成为容器文件系统，参数列表改为 <code>containerName</code> 和 <code>imageName</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func CreateMountPoint(containerName, imageName string) error &#123;
	&#x2F;&#x2F; create mnt folder as mount point
	mntURL :&#x3D; fmt.Sprintf(MntURL, containerName)
	if err :&#x3D; os.MkdirAll(mntURL, 0777); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mkdir dir %s error %v&quot;, mntURL, err)
		return err
	&#125;
	&#x2F;&#x2F; mount &#39;writeLayer&#39; and &#39;busybox&#39; to &#39;mnt&#39;
	tmpWriteLayer :&#x3D; fmt.Sprintf(WriteLayerURL, containerName)
	tmpImageLocation :&#x3D; RootURL + &quot;&#x2F;&quot; + imageName
	dirs :&#x3D; &quot;dirs&#x3D;&quot; + tmpWriteLayer + &quot;:&quot; + tmpImageLocation
	_, err :&#x3D; exec.Command(&quot;mount&quot;, &quot;-t&quot;, &quot;aufs&quot;, &quot;-o&quot;, dirs, &quot;none&quot;, mntURL).CombinedOutput()
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;run command for creating mount point failed: %v&quot;, err)
		return err
	&#125;
	return nil
&#125;</code></pre>
<p><code>MountVolume</code> 根据用户输入的 volume 参数获取相应挂载宿主机数据卷 URL 和容器的挂载点 URL，并挂载数据卷。参数列表改为 <code>volumeURLs</code> 和 <code>containerName</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func MountVolume(volumeURLs []string, containerName string) error &#123;
	&#x2F;&#x2F; create host file catalog
	parentURL :&#x3D; volumeURLs[0]
	if err :&#x3D; os.Mkdir(parentURL, 0777); err !&#x3D; nil &#123;
		logrus.Infof(&quot;mkdir parent dir %s error. %v&quot;, parentURL, err)
	&#125;
	&#x2F;&#x2F; create mount point in container file system
	containerURL :&#x3D; volumeURLs[1]
	mntURL :&#x3D; fmt.Sprintf(MntURL, containerName)
	containerVolumeURL :&#x3D; mntURL + &quot;&#x2F;&quot; + containerURL
	if err :&#x3D; os.Mkdir(containerVolumeURL, 0777); err !&#x3D; nil &#123;
		logrus.Infof(&quot;mkdir container dir %s error. %v&quot;, containerVolumeURL, err)
	&#125;
	&#x2F;&#x2F; mount host file catalog to mount point in container
	dirs :&#x3D; &quot;dirs&#x3D;&quot; + parentURL
	_, err :&#x3D; exec.Command(&quot;mount&quot;, &quot;-t&quot;, &quot;aufs&quot;, &quot;-o&quot;, dirs, &quot;none&quot;, containerVolumeURL).CombinedOutput()
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;mount volume failed. %v&quot;, err)
		return err
	&#125;
	return nil
&#125;</code></pre>
<p>然后在删除容器的 <code>removeContainer</code> 函数最后加一行 <code>DeleteWorkSpace</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func removeContainer(containerName string) &#123;
	containerInfo, err :&#x3D; getContainerInfoByName(containerName)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;get container %s info failed: %v&quot;, containerName, err)
		return
	&#125;
	&#x2F;&#x2F; only remove the stopped container
	if containerInfo.Status !&#x3D; container.STOP &#123;
		logrus.Errorf(&quot;cannot remove running container %s&quot;, containerName)
		return
	&#125;
	dirURL :&#x3D; fmt.Sprintf(container.DefaultInfoLocation, containerName)
	&#x2F;&#x2F; remove all the info including sub dir
	if err :&#x3D; os.RemoveAll(dirURL); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;cannot remove dir %s error: %v&quot;, dirURL, err)
		return
	&#125;
	container.DeleteWorkSpace(containerInfo.Volume, containerName)
&#125;</code></pre>
<p>然后 <code>DeleteWorkSpace</code> 也要修改，<code>DeleteWorkSpace</code> 作用是当容器退出时，删除容器相关文件系统，参数列表改为 containerName 和 volume：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func DeleteWorkSpace(volume, containerName string) &#123;
	if volume !&#x3D; &quot;&quot; &#123;
		volumeURLs :&#x3D; volumeUrlExtract(volume)
		length :&#x3D; len(volumeURLs)
		if length &#x3D;&#x3D; 2 &amp;&amp; volumeURLs[0] !&#x3D; &quot;&quot; &amp;&amp; volumeURLs[1] !&#x3D; &quot;&quot; &#123;
			DeleteMountPointWithVolume(volumeURLs, containerName)
		&#125; else &#123;
			DeleteMountPoint(containerName)
		&#125;
	&#125; else &#123;
		DeleteMountPoint(containerName)
	&#125;
	DeleteWriteLayer(containerName)
&#125;</code></pre>
<p><code>DeleteMountPoint</code> 函数作用是删除未挂载数据卷的容器文件系统，参数修改为 <code>containerName</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func DeleteMountPoint(containerName string) error &#123;
	mntURL :&#x3D; fmt.Sprintf(MntURL, containerName)
	_, err :&#x3D; exec.Command(&quot;umount&quot;, mntURL).CombinedOutput()
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;%v&quot;, err)
		return err
	&#125;
	if err :&#x3D; os.RemoveAll(mntURL); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;remove dir %s error %v&quot;, mntURL, err)
		return err
	&#125;
	return nil
&#125;</code></pre>
<p><code>DeleteMountPointWithVolume</code> 函数用来删除挂载数据卷容器的文件系统，参数列表改为 <code>volumeURLs</code> 和 <code>containerName</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func DeleteMountPointWithVolume(volumeURLs []string, containerName string) error &#123;
	&#x2F;&#x2F; umount volume point in container
	mntURL :&#x3D; fmt.Sprintf(MntURL, containerName)
	containerURL :&#x3D; mntURL + &quot;&#x2F;&quot; + volumeURLs[1]
	if _, err :&#x3D; exec.Command(&quot;umount&quot;, containerURL).CombinedOutput(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;umount volume failed. %v&quot;, err)
		return err
	&#125;
	&#x2F;&#x2F; umount the whole point of the container
	_, err :&#x3D; exec.Command(&quot;umount&quot;, mntURL).CombinedOutput()
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;umount mountpoint failed. %v&quot;, err)
		return err
	&#125;
	if err :&#x3D; os.RemoveAll(mntURL); err !&#x3D; nil &#123;
		logrus.Infof(&quot;remove mountpoint dir %s error %v&quot;, mntURL, err)
	&#125;
	return nil
&#125;</code></pre>
<p><code>DeleteWriteLayer</code> 函数用来删除容器读写层，参数改为 <code>containerName</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func DeleteWriteLayer(containerName string) &#123;
	writeURL :&#x3D; fmt.Sprintf(WriteLayerURL, containerName)
	if err :&#x3D; os.RemoveAll(writeURL); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;remove dir %s error %v&quot;, writeURL, err)
	&#125;
&#125;</code></pre>
<p>然后修改 <code>command.go</code> 中的 <code>commitCommand</code>：输入参数名改为 <code>containerName</code> 和 <code>imageName</code>：·</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var CommitCommand &#x3D; cli.Command&#123;
	Name:  &quot;commit&quot;,
	Usage: &quot;commit a container into image&quot;,
	Action: func(context *cli.Context) error &#123;
		if len(context.Args()) &lt; 1 &#123;
			return fmt.Errorf(&quot;missing container name&quot;)
		&#125;
		containerName :&#x3D; context.Args()[0]
		imageName :&#x3D; context.Args()[1]
		&#x2F;&#x2F; commitContainer(containerName)
		commitContainer(containerName, imageName)
		return nil
	&#125;,
&#125;</code></pre>
<p>修改 <code>commit.go</code> 的 <code>commitContainer</code> 函数，根据传入的 containerName 制作 <code>imageName.tar</code> 镜像：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func commitContainer(containerName, imageName string) &#123;
	mntURL :&#x3D; fmt.Sprintf(container.MntURL, containerName)
	mntURL +&#x3D; &quot;&#x2F;&quot;
	imageTar :&#x3D; container.RootURL + &quot;&#x2F;&quot; + imageName + &quot;.tar&quot;
	if _, err :&#x3D; exec.Command(&quot;tar&quot;, &quot;-czf&quot;, imageTar, &quot;-C&quot;, mntURL, &quot;.&quot;).CombinedOutput(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;tar folder %s error %v&quot;, mntURL, err)
	&#125;
&#125;</code></pre>
<p>测试一下，用 busybox 启动两个容器 test1 和 test2，test1 把宿主机 <code>/root/from1</code> 挂载到容器 <code>/to1</code>，test2 把宿主机 <code>/root/from2</code> 挂载到 <code>/to2</code> 下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -d --name test1 -v &#x2F;root&#x2F;from1:&#x2F;to1 busybox top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;[\&quot;&#x2F;root&#x2F;from1\&quot; \&quot;&#x2F;to1\&quot;]&quot;,&quot;time&quot;:&quot;2023-05-11T10:04:42+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-11T10:04:42+08:00&quot;&#125;
# go run . run -d --name test2 -v &#x2F;root&#x2F;from2:&#x2F;to2 busybox top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;[\&quot;&#x2F;root&#x2F;from2\&quot; \&quot;&#x2F;to2\&quot;]&quot;,&quot;time&quot;:&quot;2023-05-11T10:04:51+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-11T10:04:51+08:00&quot;&#125;
# go run . ps
ID           NAME        PID         STATUS      COMMAND     CREATED
4010011034   test1       11570       running     top         2023-05-11 10:04:42
5746376093   test2       11684       running     top         2023-05-11 10:04:51</code></pre>
<p>打开另一个终端，可以看到 <code>/root</code> 目录下多了 <code>from1</code> 和 <code>from2</code> 两个目录，我们看看 <code>mnt</code> 和 <code>writeLayer</code>，<code>mnt</code> 下多了两个 busybox 的挂载层，<code>writeLayer</code> 下分别挂载了两个容器的目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># tree writeLayer&#x2F;
writeLayer&#x2F;
├── test1
│   └── to1
└── test2
    └── to2</code></pre>
<p>下面进入 test1 容器，创建 <code>/to1/test1.txt</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . exec test1 sh
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;container pid 11570&quot;,&quot;time&quot;:&quot;2023-05-11T10:16:33+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command sh&quot;,&quot;time&quot;:&quot;2023-05-11T10:16:33+08:00&quot;&#125;
&#x2F; # echo -e &quot;test1&quot; &gt;&gt; &#x2F;to1&#x2F;test1.txt
&#x2F; # mkdir to1-1
&#x2F; # echo -e &quot;test111111&quot; &gt;&gt; &#x2F;to1-1&#x2F;test1111.txt</code></pre>
<p>这时候再来看看可写层：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># tree writeLayer&#x2F;
writeLayer&#x2F;
├── test1
│   ├── root
│   ├── to1
│   └── to1-1
│       └── test1111.txt
└── test2
    └── to2
# cat writeLayer&#x2F;test1&#x2F;to1-1&#x2F;test1111.txt
test111111</code></pre>
<p>多了 <code>to1-1/test1111.txt</code>，那刚刚创建的 <code>test1.txt</code> 去哪了呢？这时候我们看看 <code>from1</code>，在这里，新创建的文件写入了数据卷。</p>
<p>下面来验证 commit 功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . commit test1 image1</code></pre>
<p>导出的镜像路径为 <code>/root/image1.tar</code>。</p>
<p>下面测试停止和删除容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . stop test1
# go run . ps
ID           NAME        PID         STATUS      COMMAND     CREATED
4010011034   test1                   stopped     top         2023-05-11 10:04:42
5746376093   test2       11684       running     top         2023-05-11 10:04:51
# go run . rm test1
# go run . ps
ID           NAME        PID         STATUS      COMMAND     CREATED
5746376093   test2       11684       running     top         2023-05-11 10:04:51</code></pre>
<p>我们看看容器根目录和可读写层：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ls mnt
test2
# tree writeLayer&#x2F;
writeLayer&#x2F;
└── test2
    └── to2</code></pre>
<p>test1 的容器根目录和可读写层被删除。</p>
<p>下面来试一下用镜像创建容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -d --name test3 -v &#x2F;root&#x2F;from3:&#x2F;to3 image1 top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;[\&quot;&#x2F;root&#x2F;from3\&quot; \&quot;&#x2F;to3\&quot;]&quot;,&quot;time&quot;:&quot;2023-05-11T10:32:44+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-11T10:32:44+08:00&quot;&#125;
# go run . ps
ID           NAME        PID         STATUS      COMMAND     CREATED
5746376093   test2       11684       running     top         2023-05-11 10:04:51
4713076733   test3       13056       running     top         2023-05-11 10:32:44</code></pre>
<p>这时我们可以看到 <code>/root</code> 多了一个 <code>image1</code> 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ls image1
bin  dev  etc  home  lib  lib64  proc  root  sys  tmp  to1  to1-1  usr  var</code></pre>
<p>在这里发现了刚才创建的 <code>to1-1</code>，用 <code>image1.tar</code> 启动的容器 test3，进入容器后发现我们刚刚写入的文件，至此，我们成功把容器 test1 的数据卷 to1 信息，重新写入了容器 test3 数据卷 to3。</p>
<p>在次小节后，进入容器都要指定镜像名，不然都会报错。</p>
<h4 id="实现容器指定环境变量运行">6.8 实现容器指定环境变量运行</h4>
<p>本节来实现让容器内运行的程序可以使用外部传递的环境变量。</p>
<h5 id="修改-runcommand">6.8.1 修改 runCommand</h5>
<p>在原来基础上增加 <code>-e</code> 选项，允许用户指定环境变量，由于环境变量可以是多个，这里允许用户多次使用 <code>-e</code> 来传递，同时添加对环境变量的解析，整体修改如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var RunCommand &#x3D; cli.Command&#123;
	Name:  &quot;run&quot;,
	Usage: &quot;Create a container&quot;,
	Flags: []cli.Flag&#123;
		&#x2F;&#x2F; integrate -i and -t for convenience
		&amp;cli.BoolFlag&#123;
			Name:  &quot;it&quot;,
			Usage: &quot;open an interactive tty(pseudo terminal)&quot;,
		&#125;,
		&amp;cli.StringFlag&#123;
			Name:  &quot;m&quot;,
			Usage: &quot;limit the memory&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;cpu&quot;,
			Usage: &quot;limit the cpu amount&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;cpushare&quot;,
			Usage: &quot;limit the cpu share&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;v&quot;,
			Usage: &quot;volume&quot;,
		&#125;, &amp;cli.BoolFlag&#123;
			Name:  &quot;d&quot;,
			Usage: &quot;detach container&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;cpuset&quot;,
			Usage: &quot;limit the cpuset&quot;,
		&#125;, &amp;cli.StringFlag&#123;
			Name:  &quot;name&quot;,
			Usage: &quot;container name&quot;,
		&#125;, &amp;cli.StringSliceFlag&#123;
			Name:  &quot;e&quot;,
			Usage: &quot;set environment&quot;,
		&#125;,
	&#125;,
	Action: func(context *cli.Context) error &#123;
		args :&#x3D; context.Args()
		if len(args) &lt;&#x3D; 0 &#123;
			return errors.New(&quot;run what?&quot;)
		&#125;

		&#x2F;&#x2F; 转化 cli.Args 为 []string
		cmdArray :&#x3D; make([]string, len(args)) &#x2F;&#x2F; command
		copy(cmdArray, args)

		&#x2F;&#x2F; check whether type &#96;-it&#96;
		tty :&#x3D; context.Bool(&quot;it&quot;)   &#x2F;&#x2F; presudo terminal
		detach :&#x3D; context.Bool(&quot;d&quot;) &#x2F;&#x2F; detach container

		if tty &amp;&amp; detach &#123;
			return fmt.Errorf(&quot;it and d paramter cannot both privided&quot;)
		&#125;

		&#x2F;&#x2F; get the resource config
		resourceConfig :&#x3D; subsystem.ResourceConfig&#123;
			MemoryLimit: context.String(&quot;m&quot;),
			CPUShare:    context.String(&quot;cpushare&quot;),
			CPUSet:      context.String(&quot;cpu&quot;),
		&#125;
		volume :&#x3D; context.String(&quot;v&quot;)
		containerName :&#x3D; context.String(&quot;name&quot;)
		envSlice :&#x3D; context.StringSlice(&quot;e&quot;)
		imageName :&#x3D; cmdArray[0]
		cmdArray &#x3D; cmdArray[1:]
		Run(tty, cmdArray, &amp;resourceConfig, volume, containerName, imageName, envSlice)

		return nil
	&#125;,
&#125;</code></pre>
<h5 id="修改-run-函数">6.8.2 修改 Run 函数</h5>
<p>参数里新增一个 <code>envSlice</code>，然后传递给 <code>NewParentProcess</code> 函数。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Run(tty bool, cmdArray []string, res *subsystem.ResourceConfig, volume, containerName, imageName string, envSlice []string) &#123;
	containerID :&#x3D; randStringBytes(10)
	if containerName &#x3D;&#x3D; &quot;&quot; &#123;
		containerName &#x3D; containerID
	&#125;
	&#x2F;&#x2F; this is &quot;docker init &lt;cmdArray&gt;&quot;
	initProcess, writePipe :&#x3D; container.NewParentProcess(tty, volume, containerName, imageName, envSlice)
	if initProcess &#x3D;&#x3D; nil &#123;
		logrus.Errorf(&quot;new parent process error&quot;)
		return
	&#125;

	&#x2F;&#x2F; start the init process
	if err :&#x3D; initProcess.Start(); err !&#x3D; nil &#123;
		logrus.Error(err)
	&#125;
	&#x2F;&#x2F; container info
	containerName, err :&#x3D; recordContainerInfo(initProcess.Process.Pid, cmdArray, containerName, volume)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;record container info error: %v&quot;, err)
		return
	&#125;

	&#x2F;&#x2F; create container manager to control resource config on all hierarchies
	cm :&#x3D; cgroups.NewCgroupManager(&quot;simple-docker-container&quot;)
	defer cm.Remove()
	cm.Set(res)
	cm.AddProcess(initProcess.Process.Pid)

	&#x2F;&#x2F; send command to write side
	&#x2F;&#x2F; will close the plug
	sendInitCommand(cmdArray, writePipe)

	if tty &#123;
		initProcess.Wait()
		deleteContainerInfo(containerName)
		container.DeleteWorkSpace(volume, containerName)
	&#125;
	os.Exit(0)
&#125;</code></pre>
<h5 id="修改-newparentprocess-函数">6.8.3 修改 NewParentProcess 函数</h5>
<p>参数新增一个 <code>envSlice</code>，给 cmd 设置环境变量。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func NewParentProcess(tty bool, volume string, containerName, imageName string, envSlice []string) (*exec.Cmd, *os.File) &#123;
	readPipe, writePipe, err :&#x3D; os.Pipe()

	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;New Pipe Error: %v&quot;, err)
		return nil, nil
	&#125;
	&#x2F;&#x2F; create a new command which run itself
	&#x2F;&#x2F; the first arguments is &#96;init&#96; which is in the &quot;container&#x2F;init.go&quot; file
	&#x2F;&#x2F; so, the &lt;cmd&gt; will be interpret as &quot;docker init &lt;cmdArray&gt;&quot;
	cmd :&#x3D; exec.Command(&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot;, &quot;init&quot;)

	cmd.SysProcAttr &#x3D; &amp;syscall.SysProcAttr&#123;
		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS |
			syscall.CLONE_NEWNET | syscall.CLONE_NEWIPC,
	&#125;
	cmd.Stdin &#x3D; os.Stdin
	if tty &#123;
		cmd.Stdout &#x3D; os.Stdout
		cmd.Stderr &#x3D; os.Stderr
	&#125; else &#123;
		dirURL :&#x3D; fmt.Sprintf(DefaultInfoLocation, containerName)
		if err :&#x3D; os.MkdirAll(dirURL, 0622); err !&#x3D; nil &#123;
			logrus.Errorf(&quot;NewParentProcess mkdir %s error %v&quot;, dirURL, err)
			return nil, nil
		&#125;
		stdLogFilePath :&#x3D; dirURL + ContainerLogFile
		stdLogFile, err :&#x3D; os.Create(stdLogFilePath)
		if err !&#x3D; nil &#123;
			logrus.Errorf(&quot;NewParentProcess create file %s error %v&quot;, stdLogFilePath, err)
			return nil, nil
		&#125;
		cmd.Stdout &#x3D; stdLogFile
	&#125;
	cmd.ExtraFiles &#x3D; []*os.File&#123;readPipe&#125;
	cmd.Env &#x3D; append(os.Environ(), envSlice...)
	NewWorkSpace(volume, imageName, containerName)
	cmd.Dir &#x3D; fmt.Sprintf(MntURL, containerName)

	return cmd, writePipe
&#125;</code></pre>
<p>测试一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -it --name test -e test&#x3D;123 -e luck&#x3D;test busybox sh
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Start initiating...&quot;,&quot;time&quot;:&quot;2023-05-11T14:14:52+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: sh&quot;,&quot;time&quot;:&quot;2023-05-11T14:14:52+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Current location is &#x2F;root&#x2F;mnt&#x2F;test&quot;,&quot;time&quot;:&quot;2023-05-11T14:14:52+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Find path: &#x2F;bin&#x2F;sh&quot;,&quot;time&quot;:&quot;2023-05-11T14:14:52+08:00&quot;&#125;
&#x2F; #  env | grep test
test&#x3D;123
luck&#x3D;test</code></pre>
<p>可以看到，手动指定的环境变量在容器内可见。后面创建一个后台运行的容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -d --name test -e test&#x3D;123 -e luck&#x3D;test busybox top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-11T14:19:31+08:00&quot;&#125;
# go run . ps
ID           NAME        PID         STATUS      COMMAND     CREATED
9649354121   test        29524       running     top         2023-05-11 14:19:31
# go run . exec test sh
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;container pid 29524&quot;,&quot;time&quot;:&quot;2023-05-11T14:20:12+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command sh&quot;,&quot;time&quot;:&quot;2023-05-11T14:20:12+08:00&quot;&#125;
&#x2F; # ps -ef
PID   USER     TIME  COMMAND
    1 root      0:00 top
    7 root      0:00 sh
    8 root      0:00 ps -ef
&#x2F; # env | grep test
&#x2F; #</code></pre>
<p>查看环境变量，没有我们设置的环境变量。</p>
<p>这里不能用 env 命令获取设置的环境变量，原因是 exec 可以说 go 发起的另一个进程，这个进程的父进程是宿主机的，这个，并不是容器内的。在 cgo 内使用了 setns 系统调用，才使得进程进入了容器内部的命名空间，但由于环境变量是继承自父进程的，因此这个 exec 进程的环境变量其实是继承自宿主机，所以在 exec 看到的环境变量其实是宿主机的环境变量。</p>
<p>但只要是容器内 pid 为 1 的进程，创造出来的进程都会继承它的环境变量，下面来修改 exec 命令来直接使用 env 命令来查看容器内环境变量的功能。</p>
<h5 id="修改-exec-命令">6.8.4 修改 exec 命令</h5>
<p>提供一个函数，可根据指定的 pid 来获取对应进程的环境变量。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func getEnvsByPid(pid string) []string &#123;
	path :&#x3D; fmt.Sprintf(&quot;&#x2F;proc&#x2F;%s&#x2F;environ&quot;, pid)
	contentBytes ,err :&#x3D; ioutil.ReadFile(path)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;read file %s error %v&quot;, path, err)
		return nil
	&#125;
	&#x2F;&#x2F; divide by &#39;\u0000&#39;
	envs :&#x3D; strings.Split(string(contentBytes),&quot;\u0000&quot;)
	return envs
&#125;</code></pre>
<p>由于进程存放环境变量的位置是 <code>/proc/$&#123;pid&#125;/environ</code>，因此根据给定的 pid 去读取这个文件，可以获取环境变量，在文件的描述中，每个环境变量之间通过 <code>\u0000</code> 分割，因此可以以此标记来获取环境变量数组。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func ExecContainer(containerName string, comArray []string) &#123;
	&#x2F;&#x2F; get the pid according the containerName
	pid, err :&#x3D; getContainerPidByName(containerName)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;exec container getContainerPidByName %s error %v&quot;, containerName, err)
		return
	&#125;
	&#x2F;&#x2F; divide command by blank space and combine as a string
	cmdStr :&#x3D; strings.Join(comArray, &quot; &quot;)
	logrus.Infof(&quot;container pid %s&quot;, pid)
	logrus.Infof(&quot;command %s&quot;, cmdStr)

	cmd :&#x3D; exec.Command(&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot;, &quot;exec&quot;)
	cmd.Stdin &#x3D; os.Stdin
	cmd.Stdout &#x3D; os.Stdout
	cmd.Stderr &#x3D; os.Stderr

	err &#x3D; os.Setenv(ENV_EXEC_PID, pid)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;set env exec pid %s error %v&quot;, pid, err)
	&#125;
	err &#x3D; os.Setenv(ENV_EXEC_CMD, cmdStr)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;set env exec command %s error %v&quot;, cmdStr, err)
	&#125;
	&#x2F;&#x2F; get target pid environ (container environ)
	containerEnvs :&#x3D; getEnvsByPid(pid)
	&#x2F;&#x2F; set host environ and container environ to exec process
	cmd.Env &#x3D; append(os.Environ(), containerEnvs...)

	if err :&#x3D; cmd.Run(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;exec container %s error %v&quot;, containerName, err)
	&#125;
&#125;</code></pre>
<p>这里由于 exec 命令依然要宿主机的一些环境变量，因此将宿主机环境变量和容器环境变量都一起放置到 exec 进程中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -d --name test -e test&#x3D;123 -e luck&#x3D;test busybox top
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: top&quot;,&quot;time&quot;:&quot;2023-05-11T14:30:03+08:00&quot;&#125;
# go run . ps
ID           NAME        PID         STATUS      COMMAND     CREATED
9729397397   test        50040       running     top         2023-05-11 14:30:03
# go run . exec test sh
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;container pid 50040&quot;,&quot;time&quot;:&quot;2023-05-11T14:30:17+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command sh&quot;,&quot;time&quot;:&quot;2023-05-11T14:30:17+08:00&quot;&#125;
&#x2F; # env | grep test
test&#x3D;123
luck&#x3D;test
&#x2F; #</code></pre>
<p>现在可以看到 exec 进程可以获取前面 run 时设置的环境变量了。</p>
<h2 id="四网络篇">四、网络篇</h2>
<h3 id="容器网络">7. 容器网络</h3>
<h4 id="网络虚拟化技术">7.1 网络虚拟化技术</h4>
<h5 id="linux-虚拟网络设备">7.1.1 Linux 虚拟网络设备</h5>
<p>Linux 是用网络设备去操作和使用网卡的，系统装了一个网卡后就会为其生成一个网络设备实例，例如 eth0。Linux 支持创建出虚拟化的设备，可通过组合实现多种多样的功能和网络拓扑，这里主要介绍 Veth 和 Bridge。</p>
<p><strong>Linux Veth</strong></p>
<p>Veth 时成对出现的虚拟网络设备，发送到 Veth 一端虚拟设备的请求会从另一端的虚拟设备中发出。容器的虚拟化场景中，常会使用 Veth 连接不同的网络 namespace：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ip netns add ns1
# ip netns add ns2
# ip link add veth0 type veth peer name veth1
# ip link set veth0 netns ns1
# ip link set veth1 netns ns2
# ip netns exec ns1 ip link
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
4: veth0@if3: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link&#x2F;ether 02:bf:18:99:77:ed brd ff:ff:ff:ff:ff:ff link-netns ns2</code></pre>
<p>在 ns1 和 ns2 的namespace 中，除 loopback 的设备以外就只看到了一个网络设备。当请求发送到这个虚拟网络设备时，都会原封不动地从另一个网络 namespace 的网络接口中出来。例如，给两端分别配置不同地址后，向虚拟网络设备的一端发送请求，就能达到这个虚拟网络设备对应的另一端。</p>
<p><img src="http://jaydenchang.gitee.io/images/images/0x0035/7.1.1-veth.png" style="zoom:43%;" /></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ip netns exec ns1 ifconfig veth0 172.18.0.2&#x2F;24 up
# ip netns exec ns2 ifconfig veth1 172.18.0.3&#x2F;24 up
# ip netns exec ns1 route add default dev veth0
# ip netns exec ns2 route add default dev veth1
# ip netns exec ns1 ping -c 1 172.18.0.3
PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.
64 bytes from 172.18.0.3: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.395 ms

--- 172.18.0.3 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.395&#x2F;0.395&#x2F;0.395&#x2F;0.000 ms</code></pre>
<p><strong>Linux Bridge</strong></p>
<p>进行下一步之前，先删除上一小节创建的 netns：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ip netns del ns1
# ip netns del ns2
# ip netns list</code></pre>
<p>此时之前创建的两个 netns 被删除。</p>
<p>Bridge 虚拟设备时用来桥接的网络设备，相当于现实世界的交换机，可以连接不同的网络设备，当请求达到 Bridge 设备时，可以通过报文中的 Mac 地址进行广播或转发。例如，创建一个 Bridge 设备，来连接 namespace 中的网络设备和宿主机上的网络：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ip netns add ns1
# ip link add veth0 type veth peer name veth1
# ip link set veth1 netns ns1
########## 创建网桥
# brctl addbr br0
########## 挂载网络设备
# brctl addif br0 eth0
# brctl addif bro veth0</code></pre>
<p><img src="http://jaydenchang.gitee.io/images/images/0x0035/7.1.1-bridge.png" /></p>
<h5 id="linux-路由表">7.1.2 Linux 路由表</h5>
<p>路由表是 Linux 内核的一个模块，通过定义路由表来决定在某个网络 namespace 中包的流向，从而定义请求会到哪个网络设备上：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ip link set veth0 up
# ip link set br0 up
# ip netns exec ns1 ifconfig veth1 172.18.0.2&#x2F;24 up
# ip netns exec ns1 route add default dev veth1
# route add -net 172.18.0.0&#x2F;24 dev br0</code></pre>
<p><img src="http://jaydenchang.gitee.io/images/images/0x0035/7.1.2-route.png" /></p>
<p>通过设置路由，对 IP 地址的请求就能正确被路由到对应的网络设备上，从而实现通信：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ifconfig eth0
eth0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.31.93.218  netmask 255.255.240.0  broadcast 172.31.95.255
        inet6 fe80::215:5dff:fe4e:a16a  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 00:15:5d:4e:a1:6a  txqueuelen 1000  (Ethernet)
        RX packets 829  bytes 394161 (394.1 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 90  bytes 10335 (10.3 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
########## 在namespace访问宿主机
# ip netns exec ns1 ping -c 1 172.31.93.218
PING 172.31.93.218 (172.31.93.218) 56(84) bytes of data.
64 bytes from 172.31.93.218: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.556 ms

--- 172.31.93.218 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.556&#x2F;0.556&#x2F;0.556&#x2F;0.000 ms
######### 从宿主机访问namespace的网络地址
# ping -c 1 172.18.0.2
PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.
64 bytes from 172.18.0.2: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.113 ms

--- 172.18.0.2 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.113&#x2F;0.113&#x2F;0.113&#x2F;0.000 ms</code></pre>
<h5 id="linux-iptables">7.1.3 Linux iptables</h5>
<p>iptables 是对 Linux 内核的 netfilter 模块进行操作和展示的工具，用来管理包的流动和转送。iptables 定义了一套链式处理的结构，在网络包传输的各个阶段可以使用不同的策略和包进行加工、传送或丢弃。在容器虚拟化技术里，常会用到两种策略，MASQUERADE 和 DNAT，用于容器和宿主机外部的网络通信。</p>
<p><strong>MASQUERADE</strong></p>
<p>MASQUERADE 策略可以将请求包中的源地址转换为一个网络设备的地址，例如 <a href="#7.1.2%20Linux%20路由表">7.1.2 Linux 路由表</a> 这一小节里，namespace 中网络设备的地址是 172.18.0.2，这个地址虽然在宿主机可以路由到 br0 的网桥，但是到底宿主机外部后，是不知道如何路由到这个 IP 的，所以如果请求外部地址的话，要先通过 MASQUERADE 策略将这个 IP 转换为宿主机出口网卡的 IP：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># sysctl -w net.ipv4.conf.all.forwarding&#x3D;1
net.ipv4.conf.all.forwarding &#x3D; 1
# iptables -t nat -A POSTROUTING -s 172.18.0.0&#x2F;24 -o eth0 -j MASQUERADE</code></pre>
<p>在 namespace 中请求宿主机外部地址时，将 namespace 中源地址转换为宿主机的地址作为源地址，就可以在 namespace 中访问宿主机外的网络了。</p>
<p><strong>DAT</strong></p>
<p>iptables 中的 DNAT 策略也是做网络地址的转换，不过它是要更换目标地址，常用于将内部网络地址的端口映射出去。例如，上面例子的 namespace 如果要提供服务给宿主机之外的应用要怎么办呢？外部应用没办法直接路由到 172.18.0.2 这个地址，这时候可以用 DNAT 策略。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 172.18.0.2:80</code></pre>
<p>这样就可以把宿主机上的 80 端口的 TCP 请求转发到 namespace 的 172.18.0.2:80，从而实现外部应用的调用。</p>
<h4 id="构建容器网络模型">7.2 构建容器网络模型</h4>
<h5 id="基本模型">7.2.1 基本模型</h5>
<h6 id="网络">网络</h6>
<p>网络是容器的一个集合，在这个网络上的容器可以相互通信。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Network struct &#123;
    Name    string &#x2F;&#x2F; network name
    IpRange *net.IPNet &#x2F;&#x2F; address
    Driver  string &#x2F;&#x2F; network driver name
&#125;</code></pre>
<h6 id="网络端点">网络端点</h6>
<p>网络端点用于连接网络与容器，保证容器内部与网络的通信。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Endpoint struct &#123;
	ID          string           &#96;json:&quot;id&quot;&#96;
	Device      netlink.Veth     &#96;json:&quot;dev&quot;&#96;
	IPAddress   net.IP           &#96;json:&quot;ip&quot;&#96;
	MacAddress  net.HardwareAddr &#96;json:&quot;mac&quot;&#96;
	Network     *Network
	PortMapping []string
&#125;</code></pre>
<p>网络端点的信息传输需要靠网络功能的两个组件配合完成，分别为网络驱动和 IPAM。</p>
<h6 id="网络驱动">网络驱动</h6>
<p>网络驱动是网络功能的一个组件，不同驱动对网络的创建、连接、销毁策略不同，通过在创建网络时指定不同的网络驱动来定义使用哪个驱动做网络的配置。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type NetworkDriver interface &#123;
	Name() string &#x2F;&#x2F; driver name
	Create(subnet string, name string) (*Network, error)
	Delete(network Network) error
	Connect(network *Network, endpoint *Endpoint) error
	Disconnect(network Network, endpoint *Endpoint) error
&#125;</code></pre>
<h6 id="ipam">IPAM</h6>
<p>IPAM 也是网络功能的一个组件，用于网络 IP 地址的分配和释放，包括容器的 IP 和网络网关的 IP。主要功能如下：</p>
<ul>
<li><code>ipam.Allocate(*net.IPNet)</code> 从指定的 subnet 网段中分配 IP　</li>
<li><code>ipam.Release(*net.IPNet, net.IP)</code> 从指定的 subnet 网段中释放掉指定的 IP</li>
</ul>
<p>在构建下面的函数之前，先来补充一些书上没写的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var (
	defaultNetworkPath &#x3D; &quot;&#x2F;var&#x2F;run&#x2F;simple-docker&#x2F;network&#x2F;network&#x2F;&quot; &#x2F;&#x2F; 默认网络配置信息存储位置
	drivers            &#x3D; map[string]NetworkDriver&#123;&#125; &#x2F;&#x2F; 驱动字典，存储驱动信息
	networks           &#x3D; map[string]*Network&#123;&#125; &#x2F;&#x2F; 网络字段，存储网络信息
)</code></pre>
<h5 id="调用关系">7.2.2 调用关系</h5>
<h6 id="创建网络">创建网络</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func CreateNetwork(driver, subnet, name string) error &#123;
	_, cidr, _ :&#x3D; net.ParseCIDR(subnet)
    &#x2F;&#x2F; allocate gateway ip by IPAM
	gatewayIP, err :&#x3D; ipAllocator.Allocate(cidr)
	if err !&#x3D; nil &#123;
		return err
	&#125;
	cidr.IP &#x3D; gatewayIP

	nw, err :&#x3D; drivers[driver].Create(cidr.String(), name)
	if err !&#x3D; nil &#123;
		return err
	&#125;
    &#x2F;&#x2F; save network info
	return nw.dump(defaultNetworkPath)
&#125;</code></pre>
<p>其中，network.dump 和 network.load 方法是将这个网络的配置信息保存在文件系统中，或从网络的配置目录中的文件读取到网络的配置。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (nw *Network) dump(dumpPath string) error &#123;
	if _, err :&#x3D; os.Stat(dumpPath); err !&#x3D; nil &#123;
		if os.IsNotExist(err) &#123;
			os.MkdirAll(dumpPath, 0644)
		&#125; else &#123;
			return err
		&#125;
	&#125;

	nwPath :&#x3D; path.Join(dumpPath, nw.Name)
    &#x2F;&#x2F; create file while empty file, write only, no file
	nwFile, err :&#x3D; os.OpenFile(nwPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error: %v&quot;, err)
		return err
	&#125;
	defer nwFile.Close()

	nwJson, err :&#x3D; json.Marshal(nw)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error: %v&quot;, err)
		return err
	&#125;

	_, err &#x3D; nwFile.Write(nwJson)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error: %v&quot;, err)
		return err
	&#125;
	return nil
&#125;

func (nw *Network) load(dumpPath string) error &#123;
	nwConfigFile, err :&#x3D; os.Open(dumpPath)
	if err !&#x3D; nil &#123;
		return err
	&#125;
	defer nwConfigFile.Close()
	nwJson :&#x3D; make([]byte, 2000)
	n, err :&#x3D; nwConfigFile.Read(nwJson)
	if err !&#x3D; nil &#123;
		return err
	&#125;

	err &#x3D; json.Unmarshal(nwJson[:n], nw)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error load nw info: %v&quot;, err)
		return err
	&#125;
	return nil
&#125;</code></pre>
<h6 id="创建容器并连接网络">创建容器并连接网络</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Connect(networkName string, cinfo *container.ContainerInfo) error &#123;
	network, ok :&#x3D; networks[networkName]
	if !ok &#123;
		return fmt.Errorf(&quot;no Such Network: %s&quot;, networkName)
	&#125;

	ip, err :&#x3D; ipAllocator.Allocate(network.IpRange)
	if err !&#x3D; nil &#123;
		return err
	&#125;

	ep :&#x3D; &amp;Endpoint&#123;
		ID:          fmt.Sprintf(&quot;%s-%s&quot;, cinfo.Id, networkName),
		IPAddress:   ip,
		Network:     network,
		PortMapping: cinfo.PortMapping,
	&#125;
	if err &#x3D; drivers[network.Driver].Connect(network, ep); err !&#x3D; nil &#123;
		return err
	&#125;
	if err &#x3D; configEndpointIpAddressAndRoute(ep, cinfo); err !&#x3D; nil &#123;
		return err
	&#125;

	return configPortMapping(ep, cinfo)
&#125;</code></pre>
<h6 id="展示网络列表">展示网络列表</h6>
<p>从网络配置的目录中加载所有的网络配置信息：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Init() error &#123;
	var bridgeDriver &#x3D; BridgeNetworkDriver&#123;&#125;
	drivers[bridgeDriver.Name()] &#x3D; &amp;bridgeDriver

	if _, err :&#x3D; os.Stat(defaultNetworkPath); err !&#x3D; nil &#123;
		if os.IsNotExist(err) &#123;
			os.MkdirAll(defaultNetworkPath, 0644)
		&#125; else &#123;
			return err
		&#125;
	&#125;

	filepath.Walk(defaultNetworkPath, func(nwPath string, info os.FileInfo, err error) error &#123;
         &#x2F;&#x2F; skip if dir
		if info.IsDir() &#123;
			return nil
		&#125;

		if strings.HasSuffix(nwPath, &quot;&#x2F;&quot;) &#123;
			return nil
		&#125;
         &#x2F;&#x2F; load filename as network name
		_, nwName :&#x3D; path.Split(nwPath)
		nw :&#x3D; &amp;Network&#123;
			Name: nwName,
		&#125;

		if err :&#x3D; nw.load(nwPath); err !&#x3D; nil &#123;
			logrus.Errorf(&quot;error load network: %s&quot;, err)
		&#125;
		&#x2F;&#x2F; save network info to network dic
		networks[nwName] &#x3D; nw
		return nil
	&#125;)

	return nil
&#125;</code></pre>
<p>遍历展示创建的网络：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func ListNetwork() &#123;
	w :&#x3D; tabwriter.NewWriter(os.Stdout, 12, 1, 3, &#39; &#39;, 0)
	fmt.Fprint(w, &quot;NAME\tIpRange\tDriver\n&quot;)
	for _, nw :&#x3D; range networks &#123;
		fmt.Fprintf(w, &quot;%s\t%s\t%s\n&quot;,
			nw.Name,
			nw.IpRange.String(),
			nw.Driver,
		)
	&#125;
	if err :&#x3D; w.Flush(); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;Flush error %v&quot;, err)
		return
	&#125;
&#125;</code></pre>
<h6 id="删除网络">删除网络</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func DeleteNetwork(networkName string) error &#123;
	nw, ok :&#x3D; networks[networkName]
	if !ok &#123;
		return fmt.Errorf(&quot;no Such Network: %s&quot;, networkName)
	&#125;

	if err :&#x3D; ipAllocator.Release(nw.IpRange, &amp;nw.IpRange.IP); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;error Remove Network gateway ip: %s&quot;, err)
	&#125;

	if err :&#x3D; drivers[nw.Driver].Delete(*nw); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;error Remove Network DriverError: %s&quot;, err)
	&#125;

	return nw.remove(defaultNetworkPath)
&#125;</code></pre>
<p>删除网络的同时也删除配置目录的网络配置文件：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (nw *Network) remove(dumpPath string) error &#123;
	if _, err :&#x3D; os.Stat(path.Join(dumpPath, nw.Name)); err !&#x3D; nil &#123;
		if os.IsNotExist(err) &#123;
			return nil
		&#125; else &#123;
			return err
		&#125;
	&#125; else &#123;
		return os.Remove(path.Join(dumpPath, nw.Name))
	&#125;
&#125;</code></pre>
<h4 id="容器地址分配">7.3 容器地址分配</h4>
<p>现在转到 <code>ipam.go</code>。</p>
<h5 id="数据结构定义">7.3.1 数据结构定义</h5>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">const ipamDefaultAllocatorPath &#x3D; &quot;&#x2F;var&#x2F;run&#x2F;simple-docker&#x2F;network&#x2F;ipam&#x2F;subnet.json&quot;

type IPAM struct &#123;
	SubnetAllocatorPath string
	Subnets             *map[string]string
&#125;
&#x2F;&#x2F; 初始化一个IPAM对象，并指定默认分配信息存储位置
var ipAllocator &#x3D; &amp;IPAM&#123;
	SubnetAllocatorPath: ipamDefaultAllocatorPath,
&#125;</code></pre>
<p>反序列化读取网段分配信息和序列化保存网段分配信息：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (ipam *IPAM) load() error &#123;
	if _, err :&#x3D; os.Stat(ipam.SubnetAllocatorPath); err !&#x3D; nil &#123;
		if os.IsNotExist(err) &#123;
			return nil
		&#125; else &#123;
			return err
		&#125;
	&#125;
	subnetConfigFile, err :&#x3D; os.Open(ipam.SubnetAllocatorPath)
	if err !&#x3D; nil &#123;
		return err
	&#125;
	defer subnetConfigFile.Close()
	subnetJson :&#x3D; make([]byte, 2000)
	n, err :&#x3D; subnetConfigFile.Read(subnetJson)
	if err !&#x3D; nil &#123;
		return err
	&#125;

	err &#x3D; json.Unmarshal(subnetJson[:n], ipam.Subnets)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;Error dump allocation info, %v&quot;, err)
		return err
	&#125;
	return nil
&#125;

func (ipam *IPAM) dump() error &#123;
	ipamConfigFileDir, _ :&#x3D; path.Split(ipam.SubnetAllocatorPath)
	if _, err :&#x3D; os.Stat(ipamConfigFileDir); err !&#x3D; nil &#123;
		if os.IsNotExist(err) &#123;
			os.MkdirAll(ipamConfigFileDir, 0644)
		&#125; else &#123;
			return err
		&#125;
	&#125;
	subnetConfigFile, err :&#x3D; os.OpenFile(ipam.SubnetAllocatorPath, os.O_TRUNC|os.O_WRONLY|os.O_CREATE, 0644)
	if err !&#x3D; nil &#123;
		return err
	&#125;
	defer subnetConfigFile.Close()

	ipamConfigJson, err :&#x3D; json.Marshal(ipam.Subnets)
	if err !&#x3D; nil &#123;
		return err
	&#125;

	_, err &#x3D; subnetConfigFile.Write(ipamConfigJson)
	if err !&#x3D; nil &#123;
		return err
	&#125;

	return nil
&#125;</code></pre>
<h5 id="地址分配">7.3.2 地址分配</h5>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (ipam *IPAM) Allocate(subnet *net.IPNet) (ip net.IP, err error) &#123;
	ipam.Subnets &#x3D; &amp;map[string]string&#123;&#125;

	err &#x3D; ipam.load()
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error dump allocation info, %v&quot;, err)
	&#125;

	_, subnet, _ &#x3D; net.ParseCIDR(subnet.String())

	one, size :&#x3D; subnet.Mask.Size()

	if _, exist :&#x3D; (*ipam.Subnets)[subnet.String()]; !exist &#123;
        &#x2F;&#x2F; 用0填满网段的配置，1&lt;&lt;uint8(size-one)表示这个网段中有多少个可用地址
        &#x2F;&#x2F; size-one时子网掩码后面的网络位数，2^(size-one)表示网段中的可用IP数
        &#x2F;&#x2F; 2^(size-one)等价于1&lt;&lt;uint8(size-one)
        (*ipam.Subnets)[subnet.String()] &#x3D; strings.Repeat(&quot;0&quot;, 1&lt;&lt;uint8(size-one))
	&#125;
	&#x2F;&#x2F; 这里的原理建议大家看看原著
	for c :&#x3D; range (*ipam.Subnets)[subnet.String()] &#123;
		if (*ipam.Subnets)[subnet.String()][c] &#x3D;&#x3D; &#39;0&#39; &#123;
            ipalloc :&#x3D; []byte((*ipam.Subnets)[subnet.String()])
            &#x2F;&#x2F; go的字符串创建后不能修改，先用byte存储
            ipalloc[c] &#x3D; &#39;1&#39;
            (*ipam.Subnets)[subnet.String()] &#x3D; string(ipalloc)
            &#x2F;&#x2F; 
            ip &#x3D; subnet.IP
            
            &#x2F;&#x2F; 通过网段的IP与上面的偏移相加得出分配的IP，由于IP是一个uint的一个数组，需要通过数组中的每一项加所需要的值，例			 &#x2F;&#x2F; 如网段是172.16.0.0&#x2F;12，数组序号是65555，那就要在[172,16,0,0]上依次加
            &#x2F;&#x2F; [uint8(65555 &gt;&gt; 24), uint8(65555 &gt;&gt; 16), uint8(65555 &gt;&gt; 8), uint(65555 &gt;&gt; 4)]，即[0,1,0,19]，
            &#x2F;&#x2F; 那么获得的IP就是172.17.0.19
            for t :&#x3D; uint(4); t &gt; 0; t-- &#123;
                []byte(ip)[4-t] +&#x3D; uint8(c &gt;&gt; ((t - 1) * 8))
            &#125;
            &#x2F;&#x2F; 由于此处IP是从1开始分配的，所以最后再加1，最终得到分配的IP是172.16.0.20
            ip[3]++
            break
		&#125;
	&#125;

	ipam.dump()
	return
&#125;</code></pre>
<h5 id="地址释放">7.3.3 地址释放</h5>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (ipam *IPAM) Release(subnet *net.IPNet, ipaddr *net.IP) error &#123;
    ipam.Subnets &#x3D; &amp;map[string]string&#123;&#125;

    _, subnet, _ &#x3D; net.ParseCIDR(subnet.String())

    err :&#x3D; ipam.load()
    if err !&#x3D; nil &#123;
        logrus.Errorf(&quot;Error dump allocation info, %v&quot;, err)
    &#125;

    c :&#x3D; 0
    &#x2F;&#x2F; 将IP转换为4个字节的表示方式
    releaseIP :&#x3D; ipaddr.To4()
    &#x2F;&#x2F; 由于IP是从1开始分配的，所以转换成索引减1
    releaseIP[3] -&#x3D; 1
    for t :&#x3D; uint(4); t &gt; 0; t -&#x3D; 1 &#123;
        &#x2F;&#x2F; 和分配IP相反，释放IP获得索引的方式是IP的每一位相减后分别左移将对应的数值加到索引上
        c +&#x3D; int(releaseIP[t-1]-subnet.IP[t-1]) &lt;&lt; ((4 - t) * 8)
    &#125;

    ipalloc :&#x3D; []byte((*ipam.Subnets)[subnet.String()])
    ipalloc[c] &#x3D; &#39;0&#39;
    (*ipam.Subnets)[subnet.String()] &#x3D; string(ipalloc)

    ipam.dump()
    return nil
&#125;</code></pre>
<p>根据书上，写到这里就开始测试了，但是我们看看 IDE，红海一片，所以我们接着实现。</p>
<h4 id="创建-bridge-网络">7.4 创建 bridge 网络</h4>
<h5 id="实现-bridge-driver-create">7.4.1 实现 Bridge Driver Create</h5>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (d *BridgeNetworkDriver) Create(subnet string, name string) (*Network, error) &#123;
	ip, ipRange, _ :&#x3D; net.ParseCIDR(subnet)
	ipRange.IP &#x3D; ip
	n :&#x3D; &amp;Network&#123;
		Name:    name,
		IpRange: ipRange,
		Driver:  d.Name(),
	&#125;
	err :&#x3D; d.initBridge(n)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error init bridge: %v&quot;, err)
	&#125;

	return n, err
&#125;</code></pre>
<h5 id="bridge-driver-初始化-linux-bridge">7.4.2 Bridge Driver 初始化 Linux Bridge</h5>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (d *BridgeNetworkDriver) initBridge(n *Network) error &#123;
	&#x2F;&#x2F; 创建bridge虚拟设备
	bridgeName :&#x3D; n.Name
	if err :&#x3D; createBridgeInterface(bridgeName); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;eror add bridge: %s, error: %v&quot;, bridgeName, err)
	&#125;

	&#x2F;&#x2F; 设置bridge设备的地址和路由
	gatewayIP :&#x3D; *n.IpRange
	gatewayIP.IP &#x3D; n.IpRange.IP
	if err :&#x3D; setInterfaceIP(bridgeName, gatewayIP.String()); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;error assigning address: %s on bridge: %s with an error of: %v&quot;, gatewayIP, bridgeName, err)
	&#125;
	&#x2F;&#x2F; 启动bridge设备
	if err :&#x3D; setInterfaceUP(bridgeName); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;error set bridge up: %s, error: %v&quot;, bridgeName, err)
	&#125;

	&#x2F;&#x2F; 设置iptables的SNAT规则
	if err :&#x3D; setupIPTables(bridgeName, n.IpRange); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;error setting iptables for %s: %v&quot;, bridgeName, err)
	&#125;

	return nil
&#125;</code></pre>
<h6 id="创建-bridge-设备">创建 bridge 设备</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func createBridgeInterface(bridgeName string) error &#123;
	_, err :&#x3D; net.InterfaceByName(bridgeName)
	if err &#x3D;&#x3D; nil || !strings.Contains(err.Error(), &quot;no such network interface&quot;) &#123;
		return err
	&#125;

	&#x2F;&#x2F; create *netlink.Bridge object
	la :&#x3D; netlink.NewLinkAttrs()
	la.Name &#x3D; bridgeName

	br :&#x3D; &amp;netlink.Bridge&#123;LinkAttrs: la&#125;
	if err :&#x3D; netlink.LinkAdd(br); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;bridge creation failed for bridge %s: %v&quot;, bridgeName, err)
	&#125;
	return nil
&#125;</code></pre>
<h6 id="设置-bridge-设备的地址和路由">设置 bridge 设备的地址和路由</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func setInterfaceIP(name string, rawIP string) error &#123;
	retries :&#x3D; 2
	var iface netlink.Link
	var err error
	for i :&#x3D; 0; i &lt; retries; i++ &#123;
		iface, err &#x3D; netlink.LinkByName(name)
		if err &#x3D;&#x3D; nil &#123;
			break
		&#125;
		logrus.Debugf(&quot;error retrieving new bridge netlink link [ %s ]... retrying&quot;, name)
		time.Sleep(2 * time.Second)
	&#125;
	if err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;abandoning retrieving the new bridge link from netlink, Run [ ip link ] to troubleshoot the error: %v&quot;, err)
	&#125;
	ipNet, err :&#x3D; netlink.ParseIPNet(rawIP)
	if err !&#x3D; nil &#123;
		return err
	&#125;
	addr :&#x3D; &amp;netlink.Addr&#123;
		IPNet:     ipNet,
		Peer:      ipNet,
		Label:     &quot;&quot;,
		Flags:     0,
		Scope:     0,
		Broadcast: nil,
	&#125;
	return netlink.AddrAdd(iface, addr)
&#125;</code></pre>
<h6 id="启动-bridge-设备">启动 bridge 设备</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func setInterfaceUP(interfaceName string) error &#123;
	iface, err :&#x3D; netlink.LinkByName(interfaceName)
	if err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;error retrieving a link named [ %s ]: %v&quot;, iface.Attrs().Name, err)
	&#125;

	if err :&#x3D; netlink.LinkSetUp(iface); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;error enabling interface for %s: %v&quot;, interfaceName, err)
	&#125;
	return nil
&#125;</code></pre>
<h6 id="设置-iptables-linux-bridge-snat-规则">设置 iptables Linux Bridge SNAT 规则</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func setupIPTables(bridgeName string, subnet *net.IPNet) error &#123;
	iptablesCmd :&#x3D; fmt.Sprintf(&quot;-t nat -A POSTROUTING -s %s ! -o %s -j MASQUERADE&quot;, subnet.String(), bridgeName)
	cmd :&#x3D; exec.Command(&quot;iptables&quot;, strings.Split(iptablesCmd, &quot; &quot;)...)
	&#x2F;&#x2F;err :&#x3D; cmd.Run()
	output, err :&#x3D; cmd.Output()
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;iptables Output, %v&quot;, output)
	&#125;
	return err
&#125;</code></pre>
<h5 id="bridge-driver-delete-实现">7.4.3 Bridge Driver Delete 实现</h5>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (d *BridgeNetworkDriver) Delete(network Network) error &#123;
	bridgeName :&#x3D; network.Name
	br, err :&#x3D; netlink.LinkByName(bridgeName)
	if err !&#x3D; nil &#123;
		return err
	&#125;
	return netlink.LinkDel(br)
&#125;</code></pre>
<h4 id="在-bridge-网络创建容器">7.5 在 bridge 网络创建容器</h4>
<h5 id="挂载容器端点">7.5.1 挂载容器端点</h5>
<h6 id="连接容器网络端点到-linux-bridge">连接容器网络端点到 Linux Bridge</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (d *BridgeNetworkDriver) Connect(network *Network, endpoint *Endpoint) error &#123;
	bridgeName :&#x3D; network.Name
	br, err :&#x3D; netlink.LinkByName(bridgeName)
	if err !&#x3D; nil &#123;
		return err
	&#125;

	la :&#x3D; netlink.NewLinkAttrs()
	la.Name &#x3D; endpoint.ID[:5]
	la.MasterIndex &#x3D; br.Attrs().Index

	endpoint.Device &#x3D; netlink.Veth&#123;
		LinkAttrs: la,
		PeerName:  &quot;cif-&quot; + endpoint.ID[:5],
	&#125;

	if err &#x3D; netlink.LinkAdd(&amp;endpoint.Device); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;error Add Endpoint Device: %v&quot;, err)
	&#125;

	if err &#x3D; netlink.LinkSetUp(&amp;endpoint.Device); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;error Add Endpoint Device: %v&quot;, err)
	&#125;
	return nil
&#125;</code></pre>
<h6 id="配置容器-namespace-中网络设备及路由">配置容器 Namespace 中网络设备及路由</h6>
<p>回到 <code>network.go</code></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func configEndpointIpAddressAndRoute(ep *Endpoint, cinfo *container.ContainerInfo) error &#123;
	peerLink, err :&#x3D; netlink.LinkByName(ep.Device.PeerName)
	if err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;fail config endpoint: %v&quot;, err)
	&#125;

	defer enterContainerNetns(&amp;peerLink, cinfo)()

	interfaceIP :&#x3D; *ep.Network.IpRange
	interfaceIP.IP &#x3D; ep.IPAddress

	if err &#x3D; setInterfaceIP(ep.Device.PeerName, interfaceIP.String()); err !&#x3D; nil &#123;
		return fmt.Errorf(&quot;%v,%s&quot;, ep.Network, err)
	&#125;

	if err &#x3D; setInterfaceUP(ep.Device.PeerName); err !&#x3D; nil &#123;
		return err
	&#125;

	if err &#x3D; setInterfaceUP(&quot;lo&quot;); err !&#x3D; nil &#123;
		return err
	&#125;

	_, cidr, _ :&#x3D; net.ParseCIDR(&quot;0.0.0.0&#x2F;0&quot;)

	defaultRoute :&#x3D; &amp;netlink.Route&#123;
		LinkIndex: peerLink.Attrs().Index,
		Gw:        ep.Network.IpRange.IP,
		Dst:       cidr,
	&#125;

	if err &#x3D; netlink.RouteAdd(defaultRoute); err !&#x3D; nil &#123;
		return err
	&#125;

	return nil
&#125;</code></pre>
<h6 id="进入容器-net-namespace">进入容器 Net Namespace</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func enterContainerNetns(enLink *netlink.Link, cinfo *container.ContainerInfo) func() &#123;
	f, err :&#x3D; os.OpenFile(fmt.Sprintf(&quot;&#x2F;proc&#x2F;%s&#x2F;ns&#x2F;net&quot;, cinfo.Pid), os.O_RDONLY, 0)
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error get container net namespace, %v&quot;, err)
	&#125;

	nsFD :&#x3D; f.Fd()
	runtime.LockOSThread()

	if err &#x3D; netlink.LinkSetNsFd(*enLink, int(nsFD)); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error set link netns , %v&quot;, err)
	&#125;

	origns, err :&#x3D; netns.Get()
	if err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error get current netns, %v&quot;, err)
	&#125;

	if err &#x3D; netns.Set(netns.NsHandle(nsFD)); err !&#x3D; nil &#123;
		logrus.Errorf(&quot;error set netns, %v&quot;, err)
	&#125;
	return func() &#123;
		netns.Set(origns)
		origns.Close()
		runtime.UnlockOSThread()
		f.Close()
	&#125;
&#125;</code></pre>
<h6 id="配置宿主机到容器的端口映射">配置宿主机到容器的端口映射</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func configPortMapping(ep *Endpoint, cinfo *container.ContainerInfo) error &#123;
	for _, pm :&#x3D; range ep.PortMapping &#123;
		portMapping :&#x3D; strings.Split(pm, &quot;:&quot;)
		if len(portMapping) !&#x3D; 2 &#123;
			logrus.Errorf(&quot;port mapping format error, %v&quot;, pm)
			continue
		&#125;
		iptablesCmd :&#x3D; fmt.Sprintf(&quot;-t nat -A PREROUTING -p tcp -m tcp --dport %s -j DNAT --to-destination %s:%s&quot;,
			portMapping[0], ep.IPAddress.String(), portMapping[1])
		cmd :&#x3D; exec.Command(&quot;iptables&quot;, strings.Split(iptablesCmd, &quot; &quot;)...)
		&#x2F;&#x2F;err :&#x3D; cmd.Run()
		output, err :&#x3D; cmd.Output()
		if err !&#x3D; nil &#123;
			logrus.Errorf(&quot;iptables Output, %v&quot;, output)
			continue
		&#125;
	&#125;
	return nil
&#125;</code></pre>
<h5 id="修补-bug">7.5.2 修补 bug</h5>
<p>写到这里，代码还是有很多 bug 的，例如，<code>BridgeNetworkDriver</code> 未完全继承 <code>NetworkDriver</code> 的所有函数。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (d *BridgeNetworkDriver) Disconnect(network Network, endpoint *Endpoint) error &#123;
	return nil
&#125;</code></pre>
<h5 id="测试">7.5.3 测试</h5>
<p>现在终于可以测试了。</p>
<p>首先创建一个网桥：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . network create --driver bridge --subnet 192.168.10.1&#x2F;24 testbridge</code></pre>
<p>然后启动两个容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -it -net testbridge busybox sh
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Start initiating...&quot;,&quot;time&quot;:&quot;2023-05-20T19:24:53+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: sh&quot;,&quot;time&quot;:&quot;2023-05-20T19:24:53+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Current location is &#x2F;root&#x2F;mnt&#x2F;8116248511&quot;,&quot;time&quot;:&quot;2023-05-20T19:24:53+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Find path: &#x2F;bin&#x2F;sh&quot;,&quot;time&quot;:&quot;2023-05-20T19:24:53+08:00&quot;&#125;
&#x2F; # ifconfig
cif-81162 Link encap:Ethernet  HWaddr 16:62:68:81:E0:A9
          inet addr:192.168.10.2  Bcast:192.168.10.255  Mask:255.255.255.0
          inet6 addr: fe80::1462:68ff:fe81:e0a9&#x2F;64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:14 errors:0 dropped:0 overruns:0 frame:0
          TX packets:6 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:1820 (1.7 KiB)  TX bytes:516 (516.0 B)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1&#x2F;128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

&#x2F; #</code></pre>
<p>记住这个 IP：<code>192.168.10.2</code>，然后进入另一个容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -it -net testbridge busybox sh
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Start initiating...&quot;,&quot;time&quot;:&quot;2023-05-20T19:26:24+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: sh&quot;,&quot;time&quot;:&quot;2023-05-20T19:26:24+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Current location is &#x2F;root&#x2F;mnt&#x2F;9558830402&quot;,&quot;time&quot;:&quot;2023-05-20T19:26:24+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Find path: &#x2F;bin&#x2F;sh&quot;,&quot;time&quot;:&quot;2023-05-20T19:26:24+08:00&quot;&#125;
&#x2F; # ifconfig
cif-95588 Link encap:Ethernet  HWaddr 42:18:0A:73:33:CA
          inet addr:192.168.10.3  Bcast:192.168.10.255  Mask:255.255.255.0
          inet6 addr: fe80::4018:aff:fe73:33ca&#x2F;64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:10 errors:0 dropped:0 overruns:0 frame:0
          TX packets:6 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:1248 (1.2 KiB)  TX bytes:516 (516.0 B)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1&#x2F;128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

&#x2F; # ping 192.168.10.2
PING 192.168.10.2 (192.168.10.2): 56 data bytes
64 bytes from 192.168.10.2: seq&#x3D;0 ttl&#x3D;64 time&#x3D;2.619 ms
64 bytes from 192.168.10.2: seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.086 ms
^C
--- 192.168.10.2 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min&#x2F;avg&#x2F;max &#x3D; 0.086&#x2F;1.352&#x2F;2.619 ms
&#x2F; #</code></pre>
<p>可以看到，两个容器网络互通。</p>
<p>下面来试一下访问外部网络。我用的 WSL，默认的 nat 是关闭的，前期各种设置 iptables 规则什么的，都无法访问容器外部的网络，直到发现一篇帖子里说到，需要打开内核的 nat 功能，要将文件<code>/proc/sys/net/ipv4/ip_forward</code>内的值改为1（默认是0）。执行 <code>sysctl -w net.ipv4.ip_forward=1</code> 即可。</p>
<p>修改之后，继续测试。</p>
<p>容器默认是没有 DNS 服务器的，需要我们手动添加：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F; # ping cn.bing.com
ping: bad address &#39;cn.bing.com&#39;
&#x2F; # echo -e &quot;nameserver 8.8.8.8&quot; &gt; &#x2F;etc&#x2F;resolv.conf
&#x2F; # ping cn.bing.com
PING cn.bing.com (202.89.233.101): 56 data bytes
64 bytes from 202.89.233.101: seq&#x3D;0 ttl&#x3D;113 time&#x3D;38.419 ms
64 bytes from 202.89.233.101: seq&#x3D;1 ttl&#x3D;113 time&#x3D;39.011 ms
^C
--- cn.bing.com ping statistics ---
3 packets transmitted, 2 packets received, 33% packet loss
round-trip min&#x2F;avg&#x2F;max &#x3D; 38.419&#x2F;38.715&#x2F;39.011 ms
&#x2F; #</code></pre>
<p>然后再来测试容器映射端口到宿主机供外部访问：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># go run . run -it -p 90:90 -net testbridge busybox sh
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Start initiating...&quot;,&quot;time&quot;:&quot;2023-05-20T19:39:07+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;whole init command is: sh&quot;,&quot;time&quot;:&quot;2023-05-20T19:39:07+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Current location is &#x2F;root&#x2F;mnt&#x2F;3445154844&quot;,&quot;time&quot;:&quot;2023-05-20T19:39:07+08:00&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Find path: &#x2F;bin&#x2F;sh&quot;,&quot;time&quot;:&quot;2023-05-20T19:39:07+08:00&quot;&#125;
&#x2F; # nc -lp 90</code></pre>
<p>然后访问宿主机的 80 端口，看看能不能转发到容器里：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># telnet 172.31.93.218 90
Trying 172.31.93.218...
telnet: Unable to connect to remote host: Connection refused</code></pre>
<p>开始我以为是我哪里码错了，然后拿作者的代码来跑，并放到虚拟机上跑，发现并不是自己的问题，那只能这样测试了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># telnet 192.168.10.3 90
Trying 192.168.10.3...
Connected to 192.168.10.3.
Escape character is &#39;^]&#39;.</code></pre>
<p>出现这样的字眼后，容器和宿主机之间就可以通信了。</p>
<h2 id="参考链接">参考链接</h2>
<p><a target="_blank" rel="noopener" href="https://learnku.com/articles/42072">七天用 Go 写个 docker（第一天） | Go 技术论坛 (learnku.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6971335828060504094">使用 GoLang 从零开始写一个 Docker（概念篇）-- 《自己动手写 Docker》读书笔记 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.xtlsoft.top/read/server/building-wsl-kernel-with-aufs.html">编译带有 AUFS 支持的 WSL 内核 - 徐天乐 :: 个人博客 (xtlsoft.top)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/324530180">如何让WSL2使用自己编译的内核 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fangford/article/details/107728458">goland时间格式化time.Now().Format_golang time.now().format_好狗不见的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7086069688664326157#heading-1">自己动手写Docker系列 -- 5.7实现通过容器制作镜像 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tycoon1988/article/details/40781291">iptable端口重定向 MASQUERADE_tycoon1988的博客-CSDN博客</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag"># 技术</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Golang/" rel="tag"># Golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/0x0034.html" rel="prev" title="mit 6.824 lab1 思路贴">
                  <i class="fa fa-chevron-left"></i> mit 6.824 lab1 思路贴
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/0x0036.html" rel="next" title="基于Ubuntu20.04在k8s 1.25部署gin+MySQL服务">
                  基于Ubuntu20.04在k8s 1.25部署gin+MySQL服务 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jayden Chang</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">475k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">7:12</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/code-unfold.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"enable","tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"JaydenChang","repo":"jaydenchang.github.io","client_id":"4eefd4ac7c2004ef4002","client_secret":"83b3a65014e1cfa0565541412c12518873e5583f","admin_user":"JaydenChang","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"aa94db3e1bdc5ce07bca302cfd5e0747"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>




</body>
</html>
