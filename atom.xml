<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jayden&#39;s Blog</title>
  
  
  <link href="https://jaydenchang.top/atom.xml" rel="self"/>
  
  <link href="https://jaydenchang.top/"/>
  <updated>2021-12-11T06:08:25.654Z</updated>
  <id>https://jaydenchang.top/</id>
  
  <author>
    <name>Jayden Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-图及最小生成树</title>
    <link href="https://jaydenchang.top/post/0x0029.html"/>
    <id>https://jaydenchang.top/post/0x0029.html</id>
    <published>2021-12-08T16:00:00.000Z</published>
    <updated>2021-12-11T06:08:25.654Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更了 <del>其实摸鱼摸太久了</del>，当然也是最近太多事，一直没有时间去打理博客，趁着周末有空，来整理下图部分的内容</p><p>这里来总结下无向图、最小生成树(prim和Dijkstra)算法</p><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 到后面发现，visited在无向图中设计的是真的巧妙template &lt;class DataType&gt;class MGraph &#123;    public:      MGraph(DataType a[], int n, int e); &#x2F;&#x2F; 构造函数，构造有n个顶点e条边的图     ~MGraph() &#123;&#125;     void DFS(int); &#x2F;&#x2F; 深搜     void BFS(int); &#x2F;&#x2F; 广搜        private:     DataType vertex[maxSize]; &#x2F;&#x2F; 存放图中顶点的数组     int edge[maxSize][maxSize]; &#x2F;&#x2F; 存放图中边的数组     int vertexNum, edgeNum; &#x2F;&#x2F; 图中的顶点数和变数&#125;;</code></pre><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, k;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i]; &#x2F;&#x2F; 储存顶点    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            edge[i][j] &#x3D; 0; &#x2F;&#x2F; 初始化邻接矩阵        &#125;    &#125;    for (k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cin &gt;&gt; i &gt;&gt; j; &#x2F;&#x2F; 以此输入每条边依附的两个顶点的编号        edge[i][j] &#x3D; 1; &#x2F;&#x2F; 对输入的边做标记(无向图，双向标记)        edge[j][i] &#x3D; 1;    &#125;&#125;</code></pre><h5 id="广搜和深搜"><a href="#广搜和深搜" class="headerlink" title="广搜和深搜"></a>广搜和深搜</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;        if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0)             DFS(j);        &#x2F;&#x2F; 递归的妙处会在后面讲到    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int w, j, queue[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; queue数组记录的是访问矩阵第几行的顺序    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        visited[i] &#x3D; 0;    &#125;    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;    MGraph&lt;char&gt; MG(ch, 6, 6);    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS order: \n&quot;;    MG.DFS(0);    cout &lt;&lt; &quot;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;;    cout &lt;&lt; &quot;BFS order: \n&quot;;    MG.BFS(0);&#125;</code></pre><h5 id="测试用例及其邻接矩阵"><a href="#测试用例及其邻接矩阵" class="headerlink" title="测试用例及其邻接矩阵"></a>测试用例及其邻接矩阵</h5><p>测试数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0 10 20 51 21 43 4</code></pre><p>邻接矩阵</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0 1 2 3 4 5 0&#39;   1 1     1 &#39;1&#39; 1   1   1   &#39;2&#39; 1 1         &#39;3&#39;         1   &#39;4&#39;   1   1     &#39; 5&#39; 1           &#39;&#x2F;&#x2F; 以横轴为x，竖轴为y       </code></pre><p>借用这个样例来说一下深搜和广搜</p><h6 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h6><p>已知无向图的邻接矩阵是关于对角线对称的，深搜从第一行开始搜索，搜索到<code>(1,0)</code>时进入递归，进入递归后，首先对<code>visited[v]</code>进行标记，通过观察可以知道，上一轮DFS传入的j和下一轮DFS的v在矩阵中关于对角线对称 <del>好像是个无用信息</del>，每一轮DFS的<code>visited[v]=1</code>就是为了避免重复访问<code>vertex[v]</code>，再加上那条if语句的配合，即可无重复遍历完整个图</p><h6 id="广搜"><a href="#广搜" class="headerlink" title="广搜"></a>广搜</h6><p>广搜的话其实还是要自己画出一个无向图来并且在debug模式运行一遍才知道大概是怎么个流程。对上面的测试用例来说，在第一轮搜索时，访问的都是和0号这个点有通路的点，第二轮是1号，第三轮是2号，依此类推。如果把最开始输入的0号放在中间，后面输入的数据一圈圈和0号联通，产生关联，那么广搜可以理解为，从搜寻点一圈圈向外扩散找</p><h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;class MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);        private:     int vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, k;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            edge[i][j] &#x3D; 0;        &#125;    &#125;    for (k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cin &gt;&gt; i &gt;&gt; j;        edge[i][j] &#x3D; 1;        edge[j][i] &#x3D; 1;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;        if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0)            DFS(j);    &#125;&#125;template &lt;class DateType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int w, j, queue[maxSize] &#x3D; &#123;0&#125;;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        visited[i] &#x3D; 0;    &#125;    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;    int i;    MGraph&lt;char&gt; MG(ch, 6, 6);    for (i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS order: \n&quot;;    MG.DFS(0);    cout &lt;&lt; &quot;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;;    cout &lt;&lt; &quot;BFS order: \n&quot;;    MG.BFS(0);&#125;</code></pre><h4 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h4><h5 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;class MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);     void Prim(int);     int minEdge(int[], int);        private:     DataType vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;</code></pre><h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, w &#x3D; 0;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                 edge[i][j] &#x3D; 0; &#x2F;&#x2F; 这里忽略自环            else                edge[i][j] &#x3D; 100;            &#x2F;&#x2F; 这里初始化权值，赋比较大的数即可        &#125;    &#125;    for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cout &lt;&lt; &quot;input two points of the edge: &quot;;        cin &gt;&gt; i &gt;&gt; j;        cout &lt;&lt; &quot;input the weight of the edge: &quot; ;        cin &gt;&gt; w;        edge[i][j] &#x3D; w;        edge[j][i] &#x3D; w;    &#125;&#125;</code></pre><h5 id="prim代码实现"><a href="#prim代码实现" class="headerlink" title="prim代码实现"></a>prim代码实现</h5><p>将图中顶点（V）分两部分，最小生成树的点集为U，其余顶点在集合（V-U）</p><ul><li><ol><li>首先任取一个点作为起点</li></ol></li><li><ol start="2"><li>在V-U中找和起点之间权值最小的边</li></ol></li><li><ol start="3"><li>adjVex记录上一轮找最小值的位置，cost记录到各顶点的距离</li></ol></li><li><ol start="4"><li>然后上一轮找到的权值最小的边的另一个点作为起点，不断重复步骤2，3</li></ol></li></ul><h6 id="找到最小值位置"><a href="#找到最小值位置" class="headerlink" title="找到最小值位置"></a>找到最小值位置</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;int MGraph&lt;DataType&gt;::minEdge(int r[], int n) &#123;    int index;    int min &#x3D; 100; &#x2F;&#x2F; 图中all权值最大不超过100    for (int i &#x3D; 0; i &lt; n; i++) &#123;        if (r[i] !&#x3D; 0 &amp;&amp; r[i] &lt; min) &#123;            min &#x3D; r[i];            index &#x3D; i;        &#125;    &#125;    return index; &#x2F;&#x2F; 返回最小值在数组中的位置&#125;</code></pre><h6 id="prim核心代码"><a href="#prim核心代码" class="headerlink" title="prim核心代码"></a>prim核心代码</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Prim(int v) &#123;    int adjVex[maxSize], cost[maxSize];    int i, j, k;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        &#x2F;&#x2F; 通过起点对adjVex，cost数组初始化        cost[i] &#x3D; edge[v][i];        adjVex[i] &#x3D; v;        &#x2F;&#x2F; 将起点所有有联通的点都录入cost中，找权值最小的边(类似BFS)    &#125;    cost[v] &#x3D; 0; &#x2F;&#x2F; 将顶点加入u中    for (k &#x3D; 1; k &lt; vertexNum; k++) &#123;        j &#x3D; minEdge(cost, vertexNum); &#x2F;&#x2F; 在cost数组找最小值        &#x2F;&#x2F; cout &lt;&lt; &#39;(&#39; &lt;&lt; adjVex[j] &lt;&lt; &#39;,&#39; &lt;&lt; j &lt;&lt; &#39;)&#39; &lt;&lt; cost[j] &lt;&lt; endl; &#x2F;&#x2F; 输出的是点的序号        cout &lt;&lt; &#39;(&#39; &lt;&lt; vertex[j] &lt;&lt; &#39;,&#39; &lt;&lt; vertex[adjVex[j]] &lt;&lt; &#39;)&#39; &lt;&lt; cost[j] &lt;&lt; endl;  &#x2F;&#x2F; 输出的是字符        &#x2F;&#x2F; 输出生成最小生成树的过程(都是输出上一轮查找结果)        cost[j] &#x3D; 0; &#x2F;&#x2F; 将最小值的点加入U中(清零当前最小值的权值，防止后面重复遍历)        for (int p &#x3D; 0; p &lt; vertexNum; p++) &#123;            &#x2F;&#x2F; 这一步，是以第j号为起点，不断寻找和j号联通的最小权值的路线            if (edge[p][j] &lt; cost[p]) &#123;                &#x2F;&#x2F; 从所有与当前最小值临界点出发找到最小值点权值最小的                cost[p] &#x3D; edge[p][j];                adjVex[p] &#x3D; j; &#x2F;&#x2F; 记录新加入顶点上一轮迭代的最小值的位置            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="测试用例及邻接矩阵"><a href="#测试用例及邻接矩阵" class="headerlink" title="测试用例及邻接矩阵"></a>测试用例及邻接矩阵</h5><pre class="line-numbers language-none"><code class="language-none">0 1340 2460 5191 4122 3172 5253 4383 5254 526</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0  1  2  3  4  5 0&#39;    34 46       19 &#39;1&#39; 34          12    &#39;2&#39; 46       17    25 &#39;3&#39;       17    38    &#39;4&#39;    12    38    26 &#39; 5&#39; 19    25    26    &#39;&#x2F;&#x2F; 以横轴为x，竖轴为y       </code></pre><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><h5 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 到后面发现，visited在无向图中设计的是真的巧妙template &lt;class DataType&gt;class MGraph &#123;    public:      MGraph(DataType a[], int n, int e); &#x2F;&#x2F; 构造函数，构造有n个顶点e条边的图     ~MGraph() &#123;&#125;     void DFS(int); &#x2F;&#x2F; 深搜     void BFS(int); &#x2F;&#x2F; 广搜        private:     DataType vertex[maxSize]; &#x2F;&#x2F; 存放图中顶点的数组     int edge[maxSize][maxSize]; &#x2F;&#x2F; 存放图中边的数组     int vertexNum, edgeNum; &#x2F;&#x2F; 图中的顶点数和变数&#125;;</code></pre><h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    vertexNum &#x3D; e, edgeNum &#x3D; n;    int i, j, w &#x3D; 0;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                 edge[i][j] &#x3D; 0;            else                edge[i][j] &#x3D; 100;        &#125;        for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;            cout &lt;&lt; &quot;input two vertexes of the edge: &quot;;            cin &gt;&gt; i &gt;&gt; j;            cout &lt;&lt; &quot;input the weight of the edge: &quot;;            cin &gt;&gt; w;            edge[i][j] &#x3D; w;        &#125;    &#125;&#125;</code></pre><h5 id="深搜和广搜"><a href="#深搜和广搜" class="headerlink" title="深搜和广搜"></a>深搜和广搜</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        if (edge[v][i] &lt; 100 &amp;&amp; visited[i] &#x3D;&#x3D; 0)             DFS(i);    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int queue[maxSize];    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &lt; 100 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[v];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; 1;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="Dijkstra-1"><a href="#Dijkstra-1" class="headerlink" title="Dijkstra"></a>Dijkstra</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Dijkstra(MGraph&lt;DataType&gt; mg, int v) &#123;    int dist[maxSize];    &#x2F;&#x2F; dist为起点到各个点的距离，具有临时性    string path[maxSize];    string vertex(mg.vertex);    for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;        dist[i] &#x3D; mg.edge[v][i];        &#x2F;&#x2F; 初始化dist数组，0号顶点到其余各顶点的初始路程        if (dist[i] !&#x3D; 100) &#123;            path[i] +&#x3D; vertex[v];            path[i] +&#x3D; vertex[i];            &#x2F;&#x2F; 这里是记录起点可以直达的路径        &#125; else &#123;            path[i] &#x3D; &quot;&quot;;        &#125;    &#125;    dist[v] &#x3D; 0;    int num &#x3D; 1;    while (num &lt; mg.vertexNum) &#123;        int min &#x3D; 255, k &#x3D; 0; &#x2F;&#x2F; 每一轮重置最小值        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (dist[i] !&#x3D; 0 &amp;&amp; dist[i] &lt; min) &#123;                min &#x3D; dist[i];                k &#x3D; i;                &#x2F;&#x2F; 找最小值            &#125;        &#125;        &#x2F;&#x2F; cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; dist[k] &lt;&lt; &quot;;\n&quot;;        num++; &#x2F;&#x2F; 标记这是第几个被访问的点        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (dist[i] &gt; dist[k] + mg.edge[k][i]) &#123;                dist[i] &#x3D; dist[k] + mg.edge[k][i];                path[i] &#x3D; &quot;&quot;; &#x2F;&#x2F; 重置路径                path[i] +&#x3D; path[k]; &#x2F;&#x2F; 加上之前走过的路                path[i] +&#x3D; vertex[i];            &#125;        &#125;        cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; dist[k] &lt;&lt; &quot;;\n&quot;;        dist[k] &#x3D; 0;    &#125;&#125;</code></pre><h5 id="测试用例及邻接矩阵-1"><a href="#测试用例及邻接矩阵-1" class="headerlink" title="测试用例及邻接矩阵"></a>测试用例及邻接矩阵</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0 1100 3300 41001 2502 4103 2203 460</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0   1   2   3   40          1&#39; 10                 &#39;2&#39;     50      20     &#39;3&#39; 30                 &#39;4&#39; 100     10  60     &#39;&#x2F;&#x2F; 横轴为x，竖轴为y       </code></pre><h5 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;struct MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);     void Dijkstra(MGraph&lt;DataType&gt;, int);        private:     DataType vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, w &#x3D; 0;    vertexNum &#x3D; n, edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                edge[i][j] &#x3D; 0;            else                edge[i][j] &#x3D; 100;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cout &lt;&lt; &quot;input two vertexes of the edge: &quot;;        cin &gt;&gt; i &gt;&gt; j;        cout &lt;&lt; &quot;input the weight of the edge: &quot;;        cin &gt;&gt; w;        edge[i][j] &#x3D; w;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        if (edge[v][i] &lt; 100 &amp;&amp; visited[i] &#x3D;&#x3D; 0)            DFS(i);    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int queue[maxSize];    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &lt; 100 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Dijkstra(MGraph&lt;DataType&gt; mg, int v) &#123;    int distance[maxSize];    string path[maxSize];    string vertex(mg.vertex);    for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;        distance[i] &#x3D; mg.edge[v][i];        if (dist[i] !&#x3D; 100) &#123;            path[i] +&#x3D; vertex[v];            path[i] +&#x3D; vertex[i];        &#125; else &#123;            path[i] &#x3D; &quot;&quot;;        &#125;    &#125;    distance[v] &#x3D; 0;    int num &#x3D; 1;    while (num &lt; mg.vertexNum) &#123;        int min &#x3D; 100, k &#x3D; 0;        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (distance[i] !&#x3D; 0 &amp;&amp; distance[i] &lt; min) &#123;                min &#x3D; distance[i];                k &#x3D; i;            &#125;        &#125;        num++;        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (distance[i] &gt; distance[k] + mg.edge[v][i]) &#123;                distance[i] &#x3D; distance[i] + mg.edge[k][i];                path[i] &#x3D; &quot;&quot;;                path[i] +&#x3D; path[k];                path[i] +&#x3D; vertex[i];            &#125;        &#125;        cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; distance[k] &lt;&lt; &quot;;\n&quot;;        distance[k] &#x3D; 0;    &#125;&#125;int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;&#125;;    MGraph&lt;char&gt; mg(ch, 5, 7);    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS: &quot;;    mg.DFS(0);    cout &lt;&lt; endl;    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;BFS: &quot;;    mg.BFS(0);    cout &lt;&lt; &quot;the short path: \n&quot;;    mg.Dijkstra(mg, 0);&#125;</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/zgsdlr/article/details/121426826">【数据结构】最小生成树Prim算法_zgsdlr的博客-CSDN博客_ java求最小生成树</a></p>]]></content>
    
    
    <summary type="html">填坑系列之图，整理了数据结构无向图、最小生成树(Prim和Dijkstra)</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--哈夫曼树与哈夫曼编码</title>
    <link href="https://jaydenchang.top/post/0x0028.html"/>
    <id>https://jaydenchang.top/post/0x0028.html</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-12-11T10:14:34.545Z</updated>
    
    <content type="html"><![CDATA[<p>填坑系列之哈夫曼树</p><p>刚开始看哈夫曼树时有点懵懵的，加权是啥子玩意，后面查阅资料后才明白，哈夫曼树以及哈夫曼编码多用在压缩编码中，再配合二倍速食用B站大学的网课，算是把整个算法过了一遍</p><h4 id="the-main-structure"><a href="#the-main-structure" class="headerlink" title="the main structure"></a>the main structure</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int Max &#x3D; 1000;char **HuffmanCode;typedef struct Node &#123;    int weight;    int parent, left, right;&#125; HTNode, *HuffmanTree;</code></pre><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><p>select是来选择剩余结点中权值最小的两颗二叉树(包括新构造的树)的左右子树来构建一个新的二叉树，新根节点权值为其左右子树根节点的权值之和</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Select(HuffmanTree ht, int k, int&amp; id1, int&amp; id2) &#123;    long min1, min2;    min1 &#x3D; min2 &#x3D; 99999; &#x2F;&#x2F; 不能太小    for (int i &#x3D; 0;i &lt; k;i++) &#123;        if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min1 &gt; ht[i].weight) &#123;            &#x2F;&#x2F; 选择无双亲的结点            if (min1 &lt; min2) &#123;                 &#x2F;&#x2F; 这里是比大小的操作，规定min1为小                min2 &#x3D; min1;                id2 &#x3D; id1;            &#125;            min1 &#x3D; ht[i].weight; &#x2F;&#x2F; 这个操作可以把这k个数据都遍历一遍，可以选出两个最小的结点            id1 &#x3D; i;        &#125; else if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min2 &gt; ht[i].weight) &#123;            min2 &#x3D; ht[i].weight;            id2 &#x3D; i;        &#125;    &#125;&#125;</code></pre><h4 id="Create-a-Huffman-Tree"><a href="#Create-a-Huffman-Tree" class="headerlink" title="Create a Huffman Tree"></a>Create a Huffman Tree</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HuffmanTree(huffTree &amp;ht, int n) &#123;    int m &#x3D; n * 2 - 1;    int id1, id2;    int i;    if (n &lt; 0) &#x2F;&#x2F; 创建空树        return;    ht &#x3D; new Node[m];    for (i &#x3D; 0;i &lt; m;i++) &#123;        ht[i].parent &#x3D; ht[i].left &#x3D; ht[i].right &#x3D; -1;        &#x2F;&#x2F; 初始化各节点    &#125;    for (i &#x3D; 0;i &lt; n;i++) &#123;        cin &gt;&gt; ht[i].weight; &#x2F;&#x2F; 输入各个结点的权值    &#125;    for (i &#x3D; n;i &lt; m;i++) &#123;        Select(ht, i, id1, id2);        &#x2F;&#x2F; 在n个结点中选择俩无双亲的结点且权值最小的结点        ht[id1].parent &#x3D; ht[id2].parent &#x3D; i;        &#x2F;&#x2F; 获得id1，id2，把第i个结点设为它俩的双亲        ht[i].left &#x3D; id1;        ht[i].right &#x3D; id2; &#x2F;&#x2F; 设第i个结点的左右孩子为id1，id2        ht[i].weight &#x3D; ht[id1].weight + ht[id2].weight;    &#125;&#125;</code></pre><h4 id="destroy-a-Huffman-Tree"><a href="#destroy-a-Huffman-Tree" class="headerlink" title="destroy a Huffman Tree"></a>destroy a Huffman Tree</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Destroy(HuffmanTree &amp;ht) &#123;    delete[] ht;    ht &#x3D; NULL;&#125;</code></pre><h4 id="create-the-Huffman-Code"><a href="#create-the-Huffman-Code" class="headerlink" title="create the Huffman Code"></a>create the Huffman Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void createHuffmanCode(HuffmanTree ht, HuffmanCode &amp;hc, int n) &#123;    int start;    int cur, f;    hc &#x3D; new char *[n + 1];    char *cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (i &#x3D; 0;i &lt; n;i++) &#123;        start &#x3D; n - 1;         cur &#x3D; i; &#x2F;&#x2F; 当前结点在数组中的位置        f &#x3D; hf[i].parent; &#x2F;&#x2F; 当前结点的父节点在数组的位置        while (f !&#x3D; 0) &#123;            &#x2F;&#x2F; 如果该结点是父节点的左孩子则对应编码为0，否则右孩子为1            start--;            if (hf[f].left &#x3D;&#x3D; cur)                cd[start] &#x3D; &#39;0&#39;;            else                 cd[start] &#x3D; &#39;1&#39;;            &#x2F;&#x2F; 以父节点为孩子结点，继续朝树根的方向遍历            cur &#x3D; f;            f &#x3D; hf[f].parent;        &#125;        &#x2F;&#x2F; 跳出循环后，cd数组中从下标start开始，存放的就是该结点的哈夫曼编码        hc[i] &#x3D; new char[n - start];        strcpy(hc[i], &amp;cd[start]);    &#125;    delete cd;&#125;</code></pre><h4 id="the-code"><a href="#the-code" class="headerlink" title="the code"></a>the code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int Max &#x3D; 9999;typedef char **HuffmanCode;typedef struct Node &#123;    int weight;    int parent, left, right;&#125; HTNode, *HuffmanTree;void Select(HuffmanTree ht, int k, int id1, int id2) &#123;    int min1 &#x3D; min2 &#x3D; 9999;for (int i &#x3D; 0;i &lt; k;i++) &#123;        if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min1 &lt; ht[i].weight) &#123;            if (min1 &lt; min2) &#123;                min2 &#x3D; min1;                id2 &#x3D; id1;            &#125;            id1 &#x3D; i;            min1 &#x3D; ht[i].weight;        &#125; else if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min2 &gt; ht[i].weight) &#123;            min2 &#x3D; ht[i].weight;            id2 &#x3D; i;        &#125;    &#125;&#125;void createHuffmanTree(HuffmanTree ht, int n) &#123;    int id1, id2;    if (n &lt;&#x3D; 0)         return;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        ht[i].left &#x3D; ht[i].right &#x3D; ht[i].parent &#x3D; 0;    &#125;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        cin &gt;&gt; ht[i].weight;    &#125;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        Select(ht, i, id1, id2);        ht[id1].parent &#x3D; ht[id2].parent &#x3D; i;        ht[i].left &#x3D; id1;        ht[i].right &#x3D; id2;        ht[weight] &#x3D; ht[id1].weight + ht[id2].weight;    &#125;&#125;void createHuffmanTreeCode(HuffmanTree ht, HuffmanCode &amp;hc, int n) &#123;    int start, cur f;    hc &#x3D; new char*[n + 1];    char* cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        start &#x3D; n - 1;        cur &#x3D; i;        f &#x3D; ht[i].parent;        while (f !&#x3D; 0) &#123;            start--;            if (ht[f].left &#x3D;&#x3D; cur) &#123;                cd[start] &#x3D; &#39;0&#39;;            &#125; else &#123;                cd[start] &#x3D; &#39;1&#39;;            &#125;            cur &#x3D; f;            f &#x3D; ht[i].parent;        &#125;        hc[i] &#x3D; cd[n - start];        strcpy(hc[i], &amp;cd[start]);    &#125;    delete cd;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    HuffmanTree ht;    HuffmanCode hc;    int sum &#x3D; 0;    HuffmanTree(ht, n);    createHuffmanCode(ht, hc, n);    for (int i &#x3D; 0;i &lt; 2 * n - 1;i++) &#123;        cout &lt;&lt; ht[i].weight &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 测试，输出所有结点，包括非原有结点    &#125;    cout &lt;&lt; endl;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        cout &lt;&lt; hc[i] &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 输出每个结点的HuffmanCode    &#125;&#125;</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/linfangnan/p/12593480.html">数据结构：哈夫曼树与哈夫曼编码 - 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV18t411U7Tb">数据结构与算法基础–第09周04–5.7哈夫曼树及其应用4-5.7.2哈夫曼树的构造算法2-哈夫曼树算法实现_哔哩哔哩_bilibili</a>(共6p)</p>]]></content>
    
    
    <summary type="html">填坑系列之哈夫曼树，整理了哈夫曼树和哈夫曼编码</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--简单二叉树(无序)</title>
    <link href="https://jaydenchang.top/post/0x0027.html"/>
    <id>https://jaydenchang.top/post/0x0027.html</id>
    <published>2021-11-15T16:00:00.000Z</published>
    <updated>2021-12-11T05:45:42.062Z</updated>
    
    <content type="html"><![CDATA[<p>本次来简单总结下简单二叉树(无序)，前面欠的债有点多，最近在疯狂追赶课程进度，简单记录下自己对简单二叉树的一些理解</p><h4 id="binary-tree"><a href="#binary-tree" class="headerlink" title="binary tree"></a>binary tree</h4><h5 id="the-main-structure"><a href="#the-main-structure" class="headerlink" title="the main structure"></a>the main structure</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int Max &#x3D; 100;template &lt;class DataType&gt;struct BiNode &#123;    DataType data;    BiNode *leftChild, *rightChild;    &#125;;template &lt;class DataType&gt;class BiTree &#123;    public:     BiTree() &#123; root &#x3D; Create(); &#125;     ~BiTree() &#123; Release(root); &#125;     void PreOrder() &#123; PreOrder(root); &#125;     void InOrder() &#123; InOrder(root); &#125;     void LevelOrder();     int leafNum(BiNode*);     BiNode* getRoot() &#123; return root; &#125;        private:     BiNode* root;     BiNode* Create();     void Release(BiNode* bt);     void PreOrder(BiNode* bt);     void InOrder(BiNode* bt);     void PostOrder(BiNode* bt);&#125;;</code></pre><h5 id="Create"><a href="#Create" class="headerlink" title="Create()"></a>Create()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;BiTree::BiTree() &#123;    BiNode* bt;    DataType ch;    cout &lt;&lt; &quot;enter a binary node: &quot;;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        return NULL;    &#125; else &#123;        bt &#x3D; new BiNode;        bt-&gt;data &#x3D; ch;        bt-&gt;leftChild &#x3D; Create();        bt-&gt;rightchild &#x3D; Create();        &#x2F;&#x2F; 不断套娃递归    &#125;&#125;</code></pre><h5 id="Release"><a href="#Release" class="headerlink" title="Release()"></a>Release()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;BiTree::Release(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        Release(bt-&gt;leftChild);        Release(bt-&gt;rightChild);        delete bt;    &#125;&#125;</code></pre><h5 id="PreOrder"><a href="#PreOrder" class="headerlink" title="PreOrder"></a>PreOrder</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::PreOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        PreOrder(bt-&gt;leftChild);        PreOrder(bt-&gt;rightChild);    &#125;&#125;</code></pre><h5 id="InOrder"><a href="#InOrder" class="headerlink" title="InOrder()"></a>InOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::InOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        InOrder(bt-&gt;leftChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        InOrder(bt-&gt;rightChild);    &#125;&#125;</code></pre><h5 id="PostOrder"><a href="#PostOrder" class="headerlink" title="PostOrder()"></a>PostOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::PostOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        PostOrder(bt-&gt;leftChild);        PostOrder(bt-&gt;rightChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;    &#125;&#125;</code></pre><h5 id="LevelOrder"><a href="#LevelOrder" class="headerlink" title="LevelOrder()"></a>LevelOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::LevelOrder() &#123;    BiNode *queue[Max], *ptr &#x3D; NULL;    int front &#x3D; -1, rear &#x3D; -1;    if (root &#x3D;&#x3D; NULL)         return;        queue[++rear] &#x3D; root; &#x2F;&#x2F; 根节点入队    while (front !&#x3D; rear) &#123;        ptr &#x3D; queue[++front]; &#x2F;&#x2F; 把根节点赋给临时指针ptr        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 输出当前结点的内容               if (ptr-&gt;leftChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;leftChild;        if (ptr-&gt;rightChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;rightChild;        &#x2F;&#x2F; 这里依次遍历左右左右孩子节点并添加入列    &#125;&#125;</code></pre><h5 id="leafNum"><a href="#leafNum" class="headerlink" title="leafNum()"></a>leafNum()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;int BiTree::leafNum(BiNode* bt)&#123;    if (bt &#x3D;&#x3D; NULL)        return 0;    if (bt-&gt;leftChild &#x3D;&#x3D; NULL &amp;&amp; bt-&gt;rightChild &#x3D;&#x3D; NULL)         return 1;    int left &#x3D; leafNum(bt-&gt;leftChild);    int right &#x3D; leafNum(bt-&gt;rightChild);    return left + right;&#125;</code></pre><h5 id="Complete-code"><a href="#Complete-code" class="headerlink" title="Complete code"></a>Complete code</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int Max &#x3D; 100;template &lt;class DataType&gt;struct BiNode &#123;    DataType data;    BiNode *leftChild, *rightChild;&#125;;template &lt;class DataType&gt;class BiTree &#123;    public:     BiTree() &#123; root &#x3D; Create(); &#125;     ~BiTree() &#123;Release(root); &#125;     void PreOrder() &#123; PreOrder(root); &#125;     void InOrder() &#123; InOrder(root); &#125;     void PostOrder() &#123; PostOrder(root); &#125;     void LevelOrder();     int leafNum(BiNode*);     BiNode* getRoot() &#123; return root; &#125;        private:     BiNode* root;     BiNode* Create();     void Release(BiNode*);     void PreOrder(BiNode*);     void InOrder(BiNode*);     void PostOrder(BiNode*);&#125;;template &lt;class DataType&gt;BiNode* BiTree::Create() &#123;    BiNode* bt;    DataType ch;    cout &lt;&lt; &quot;enter a node data: &quot;;    cin &gt;&gt; ch;    if (ch !&#x3D; &#39;#&#39;) &#123;        bt-&gt;data &#x3D; ch;        bt-&gt;leftChild &#x3D; Create();        bt-&gt;rightChild &#x3D; Create();        return bt;    &#125;&#125;template &lt;class DataType&gt;void BiTree::Release(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        Release(bt-&gt;leftChild);        Release(bt-&gt;rightChild);        delete bt;    &#125;&#125;template &lt;class DataType&gt;void BiTree::PreOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        PreOrder(bt-&gt;leftChild);        PreOrder(bt-&gt;rightChild);    &#125;&#125;template &lt;class DataType&gt;void BiTree::InOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        InOrder(bt-&gt;leftChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        InOrder(bt-&gt;rightChild);    &#125;&#125;template &lt;class DataType&gt;void BiTree::PostOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        PostOrder(bt-&gt;leftChild);        PostOrder(bt-&gt;rightChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;    &#125;&#125;template &lt;class DataType&gt;void BiTree::LevelOrder() &#123;    BiNode* queue[Max], ptr &#x3D; NULL;    int front &#x3D; -1, rear &#x3D; -1;    if (root &#x3D;&#x3D; NULL)        return;queue[++rear] &#x3D; root;    while (front !&#x3D; rear) &#123;        ptr &#x3D; queue[++front];        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;;        if (ptr-&gt;leftChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;leftChild;        if (ptr-&gt;rightChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;rightChild;    &#125;&#125;template &lt;class DataType&gt;int BiTree::leafNum(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL)        return 0;    if (bt-&gt;leftChild &#x3D;&#x3D; NULL &amp;&amp; bt-&gt;rightChild &#x3D;&#x3D; NULL)        return 1;    int left &#x3D; leafNum(bt-&gt;leftChild);    int right &#x3D; leafNum(bt-&gt;rightChild);    return left + right;    &#125;int main() &#123;    BiTree tree;    cout &lt;&lt; &quot;---PreOrder---\n&quot;;    tree.PreOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---InOrder---\n&quot;;    tree.InOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---PostOrder---\n&quot;;    tree.PostOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---LevelOrder---\n&quot;;    tree.LevelOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;the num of the leaves: &quot;;    cout &lt;&lt; tree.leafNum(tree.getRoot());&#125;</code></pre>]]></content>
    
    
    <summary type="html">整理了简单二叉树的简单应用，包括前中后遍历，求树的深度、叶子节点个数</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>kmp</title>
    <link href="https://jaydenchang.top/post/0x0026.html"/>
    <id>https://jaydenchang.top/post/0x0026.html</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2021-12-11T05:50:30.777Z</updated>
    
    <content type="html"><![CDATA[<p>注：本篇文章只记录我理解的过程、需要注意的小细节，不涉及具体讲解，一些具体的原理、推导步骤可参考文末我列出的文章和视频</p><p>说到字符串匹配，以前的我，对时间、空间复杂度没有什么概念，估计写出来的代码长这样</p><h3 id="BF-brute-force"><a href="#BF-brute-force" class="headerlink" title="BF(brute-force)"></a>BF(brute-force)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int BF(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0; j &#x3D; 0;    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        if (s[i] &#x3D;&#x3D; p[j]) &#123;            i++, j++;            &#x2F;&#x2F; 匹配成功就指针都后移        &#125; else &#123;            i &#x3D; i - j + 1;            j &#x3D; 0;        &#125;    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else         return -1;&#125;</code></pre><p>查阅资料后发现，这￥%&amp;#时间复杂度还挺高，假设文本串长m，模式串长n，时间复杂度是<code>O(m*n)</code>，如果m和n都很大的话，效率会低到无法想象</p><h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><p>这时候，引入一个新算法，kmp，反正就是三个大佬的名字首字母拼在一起</p><p>要理解kmp，首先要理解kmp中的next数组，next数组，说人话，就类似一个索引。kmp的本质就是利用模式串的最长公共前后缀来缩短查找时间</p><p>如果字符失配，模式串向后移动<code>j-next[j]</code>位，这样说还不是很好理解，看一个例子</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td><u><strong>d</strong></u></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>这里在第七位失配，在d前面，有最长公共前后缀”ab”，长度为2，按照刚才说的，模式串向后移动<code>j-next[j]</code>位，即<code>6-next[6]</code>，其中<code>next[6] = 2</code>，变成如下</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td><u><strong>c</strong></u></td><td>d</td><td>a</td><td>b</td><td>d</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>c失配，c前无最长公共前后缀，向后移动<code>2-next[2]</code>，也就是2位</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td><u><strong>d</strong></u></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在d处又失配，再次移动<code>6-next[6]</code>也就是4位</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td>d</td><td></td></tr></tbody></table><p>匹配成功ヾ(≧▽≦*)o</p><p>以上就是kmp算法的基本实现流程</p><h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><h5 id="next数组的二三事"><a href="#next数组的二三事" class="headerlink" title="next数组的二三事"></a>next数组的二三事</h5><p>next数组的实质是：在当前字符前，最长公共前后缀的字符数</p><p>先拿出一个模式串：<code>abcabzan</code></p><p>对于next，有些版本默认第0位是-1，有的是0，这里默认第0位是-1.</p><ul><li>对于第一位是a，前面没有字符，赋值-1</li><li>第二位b前面只有一个字符，没有相同子串，赋值0</li><li>第三位前面两个字符没有同，赋值0</li><li>第四位前面也无，同上</li><li>第五位前面有相同前后缀元素，即a，赋值1</li><li>第六位前面，继续找，发现有更长的前后缀公共元素，是ab，两个字符，赋值2</li><li>第七位无，第八位前有一个a，赋值1，后面无公共元素</li><li>最后一位其实可以不用管的，都匹配到了，说明匹配成功了[doge]</li></ul><p>最后把next数组的值罗列一下</p><p><code>-1 0 0 0 1 2 0 1 </code></p><p>然后就得到了next数组</p><h5 id="next数组代码实现"><a href="#next数组代码实现" class="headerlink" title="next数组代码实现"></a>next数组代码实现</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void makeNext(string p, int next[]) &#123;    int j &#x3D; 0, k &#x3D; -1;    int len &#x3D; p.length();    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            &#x2F;&#x2F; 这里判断是否从首位开始匹配，或者模式串前后是否匹配成功            j++, k++;            next[j] &#x3D; k;            &#x2F;&#x2F; 匹配成功就把当前匹配的字符数赋给当前next[j]            &#x2F;&#x2F; 即模式串第j位前有k个最长前后缀公共元素        &#125; else &#123;            k &#x3D; next[k];            &#x2F;&#x2F; 把当前next[k]赋给k，也就相当于整个模式串向后移动next[k]位        &#125;    &#125;&#125;</code></pre><h5 id="next数组的优化"><a href="#next数组的优化" class="headerlink" title="next数组的优化"></a>next数组的优化</h5><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>a</td><td>b</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>对于模式串<code>&quot;abab&quot;</code>，它的next数组为<code>-1 0 0 1</code></p><p>当c与b失配时，模式串向后移动<code>3-next[3] = 2</code>，变成如下</p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td></td><td></td><td>a</td><td><u><strong>b</strong></u></td><td>a</td><td>b</td><td></td><td></td><td></td></tr></tbody></table><p>看到上面这里，原来<code>p[j]</code>和<code>s[j]</code>失配，右移之后，变成<code>s[j]</code>和<code>p[next[j]]</code>(即前后缀相同字符)匹配，然后呢，又失配了，虽然说在这组字符串里最后都能匹配成功，但是移动后，按照道理，失配位前面的字符在移动之后都能匹配成功，如果一直出现这样的情况的话，那么匹配的效率就会下降。</p><p>那么怎么修改？答案是，<strong>不能容许<code>p[j]=p[next[j]]</code></strong>。如果出现刚才叙述的情况，则需递归，令<code>next[j] = next[next[j]]</code></p><p>那么这个递归又是怎么个回事呢？(看了好久才懂)</p><p>随便举一个字符串<code>ababc</code></p><p>下标从0开始，到c这个位置，也就是第4位，下标为1的字符b和下标为3的字符b是等价的，在递归之后，next数组更新，可避免出现刚才那样的bug，后移之后在前面的子串部分失配(按照道理，公共前后缀部分是不会失配的)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void makeNext(string p, int next[]) &#123;    int len &#x3D; p.length();    int k &#x3D; -1, j &#x3D; 0;    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            j++, k++;            if (p[j] !&#x3D; p[k])                 next[j] &#x3D; k;            &#x2F;&#x2F; 如果匹配失败就把匹配数赋给next[j]            else                 next[j] &#x3D; next[k];            &#x2F;&#x2F; 不能出现p[j] &#x3D; p[next[j]]的情况，需要继续递归        &#125; else &#123;            k &#x3D; next[k];            &#x2F;&#x2F; 把k复位(分匹配是否成功两种情况)        &#125;    &#125;&#125;</code></pre><p>优化过后的数组</p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>-1</td><td>0</td><td>-1</td><td>0</td></tr></tbody></table><p>单单只看优化过后的代码，感觉还是有点恍惚，还是要结合kmp的主干部分来看</p><h4 id="kmp-1"><a href="#kmp-1" class="headerlink" title="kmp"></a>kmp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int kmp(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0, j &#x3D; 0;    int *next &#x3D; new int[len2];    makeNext(p, next);    while (j &#x3D;&#x3D; -1 || i &lt; len1 &amp;&amp; j &lt; len2) &#123;        &#x2F;&#x2F; j为-1 or 匹配成功才指针后移        if(s[i] &#x3D;&#x3D; p[j])             i++, j++;        &#x2F;&#x2F; 匹配就指针后移        else             j &#x3D; next[j];                &#x2F;&#x2F; 不匹配就根据之前求出的next来决定模式串从哪开始匹配    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else        return 0;&#125;</code></pre><p>优化过后继续结合刚才优化前出现bug的那个数组</p><p>优化后next：<code>-1 0 -1 0</code></p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>a</td><td><u><strong>b</strong></u></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第四位失配，后移<code>3-next[3]</code>，递归后<code>next[3] = 0</code>，后移了3位</p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>a</td><td>b</td><td>a</td><td>b</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td><td></td></tr></tbody></table><p>c和a失配，再后移</p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>a</td><td>b</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td></tr></tbody></table><p>匹配成功</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;void makeNext(string p, int next[]);int kmp(string s, string p);void makeNext(string p, int next[]) &#123;    int len &#x3D; p.length();    int j &#x3D; 0, k &#x3D; -1;    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            j++, k++;            if (p[j] !&#x3D; p[k])                next[j] &#x3D; next[k];            else                k &#x3D; next[j];        &#125;     &#125;&#125;int kmp(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0, j &#x3D; 0;    int *next &#x3D; new int[len2];    makeNext(p, next);    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        if (j &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; p[j])            i++, j++;        else            j &#x3D; next[j];    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else         return 0;&#125;int main() &#123;    string s, p;    cin &gt;&gt; s &gt;&gt; p;    if (kmp(s, p) &#x3D;&#x3D; 1)        cout &lt;&lt; &quot;found the key string\n&quot;;    else        cout &lt;&lt; &quot;not found the key string\n&quot;;&#125;</code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP（2014年8月22日版）_结构之法 算法之道-CSDN博客_kmp</a></p><p><a href="https://www.bilibili.com/video/BV1Ys411d7yh?from=search&seid=14595349758363193343&spm_id_from=333.337.0.0">【soso字幕】汪都能听懂的KMP字符串匹配算法【双语字幕】_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">填坑系列之kmp，本篇文章只记录我理解的过程、需要注意的小细节，不涉及具体讲解，一些具体的原理、推导步骤可参考文末我列出的文章和视频</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--不设头指针的循环链队列</title>
    <link href="https://jaydenchang.top/post/0x0025.html"/>
    <id>https://jaydenchang.top/post/0x0025.html</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2021-12-11T05:52:19.369Z</updated>
    
    <content type="html"><![CDATA[<p>本次数据结构的作业是设计一个只有尾指针的循环链队列，要求实现构造(有参 &amp;&amp; 无参)、析构、出入列、获取头结点等功能。在完成过程中踩了很多坑(特别是在实现析构时qwq)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;struct Node &#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template &lt;class DataType&gt;class LinkQueue &#123;    public:     LinkQueue();     LinkQueue(int [], int);     ~LinkQueue();     void EnQueue(DataType x);     DataType DeQueue();     DataType GetQueue();        private:     Node&lt;DataType&gt;* rear;&#125;;</code></pre><h4 id="有参构造-amp-amp-无参构造"><a href="#有参构造-amp-amp-无参构造" class="headerlink" title="有参构造&amp;&amp;无参构造"></a>有参构造&amp;&amp;无参构造</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue(int arr[], int n) &#123;    rear &#x3D; new Node&lt;DataType&gt;;    Node&lt;DataType&gt;* p &#x3D; rear;    &#x2F;&#x2F;储存首地址，最后把尾巴连上for(int i &#x3D; 0; i &lt; n; i++) &#123;        rear-&gt;next &#x3D; new Node&lt;DataType&gt;;        rear &#x3D; rear-&gt;next;        rear-&gt;data &#x3D; arr[i];    &#125;    rear-&gt;next &#x3D; p;    &#x2F;&#x2F; 把尾巴连到首部&#125;template &lt;class DataType&gt;LinkQueue&lt;DataTpye&gt;::LinkQueue() &#123;    rear &#x3D; NULL;&#125;</code></pre><h4 id="进队-amp-amp-出队"><a href="#进队-amp-amp-出队" class="headerlink" title="进队 &amp;&amp; 出队"></a>进队 &amp;&amp; 出队</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void LinkQueue&lt;DataType&gt;::EnQueue(DataType x) &#123;    Node&lt;DataType&gt;* p &#x3D; new Node&lt;DataType&gt;;        p-&gt;data &#x3D; x;    if (rear &#x3D;&#x3D; NULL) &#123;        rear &#x3D; p;        rear-&gt;next &#x3D; p;    &#125; else &#123;        p-&gt;next &#x3D; rear-&gt;next;  &#x2F;&#x2F; 新建节点连接头指针        rear-&gt;next &#x3D; p; &#x2F;&#x2F; 尾指针连接新节点        rear &#x3D; p; &#x2F;&#x2F; 尾指针后移    &#125;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::DeQueue() &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    DataType x;    if (rear &#x3D;&#x3D; NULL)         throw &quot;dive dowm&quot;;    p &#x3D; rear-&gt;next;    x &#x3D; p-&gt;data;    if (rear &#x3D;&#x3D; p)        rear &#x3D; NULL;    else         rear-&gt;next &#x3D; p-&gt;next;    delete p;    return x;&#125;</code></pre><h4 id="获取头结点"><a href="#获取头结点" class="headerlink" title="获取头结点"></a>获取头结点</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::GetQueue() &#123;    if (rear !&#x3D; NULL)        return rear-&gt;next-&gt;data;    &#x2F;&#x2F; return rear-&gt;data;    &#x2F;&#x2F; 这里rear已经指向队末，按照上一行代码，返回的是队末元素    else        throw &quot;empty queue&quot;;&#125;</code></pre><h4 id="清空循环链队列-也可写成析构"><a href="#清空循环链队列-也可写成析构" class="headerlink" title="清空循环链队列(也可写成析构)"></a>清空循环链队列(也可写成析构)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::~LinkQueue() &#123;    Node&lt;DataType&gt;* p;    while (rear !&#x3D; NULL) &#123;        &#x2F;&#x2F; the wrong version:                &#x2F;&#x2F; p &#x3D; rear;        &#x2F;&#x2F; rear &#x3D; rear-&gt;next;        &#x2F;&#x2F; delete p;        p &#x3D; rear-&gt;next;        if (rear &#x3D;&#x3D; p) &#123;            delete rear;            break;        &#125; else             rear-&gt;next &#x3D; p-&gt;next;        delete p;    &#125;&#125;</code></pre><p>关于这个析构函数，我在网上找了很多个版本，很多代码都是写成注释里的那样，包括老师给的答案也是，有些编译器直接运行可能看不出什么问题，但是放在debug模式里，就会报错</p><img src='https://jaydenchang.gitee.io/images/images/0x0025-1.jpg' style="zoom:67%;" ><p>如上图，在这里我已将循环链队列所有元素delete，当我查看变量的值时，发现，没那么简单，rear指针不为null，它指向的data值也是不规则的，也就不难说明为什么跳不出第46行的while循环了</p><img src='https://jaydenchang.gitee.io/images/images/0x0025-2.jpg' style="zoom:67%;" ><p>跳不出循环后，继续delete，就会报错，虽然提示<code>unKnown signal</code>，实际上是队列为空，无法继续delete</p><p>那么怎么解决呢，我将出列函数改写，放到析构函数里，这样子在删除最后一个节点时就能跳出循环，结束析构</p><img src='https://jaydenchang.gitee.io/images/images/0x0025-3.JPG'><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template &lt;class DataType&gt;struct Node &#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template &lt;class DataType&gt;class LinkQueue &#123;   public:    LinkQueue();    LinkQueue(int[], int);    ~LinkQueue();    void EnQueue(DataType x);    DataType DeQueue();    DataType GetQueue();   private:    Node&lt;DataType&gt;* rear;&#125;;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue(int arr[], int n) &#123;    rear &#x3D; new Node&lt;DataType&gt;;    &#x2F;&#x2F; rear-&gt;data &#x3D; arr[0];    Node&lt;DataType&gt;* p &#x3D; rear;  &#x2F;&#x2F; 储存首地址，最后把尾巴连接到首部    for (int i &#x3D; 0; i &lt; n; i++) &#123;        rear-&gt;next &#x3D; new Node&lt;DataType&gt;;  &#x2F;&#x2F; 不断开辟空间        rear &#x3D; rear-&gt;next;                &#x2F;&#x2F; rear后移        rear-&gt;data &#x3D; arr[i];    &#125;    rear-&gt;next &#x3D; p;  &#x2F;&#x2F;把尾巴连到首部&#125;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue() &#123;    rear &#x3D; NULL;&#125;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::~LinkQueue() &#123;    Node&lt;DataType&gt;* p;    while (rear !&#x3D; NULL) &#123;                p &#x3D; rear-&gt;next;        if (rear &#x3D;&#x3D; p) &#123;            delete rear;            break;        &#125; else &#123;            rear-&gt;next &#x3D; p-&gt;next;        &#125;        delete p;    &#125;&#125;template &lt;class DataType&gt;void LinkQueue&lt;DataType&gt;::EnQueue(DataType x) &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    p &#x3D; new Node&lt;DataType&gt;;    p-&gt;data &#x3D; x;    if (rear &#x3D;&#x3D; NULL) &#123;        rear &#x3D; p;        rear-&gt;next &#x3D; p;    &#125; else &#123;        p-&gt;next &#x3D; rear-&gt;next;  &#x2F;&#x2F; 新建节点连接头指针        rear-&gt;next &#x3D; p;        &#x2F;&#x2F; 尾指针连接新节点        rear &#x3D; p;              &#x2F;&#x2F; 尾指针后移    &#125;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::DeQueue() &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    DataType x;    if (rear &#x3D;&#x3D; NULL)        throw &quot;dive down&quot;;    p &#x3D; rear-&gt;next;    x &#x3D; p-&gt;data;    if (rear &#x3D;&#x3D; p)        rear &#x3D; NULL;    else        rear-&gt;next &#x3D; p-&gt;next;    delete p;    return x;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::GetQueue() &#123;    if (rear !&#x3D; NULL)        return rear-&gt;next-&gt;data;    &#x2F;&#x2F; return rear-&gt;data;    &#x2F;&#x2F; 这里rear已指向队末，返回的是队末元素    else        throw &quot;empty queue&quot;;&#125;int main() &#123;    LinkQueue&lt;int&gt; Queue;    try &#123;        Queue.EnQueue(5);        Queue.EnQueue(10);        Queue.EnQueue(15);        &#x2F;&#x2F; Queue.EnQueue(20);    &#125; catch (char* wrong) &#123;        cout &lt;&lt; wrong &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;get head element&quot; &lt;&lt; endl;    cout &lt;&lt; Queue.GetQueue() &lt;&lt; endl;    try &#123;        Queue.DeQueue();    &#125; catch (char* wrong) &#123;        cout &lt;&lt; wrong &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;get head element&quot; &lt;&lt; endl;    cout &lt;&lt; Queue.GetQueue() &lt;&lt; endl;&#125;</code></pre>]]></content>
    
    
    <summary type="html">记录一次和作业答案bug的对抗过程</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--关于单链表小细节的一些补充</title>
    <link href="https://jaydenchang.top/post/0x0024.html"/>
    <id>https://jaydenchang.top/post/0x0024.html</id>
    <published>2021-10-04T16:00:00.000Z</published>
    <updated>2021-12-11T05:53:22.157Z</updated>
    
    <content type="html"><![CDATA[<p>以下是在做数据结构作业时遇到的一些bug<del>(老师给的答案不太行)</del></p><h4 id="无相应构造函数报错"><a href="#无相应构造函数报错" class="headerlink" title="无相应构造函数报错"></a>无相应构造函数报错</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int MaxSize &#x3D; 10;template &lt;class T&gt;class Seqlist &#123;    public:    Seqlist() &#123; length &#x3D; 0;&#125;    Seqlist(T [],int);    private:    int length;    T data[MaxSize];&#125;;    class B &#123;    public:    B(T);    B() &#123;&#125; &#x2F;&#x2F;这个默认的构造函数十分重要    private:    T data;&#125;;B::B(T n) &#123;    data &#x3D; n;&#125;template &lt;class T&gt;Seqlist&lt;T&gt;::Seqlist(T arr[], int n) &#123;    if (n &gt; MaxSize) throw &quot;invalid num&quot;;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        data[i] &#x3D; arr[i];    &#125;    length &#x3D; n;&#125;int main() &#123;    B b[3] &#x3D; &#123;B(10), B(20), B(30)&#125;;    Seqlist&lt;B&gt; list(b,3);&#125;</code></pre><p>在上面部分代码中，如果把有注释的那一行代码删去，则这部分代码不能正常运行，报错信息是</p><p><code>no matching function for call to &#39;B::B()&#39;[25, 35]</code></p><p>根据这个报错信息找到相应行数，居然在<code>int n</code>这里报错，我寻思着这关n什么事，后面查阅了资料，原因出在第34行的<code>B b[3]</code>这里，定义了一个B类型的数组，没有参数传入，而B类中无适配该成员的构造函数，于是编译器报错</p><p>解决方法是，加上相应的构造函数<code>B() &#123;&#125;</code></p><h4 id="线性链表的反转和复制功能"><a href="#线性链表的反转和复制功能" class="headerlink" title="线性链表的反转和复制功能"></a>线性链表的反转和复制功能</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;template &lt;class T&gt;struct Node &#123;    T data;    Node&lt;T&gt;* next;&#125;;template &lt;class T&gt;class LinkList &#123;    public:     LinkList(); &#x2F;&#x2F; create an empty list    LinkList(T[], int);    &#x2F;&#x2F;~LinkList();        void Reverse(Node&lt;T&gt;* head);    Node&lt;T&gt;* Copy(Node&lt;T&gt;* head);    Node&lt;T&gt;* first;&#125;template &lt;class T&gt;LinkList&lt;T&gt;::LinkList() &#123;    first &#x3D; new Node&lt;T&gt;;    first-&gt;next &#x3D; NULL;&#125;template &lt;class T&gt;LinkList&lt;T&gt;::LinkList(T arr[], int n) &#123;    first &#x3D; new Node&lt;T&gt;;    Node&lt;T&gt;* p &#x3D; first;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        Node&lt;T&gt;* s &#x3D; new Node&lt;T&gt;;        s-&gt;data &#x3D; arr[i];        p-&gt;next &#x3D; s;&#x2F;&#x2F;让first指向第一个节点        p &#x3D; s;&#x2F;&#x2F;虽说把s的地址赋给p，但是first的地址和p不一样，对p操作不会改变first        &#x2F;&#x2F;因此first永远指向链表第一个位置    &#125;    p-&gt;next &#x3D; NULL;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::Reverse(Node&lt;T&gt;* head) &#123;    Node&lt;T&gt;* pre, *cur;    cur &#x3D; head-&gt;next;    head-&gt;next &#x3D; NULL;    while (cur) &#123;        pre &#x3D; cur;&#x2F;&#x2F;让当前节点的上一节点移动到当前节点位置        cur &#x3D; cur-&gt;next;&#x2F;&#x2F;当前节点移动到下一个位置        pre-&gt;next &#x3D; head-&gt;next;&#x2F;&#x2F;这一操作就是让pre不断指向前一个节点        head-&gt;next &#x3D; pre;&#x2F;&#x2F;更新节点，让head的next指向pre    &#125;    &#x2F;&#x2F;在画图理解时，要让cur和pre同时向后移动    &#x2F;&#x2F;这一部分，建议自己在纸上画出若干个节点和用三个小部件(代表三个指针)模拟一边才能够真正地理解&#125;&#x2F;&#x2F;复盘时自己有个小细节没注意到，这里都是指针变量的赋值操作，这里的赋值只是赋予地址，给予者的值改变，接收者的值不会改变template &lt;class T&gt;Node&lt;T&gt;* LinkList&lt;T&gt;::Copy(Node&lt;T&gt;* head) &#123;    Node&lt;T&gt;* headB &#x3D; new Node&lt;T&gt;;    Node&lt;T&gt;* pb &#x3D; headB;    Node&lt;T&gt;* pa &#x3D; head-&gt;next;    while (pa !&#x3D; NULL) &#123;        Node&lt;T&gt;* temp &#x3D; new Node&lt;T&gt;;        temp-&gt;data &#x3D; pa-&gt;data;        temp-&gt;next &#x3D; NULL;&#x2F;&#x2F;这里用到了一个临时指针变量        pb-&gt;next &#x3D; temp;&#x2F;&#x2F;让pb连上temp        pb &#x3D; pb-&gt;next;        pa &#x3D; pa-&gt;next;        &#x2F;&#x2F;这里向后移动    &#125;    return headB;    &#x2F;&#x2F;注意这里返回的是headB，在调用时记得再加一个&quot;-&gt;next&quot;&#125;int main() &#123;    int arr[] &#x3D; &#123;1, 2, 3, 4, 5&#125;;    LinkList&lt;int&gt; list(arr,5);    cout &lt;&lt; &quot;the origin state: &quot; &lt;&lt; endl;    list.PrintList();        cout &lt;&lt; endl &lt;&lt; &quot;copy list a to list b\n&quot;;    Node&lt;int&gt;* ptr &#x3D; new Node&lt;int&gt;;    ptr &#x3D; list.copy(list.first)-&gt;next;    while (ptr !&#x3D; NULL) &#123;        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;;        ptr &#x3D; ptr-&gt;next;    &#125;        cout &lt;&lt; endl &lt;&lt; &quot;reverse the list a\n&quot;;    list.Reverse(list.first);    list.PrintList();&#125;</code></pre><h4 id="链表反转参考视频"><a href="#链表反转参考视频" class="headerlink" title="链表反转参考视频"></a>链表反转参考视频</h4><p><a href="https://www.bilibili.com/video/BV1KZ4y157Up?from=search&seid=15845376229805622503&spm_id_from=333.337.0.0">LeetCode力扣刷题 | 剑指Offer 24. 反转链表_哔哩哔哩_bilibili</a> [小姐姐声音很温柔doge]</p><p><a href="https://www.bilibili.com/video/BV1CW411N7mg?from=search&seid=15845376229805622503&spm_id_from=333.337.0.0">一分钟教你链表反转_哔哩哔哩_bilibili</a> [这个动画模拟比较贴合代码框的函数]</p><p>//谁知道我当时居然还去断点debug把每个节点以及他们的next的地址抄下来去对比</p>]]></content>
    
    
    <summary type="html">记录一次和老师给的答案的bug的对抗过程</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>旧手机改造成web服务器并实现内网穿透</title>
    <link href="https://jaydenchang.top/post/0x0023.html"/>
    <id>https://jaydenchang.top/post/0x0023.html</id>
    <published>2021-08-27T16:00:00.000Z</published>
    <updated>2021-12-11T05:53:51.507Z</updated>
    
    <content type="html"><![CDATA[<p>前几天由于gitee的审核引擎一通乱杀，使得gitee pages停止提供服务，心生更换服务器或者其他pages托管的想法，看了看价格感人的云服务器以及空空的钱包，这时，脑子有个奇怪的想法飘过，自己搞一个服务器，忽然想起来，我有一台root的旧手机，刚好拿来做测试</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>需要的工具：一台旧安卓手机(能获取root权限)，能联网的电脑，并装有Git</p><p>需要安装的软件：Linux Deploy，BusyBox，JuiceSSH (可选)，KSWEB (可选)</p><blockquote><p>JuiceSSH执行命令速度比电脑快，不过是手机操作，可能需要外接键盘</p><p>以下操作全在电脑端操作，不演示JuiceSSH与Linux Deploy的连接 (教程见文末第三个链接)</p></blockquote><p>需要的经验：部署过hexo博客，有一定git (或linux)基础，灵活运用关键字搜索，vim编辑器的使用语法</p><p><em>旧手机的基本信息</em></p><blockquote><ul><li>手机型号：Redmi 3</li><li>Android版本：5.1.1</li><li>Linux发行版：CentOS 7 (AltArch) [running via Linux Deploy]</li><li>RAM：2.0GiB</li><li>CPU：8核1.5GHz</li><li>储存空间：10GiB，可用4GiB</li></ul></blockquote><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-1.jpg' style="zoom: 25%;border-radius:2em" ><h3 id="配置Linux环境"><a href="#配置Linux环境" class="headerlink" title="配置Linux环境"></a>配置Linux环境</h3><p>首先打开BusyBox，点击安装 (需要root权限)</p><p>然后打开Linux Deploy，点击右下方的配置，设置系统相关信息，容器类型选chroot，发行版选CentOS，如果选其他发行版，架构一定要选对，不然会安装出错，或者无法使用，安装之前一定要知道手机CPU的架构；源地址建议切换为国内源，这里放上中科大的镜像源 <a href="http://mirrors.ustc.edu.cn/centos-altarch/">http://mirrors.ustc.edu.cn/centos-altarch/</a> ，国内还有其他源可选择，例如清华源，阿里源等</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-2.jpg' style="zoom: 25%;border-radius:2em" ><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-3.jpg' style="zoom: 25%;border-radius:2em" ><p>这里的设置很重要，一定要启用ssh，后面的步骤会用到 (SSH默认端口是22，此端口用于JuiceSSH连接)</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-4.jpg' style="zoom: 25%;border-radius:2em" ><p>然后返回主界面，点击左上，打开设置，建议前三个选项都勾上，往下滑，看到<code>PATH变量</code>，输入<code>/system/xbin</code>，再往下拉，把 调试模式 也勾上</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-5.jpg' style="zoom: 25%;border-radius:2em" ><p>再回到主界面，点击右上角，开始安装，大约要半小时</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-6.jpg' style="zoom: 25%;border-radius:2em" ><p>a few thousand years later……</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-7.jpg' style="zoom: 25%;border-radius:2em" ><p>看到手机输出<code>&lt;&lt;&lt;deploy</code>时说明安装完成，启动前先点击一次停止按钮，看见<code>&lt;&lt;&lt;stop</code>时再点击启动，看见输出如图内容时即成功启动。</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-8.jpg' style="zoom: 25%;border-radius:2em" ><p>然后打开KSWEB，查看当前手机的局域网ip，例如我手机的ip是192.168.101.10</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-9.jpg' style="zoom: 25%;border-radius:2em" ><p>然后打开电脑终端(cmd，git，wsl都可)，输入<code>ssh admin@192.168.101.10</code>，按照要求输入密码(前面的Linux Deploy配置里有密码的选项)，如下图所示即成功连接手机</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-10.jpg' style="zoom: 100%;border-radius:0.5em" ><h3 id="在服务器上部署"><a href="#在服务器上部署" class="headerlink" title="在服务器上部署"></a>在服务器上部署</h3><h4 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h4><p>在服务器端安装git和node.js</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y gitcurl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_12.x | bash -yum -y install nodejs</code></pre><p>:::tip</p><p>如果出现没做任何操作，下载自行终止并出现<code>Exiting on user cancel</code>，可尝试输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum clean metadatayum clean allyum upgrade</code></pre><p>如果出现<code>Failed to set locale, defaulting to C.UTF-8</code>，是没有正确设置语言环境或者没安装相关语言包导致的，可尝试用两种解决方法</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;export LC_ALL&#x3D;en_US.UTF-8&quot; &gt;&gt; &#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profile</code></pre><p>执行完后<strong>重新登陆</strong>再试安装，若还出现这个情况，安装相应语言包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install glibc-langpack-zh &#x2F;&#x2F;中文包&#x2F;&#x2F;英文包dnf install glibc-langpack-en 或dnf install langpacks-en glibc-all-langpacks -y</code></pre><p>:::</p><p>创建用户并配置其仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">useradd gitpasswd git &#x2F;&#x2F; 设置密码su git &#x2F;&#x2F; 这步很重要，不切换用户后面会很麻烦cd &#x2F;home&#x2F;git&#x2F;mkdir -p projects&#x2F;blog &#x2F;&#x2F; 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git &#x2F;&#x2F; 创建一个裸露的仓库cd blog.git&#x2F;hooksvi post-receive &#x2F;&#x2F; 创建 hook 钩子函数，输入了内容如下</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;home&#x2F;git&#x2F;projects&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git checkout -f</code></pre><p>添加完毕修改权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x post-receiveexit &#x2F;&#x2F; 退出到 root 登录chown -R git:git &#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git &#x2F;&#x2F; 添加权限</code></pre><p>测试<code>git仓库</code>是否可用，另找空白文件夹，在电脑端右键git bash here，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone git@server_ip:&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git</code></pre><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-11.jpg' style="zoom:50%;border-radius:0.7em" ><p>如果能clone空仓库，说明git仓库搭建成功</p><p>建立ssh信任关系，在电脑输入以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i C:&#x2F;Users&#x2F;yourname&#x2F;.ssh&#x2F;id_rsa.pub git@server_ip&#x2F;&#x2F;如果用户名有空格，路径用引号括起来ssh git@server_ip &#x2F;&#x2F; 测试能否登录</code></pre><p><strong>注：此时的 ssh 登录 git 用户不需要密码！否则就有错，请仔细重复步骤 3-5</strong></p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-12.jpg' style="zoom:50%;border-radius:0.7em" ><p>如图即成功添加信任</p><p>为了安全起见禁用 git 用户的 shell 登录权限，从而只能用 git clone，git push </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;etc&#x2F;shells &#x2F;&#x2F; 查看 git-shell 是否在登录方式里面which git-shell &#x2F;&#x2F; 查看是否安装vi &#x2F;etc&#x2F;shells添加上2步显示出来的路劲，通常在 &#x2F;usr&#x2F;bin&#x2F;git-shell</code></pre><p>修改<code>/etc/passwd</code>中的权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; 将原来的git:x:1000:1000::&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash&#x2F;&#x2F; 修改为git:x:1000:1000:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</code></pre><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-13.jpg' style="zoom:45%;" ><blockquote><p>需修改的内容一般在最后一行，数字不用改，只需添加半角逗号和改路径即可</p></blockquote><h4 id="搭建nginx服务器"><a href="#搭建nginx服务器" class="headerlink" title="搭建nginx服务器"></a>搭建nginx服务器</h4><p>下载并安装nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;srcwget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.15.2.tar.gztar xzvf nginx-1.15.2.tar.gzcd nginx-1.15.2&#x2F;&#x2F; 执行之前先检查是否有安装gcc gdb gcc-c++ make wget这五个软件，没有的话不能进行下一步，可直接用yum命令安装.&#x2F;configure &#x2F;&#x2F; 如果后面还想要配置 SSL 协议，就执行后面一句！.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_modulemake &amp;&amp; make installalias nginx&#x3D;&#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx&#39; &#x2F;&#x2F; 为 nginx 取别名，后面可直接用，重新登陆后失效</code></pre><p>配置nginx文件</p><p>先启动是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx &#x2F;&#x2F; 直接来！浏览器查看 server_ip，默认是 80 端口</code></pre><p>修改配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -s stop &#x2F;&#x2F; 先停止nginxcd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;confvi nginx.conf修改 root 解析路径，如下图同时将 user 改为 root 如下图，不然nginx无法访问 &#x2F;home&#x2F;git&#x2F;projects&#x2F;blognginx -s reload</code></pre><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-14.jpg' style="zoom:50%;border-radius:0.7em" ><blockquote><p>需要修改第一个箭头所指的nobody，第二个箭头所指的是会产生bug的文件</p></blockquote><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-15.jpg' style="zoom:50%;border-radius:0.7em" ><blockquote><p>需要修改root的路径为博客位置，例如我之前设置的位置是<code>/home/git/projects/blog</code>，就把这个路径替换进去，注意不要漏了句尾的分号</p></blockquote><p>:::tip</p><p>在修改配置文件这里目测有坑，会出现<code>/usr/local/nginx/logs/nginx.pid failed</code>这样的字眼，打开<code>/usr/local/nginx/logs</code>，输入<code>ls -al</code>，没看见有<code>nginx.pid</code>，我的解决方法是输入这个<br><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code>，再输入<code>ls -al</code>，发现<code>nginx.pid</code>出现了，再次运行<code>nginx -s reload</code>，没有报错。</p><p>:::</p><p>在这里，可以测试下部署在服务器的网页，不过只能实现局域网查。注意上图中有一个<code>listen  80</code>，这是一个设置在localhost的端口，可尝试在浏览器打开预览，不过建议换成其他端口，避免端口被占用无法预览，这里我换成800，可成功预览</p><p>:::warning</p><p>别忘了启动nginx，不然不能预览页面</p><p>:::</p><p>在手机浏览器输入<code>127.0.0.1:800</code>或<code>192.168.101.10:800</code>可以预览</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-19.jpg' style="zoom: 40%;border-radius:0.8em" ><p>在同一局域网的电脑输入<code>192.168.101.10:800</code>即可预览</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-20.jpg' style="zoom: 50%;border-radius:0.8em" ><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><h4 id="配置-config-yml文件"><a href="#配置-config-yml文件" class="headerlink" title="配置_config.yml文件"></a>配置<code>_config.yml</code>文件</h4><p>编辑deploy属性</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-17.jpg' style="zoom: 67%;border-radius:0.8em" ><blockquote><p>repo是推送到的目的地地址</p></blockquote><p>推送到服务器</p><p>使用<code>hexo d -g</code>或<code>hexo g- d</code>均可，如图即成功推送</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-18.jpg' style="zoom:67%;border-radius:0.7em" ><h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>内网穿透有很多工具，常见的有花生壳，FRP，ngork。由于花生壳的价格过于感人，FRP需要另一台有公网ip的服务器，这里使用基于ngork的<a href='natapp.cn'>natapp</a> </p><p>官网：<a href="https://natapp.cn/">https://natapp.cn</a> <del>(快来打钱doge)</del> </p><p>这里需要在Linux安装，安装方法用wget + Linux安装包，由于我不知道wget会保存到哪里，所以我在wget后加了一个指定路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget -P &#x2F;home&#x2F;git&#x2F; https:&#x2F;&#x2F;cdn.natapp.cn&#x2F;assets&#x2F;downloads&#x2F;clients&#x2F;2_3_9&#x2F;natapp_linux_arm64&#x2F;natapp?version&#x3D;20190730</code></pre><p>下载之后对安装包重命名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv natapp?version&#x3D;20190730 natapp</code></pre><p>在root下先给予执行权限再执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod a+x natapp.&#x2F;natapp</code></pre><p>直接运行<code>./natapp</code>还不能运行程序，这里需要加上创建的隧道的authtoken参数才能打开</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;natapp -authtoken&#x3D;&lt;your token&gt;</code></pre><p>运行程序后，图中的网址已穿透内网，可对外访问 (这是个临时链接)</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-21.jpg' style="zoom:50%;border-radius:0.8em" ><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-22.jpg' style="zoom:40%;border-radius:0.8em" ><p>到这里，一个web私人服务器就搭好了。</p><p>另外，关于穿透的网址，natapp有一个付费隧道可以绑定自定义域名，每个月9￥，而花生壳那边的价格比较感人 (还花了6￥开启https穿透的认证，发现没什么luan用，我*&amp;%@)，最终还是选择了natapp</p><p>不过，我还是选择GitHub Pages + Netlify 来配置我的网站，私人服务器跑网页，需要让服务器24h保持运作状态 (感觉也废不了什么电费)，毕竟通过隧道来访问网站的速度和直接托管在GitHub Pages差不多，干脆直接用GitHub Pages比较省事</p><p>除了网页服务器，旧手机理论上也可以建一个私人网盘 <del>(感觉也没时间整了)</del></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ii.do/24.html">旧手机搭建网站以及内网穿透 - Dark’s blog (ii.do)</a></p><p><a href="https://blog.csdn.net/qq_35561857/article/details/81590953">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器_jeffery5461的博客-CSDN博客_</a></p><p><a href="https://www.cnblogs.com/sw-code/p/14990229.html">使用Linux Deploy将闲置的安卓手机改造简易服务器 - sw-code - 博客园 (cnblogs.com)</a></p><p><a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程【持续更新】 - SegmentFault 思否</a></p><p>[<a href="https://blog.csdn.net/qq_41502780/article/details/104064975">解决nginx: [error] open() ＂/usr/local/nginx/logs/nginx.pid＂ failed错误_三也先生的博客-CSDN博客]</a></p><p><a href="https://developer.aliyun.com/article/387493">centos 7 升级后yum install出现Exiting on user cancel-阿里云开发者社区 (aliyun.com)</a></p><p><a href="https://www.cnblogs.com/h2285409/p/14745010.html">Failed to set locale, defaulting to C.UTF-8 - 天军 - 博客园 (cnblogs.com)</a></p><p><a href="https://mx142.cn/2020/12/22/11/">把hexo博客部署到服务器 | MX (mx142.cn)</a></p>]]></content>
    
    
    <summary type="html">我用半个月做了一个&quot;服务器&quot;</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="整活" scheme="https://jaydenchang.top/tags/%E6%95%B4%E6%B4%BB/"/>
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>迁移博客</title>
    <link href="https://jaydenchang.top/post/0x0022.html"/>
    <id>https://jaydenchang.top/post/0x0022.html</id>
    <published>2021-08-19T16:00:00.000Z</published>
    <updated>2021-12-11T05:54:15.728Z</updated>
    
    <content type="html"><![CDATA[<p>本站点已由<a href='https://jaydenchang.gitee.io'>旧站点</a>迁往<a href='https://jaydenchang.top'>jaydenchang.top</a>，旧站点已废弃</p><p>前几天准备更博客时，发现gitee的站点被ban了，了解到我的站点有违规内容 <del>(一脸懵逼)</del>，具体就不吐槽了，<strong>果然免费的是最贵的</strong>。后来心里冒出个想法，迁博客到别的服务器，gitee就当作图床了doge。</p><p>最终还是选择了GitHub pages，云服务器太贵了，自己搭的服务器内网穿透效果一般般<del>(先挖个坑)</del></p>]]></content>
    
    
    <summary type="html">记录一次站点迁移</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>为博客添加评论邮件提醒功能(踩坑全过程)</title>
    <link href="https://jaydenchang.top/post/0x0021.html"/>
    <id>https://jaydenchang.top/post/0x0021.html</id>
    <published>2021-08-15T16:00:00.000Z</published>
    <updated>2021-12-11T05:55:03.852Z</updated>
    
    <content type="html"><![CDATA[<p>在很早之前，我就想过要给博客加一个邮件评论提醒功能，上个月折腾了三天愣是没折腾出什么，这几天学不进去，刚好来折腾这个。</p><p>因为懒，需要加载到图床的图片太多，这次不插入图片。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>注册一个 leancloud 国际版账户(国内的需要备案等一系列复杂的操作)</li><li>去GitHub fork项目，开启GitHub Action功能</li></ul><h3 id="为hexo博客添加评论valine系统"><a href="#为hexo博客添加评论valine系统" class="headerlink" title="为hexo博客添加评论valine系统"></a>为hexo博客添加评论valine系统</h3><p>这一步可参考以下链接，此处不再赘述，包括</p><ul><li>注册leancloud</li><li>配置hexo博客根目录下的<code>_config.(the name of your theme).yml</code> (这里需要修改的是对应主题的yml文件，不是<code>_config.yml</code>)</li></ul><p><a href='https://blog.csdn.net/blue_zy/article/details/79071414'>为你的Hexo加上评论系统-Valine – blue_zy</a></p><p><a href='https://blog.csdn.net/jiunian_2761/article/details/97388997'>Hexo博客进阶：为Next主题添加Valine评论系统– 千帆过烬</a></p><p>前两步，csdn，博客园大多数帖子都有教程，剩下的步骤有些难度，需要大量阅读相关帖子</p><h3 id="为hexo博客添加valine评论邮件提醒功能"><a href="#为hexo博客添加valine评论邮件提醒功能" class="headerlink" title="为hexo博客添加valine评论邮件提醒功能"></a>为hexo博客添加valine评论邮件提醒功能</h3><p>这一步包括</p><ul><li>自定义云引擎的变量 <del>(可选择氪还是不氪，不氪的选择体验版)</del></li><li>添加定时任务，定期唤醒和检查补发邮件</li></ul><p><a href='https://blog.csdn.net/Aoman_Hao/article/details/105323917'>Hexo博客Next主题valine评论系统邮件提醒 – AomanHao</a></p><p>完成这一步并且测试后，我心满意足，开始写博客，一开始还是有收到评论邮件的，过几天更新时发现有新评论却没有邮件提醒，回到leancloud后台一看，我%￥#&amp;*，引擎自动休眠了，再看日志，现实云函数报错，马上去必应一下这个情况，找不到有效解决方案，那就先搁着；过了几天来看，我去，提示我这个信息</p><p>“因为流控问题，通过定时任务唤醒体验版实例失败，建议升级至标准版引擎实例避免休眠”</p><p>好家伙，这明摆着要我去氪。不过，本着我多年不氪金<del>(白嫖)</del>的习惯，又去必应了下解决方案</p><h3 id="解决leancloud流控问题-最难"><a href="#解决leancloud流控问题-最难" class="headerlink" title="解决leancloud流控问题(最难)"></a>解决leancloud流控问题(最难)</h3><p>有三个常见的唤醒功能</p><ul><li>cron-job</li><li>Github+Action</li><li>Ajax请求唤醒</li></ul><p>csdn上大多数是去阿里云等网站申请唤醒功能，不过这些感觉需要花很多大洋的样子，就没去理会，后来发现GitHub+Action这个貌似不错，然后就去必应了下，雀食有很多帖子教GitHub+Action的，不过他们fork的项目已经不能访问了，就是这个： <code>https://github.com/blogimg/WakeLeanCloud</code></p><p>下面这两个帖子的</p><p><a href='https://hiram.wang/leancloud-timer-github-actions/#原有方案'>使用Github Actions模拟评论解决LeanCloud的流控限制 – Hiram’s Blog</a></p><p><a href='https://www.aimtao.net/slef-wake-leancloud/'>Gtihub Action｜一行命令解决 LeanCloud 流控问题 – AimTao’s Blog</a></p><p>以上两个博客提到的GitHub建议fork到本地仓库</p><p>按照上面两个博客其中之一设置完就差不多设置好了</p><h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><ul><li>怎么进入leancloud国际版评论后台网站：参照这个博客来设置user变量 <a href='https://www.fezhu.top/2020/07/02/liukong/'>解决Leancloud流控问题 – Uncleacc’s Blog</a></li><li>为什么提示云函数报错：是因为没有在云引擎处设置变量<code>ADMIN_URL</code>，这里填leancloud评论后台管理网址</li><li>云引擎中的变量<code>SMTP_PASS</code>不是邮箱密码，是邮箱SMTP的授权码</li><li>GitHub Action那里的<code>SITE</code>应该填评论后台管理网址</li></ul><p>写到这里，总算把折腾的全过程写出来了<del>(无用的知识增加了)</del></p>]]></content>
    
    
    <summary type="html">记录一次整活，完善博客的评论提醒功能</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="整活" scheme="https://jaydenchang.top/tags/%E6%95%B4%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>单链表(Java)</title>
    <link href="https://jaydenchang.top/post/0x0020.html"/>
    <id>https://jaydenchang.top/post/0x0020.html</id>
    <published>2021-08-06T16:00:00.000Z</published>
    <updated>2021-12-11T05:56:35.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>大体结构和C++的链表差不多，参考之前写过的博客 <a href='https://jaydenchang.gitee.io/post/0x0006'>单链表图书管理系统实例</a> <a href='https://jaydenchang.gitee.io/post/0x000B'>基于类的单链表实例</a></p><p>补充之前不知道的：链表分两类，带和不带头结点的链表  <del>现在才知道，Java没有像C/C++那样的指针</del></p><p>首先创建一个<code>LinkList</code>类，然后把链表的各个功能添加进去</p><h4 id="创建结点"><a href="#创建结点" class="headerlink" title="创建结点"></a>创建结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;当不考虑编号顺序时，找到当前链表最后节点，将最后节点next指向新节点public void add(PersonNode node) &#123;    &#x2F;&#x2F;因为头节点不能动，先需要一个辅助遍历节点temp    PersonNode temp &#x3D; head;            while (true) &#123;&#x2F;&#x2F;遍历链表，找到最后        if (temp.next &#x3D;&#x3D; null) &#123;            break;        &#125;                    temp &#x3D; temp.next;&#x2F;&#x2F;如果没到最后，就继续找下去    &#125;&#x2F;&#x2F;当退出while循环时，temp指向链表的最后    temp.next &#x3D; node;&#125;</code></pre><h4 id="添加结点-乱序"><a href="#添加结点-乱序" class="headerlink" title="添加结点(乱序)"></a>添加结点(乱序)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void addByOrder(PersonNode node) &#123;    &#x2F;&#x2F;因为头节点不移动，仍通过一个辅助变量来找添加的位置    &#x2F;&#x2F;因为是单链表，所以找的temp时位于添加位置的前一个结点，否则不能插入    PersonNode temp &#x3D; head;    boolean flag &#x3D; false;&#x2F;&#x2F;标识添加的编号是否存在    while (true) &#123;        if (temp.next &#x3D;&#x3D; null) &#x2F;&#x2F;说明temp在链表最后            break;        if (temp.next.no &gt; node.no) &#123;&#x2F;&#x2F;位置找到了，就在temp后面            break;        &#125; else if (temp.next.no &#x3D;&#x3D; node.no) &#123;&#x2F;&#x2F;希望添加的编号已存在            flag &#x3D; true;            break;        &#125;        temp &#x3D; temp.next;    &#125;    if (flag) &#123;&#x2F;&#x2F;编号已存在，不能添加        System.out.println(&quot;already exist no.&quot; + node.no + &quot;, you can&#39;t add it.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125; else &#123;        node.next &#x3D; temp.next;        temp.next &#x3D; node;    &#125;&#125;&#x2F;&#x2F;最终还是按照序号来排列</code></pre><h4 id="编辑结点"><a href="#编辑结点" class="headerlink" title="编辑结点"></a>编辑结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void edit(PersonNode node) &#123;&#x2F;&#x2F;这里直接引入外部结点，根据node.no来寻找需要修改的结点    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    PersonNode temp;    temp &#x3D; head.next;    boolean flag &#x3D; false;&#x2F;&#x2F;判断是否找到该结点    while (true) &#123;        if (temp &#x3D;&#x3D; null)            break;&#x2F;&#x2F;到了链表最后        if (temp.no &#x3D;&#x3D; node.no) &#123;            flag &#x3D; true;&#x2F;&#x2F;找到            break;        &#125;        temp &#x3D; temp.next;    &#125;    &#x2F;&#x2F;根据flag判断是否找到    if (flag) &#123;        temp.name &#x3D; node.name;        temp.score &#x3D; node.score;    &#125; else &#123;        System.out.println(&quot;not found no.&quot; + node.no + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#125;</code></pre><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void delete(int no) &#123;    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    PersonNode temp &#x3D; head;&#x2F;&#x2F;temp指向待删除结点的前一个结点    boolean flag &#x3D; false;    while (true) &#123;        if (temp.next &#x3D;&#x3D; null) &#123;                            break;&#x2F;&#x2F;已经到链表最后        &#125;        if (temp.next.no &#x3D;&#x3D; no) &#123;            flag &#x3D; true;&#x2F;&#x2F;找到了待删除结点的前一个结点temp            break;        &#125;        temp &#x3D; temp.next;    &#125;    if (flag) &#123;        temp.next &#x3D; temp.next.next;    &#x2F;&#x2F;Java会自动回收未被访问的数据            &#125; else &#123;        System.out.println(&quot;not found&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#125;</code></pre><h4 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void list() &#123;    &#x2F;&#x2F;判断链表是否为空    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    &#x2F;&#x2F;头节点不动，需要一个辅助变量来遍历    PersonNode temp &#x3D; head.next;    while (true) &#123;        &#x2F;&#x2F;判断是否到链表最后        if (temp &#x3D;&#x3D; null) &#123;            break;        &#125;        &#x2F;&#x2F;输出节点信息        System.out.println(temp);        &#x2F;&#x2F;由于之前重写了toString，这里直接打印temp就可以打印出节点的所有信息        temp &#x3D; temp.next;    &#125;&#125;</code></pre><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    PersonNode person1 &#x3D; new PersonNode(1, &quot;Jordan&quot;, 56);    PersonNode person2 &#x3D; new PersonNode(2, &quot;Kobe&quot;, 81);    PersonNode person3 &#x3D; new PersonNode(3, &quot;James&quot;, 61);    PersonNode person4 &#x3D; new PersonNode(4, &quot;Melo&quot;, 60);    LinkList list &#x3D; new LinkList();&#x2F;&#x2F;按照顺序添加    &#x2F;&#x2F; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#x2F;&#x2F; list.add(person1);    &#x2F;&#x2F; list.add(person2);    &#x2F;&#x2F; list.add(person3);    &#x2F;&#x2F; list.add(person4);&#x2F;&#x2F;不按照顺序添加    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add by order&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    list.addByOrder(person1);    list.addByOrder(person4);    list.addByOrder(person3);    list.addByOrder(person2);    list.list();    &#x2F;&#x2F; list.addByOrder(person2);    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;edit&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    PersonNode newNode &#x3D; new PersonNode(3, &quot;Ivring&quot;, 57);    list.edit(newNode);    list.list();&#x2F;&#x2F;删除结点    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;delete&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    list.delete(4);    list.list();&#125;</code></pre><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;SingleLinkList.javapublic class SingleLinkList &#123;    public static void main(String[] args) &#123;        PersonNode person1 &#x3D; new PersonNode(1, &quot;Jordan&quot;, 56);        PersonNode person2 &#x3D; new PersonNode(2, &quot;Kobe&quot;, 81);        PersonNode person3 &#x3D; new PersonNode(3, &quot;James&quot;, 61);        PersonNode person4 &#x3D; new PersonNode(4, &quot;Melo&quot;, 60);        LinkList list &#x3D; new LinkList();    &#x2F;&#x2F;按照顺序添加        &#x2F;&#x2F; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F; list.add(person1);        &#x2F;&#x2F; list.add(person2);        &#x2F;&#x2F; list.add(person3);        &#x2F;&#x2F; list.add(person4);    &#x2F;&#x2F;不按照顺序添加        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add by order&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        list.addByOrder(person1);        list.addByOrder(person4);        list.addByOrder(person3);        list.addByOrder(person2);        list.list();        &#x2F;&#x2F; list.addByOrder(person2);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;edit&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        PersonNode newNode &#x3D; new PersonNode(3, &quot;Ivring&quot;, 57);        list.edit(newNode);        list.list();    &#x2F;&#x2F;删除结点        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;delete&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        list.delete(4);        list.list();    &#125;&#125;&#x2F;&#x2F;定义一个成员点class PersonNode &#123;    String name;    public int no;    public int score;    public PersonNode next;&#x2F;&#x2F;指向下一个结点    public PersonNode(int no, String name, int score) &#123;        this.no &#x3D; no;        this.name &#x3D; name;        this.score &#x3D; score;    &#125;    &#x2F;&#x2F;为了显示方便，重写toString    @Override    public String toString() &#123;        return &quot;[no&#x3D;&quot; + no + &quot;,name&#x3D;&quot; + name + &quot;,score&#x3D;&quot; + score + &quot;]&quot;;    &#125;&#125;&#x2F;&#x2F;定义LinkList管理personclass LinkList &#123;    &#x2F;&#x2F;初始化头节点，头节点不能动    private PersonNode head &#x3D; new PersonNode(0, &quot;&quot;, 0);    public PersonNode getHead()&#123;        return head;&#x2F;&#x2F;返回私有成员head    &#125;    &#x2F;&#x2F;当不考虑编号顺序时，找到当前链表最后节点，将最后节点next指向新节点    public void add(PersonNode node) &#123;        &#x2F;&#x2F;因为头节点不能动，先需要一个辅助遍历节点temp        PersonNode temp &#x3D; head;                while (true) &#123;&#x2F;&#x2F;遍历链表，找到最后            if (temp.next &#x3D;&#x3D; null) &#123;                break;            &#125;                        temp &#x3D; temp.next;&#x2F;&#x2F;如果没到最后，就继续找下去        &#125;&#x2F;&#x2F;当退出while循环时，temp指向链表的最后        temp.next &#x3D; node;    &#125;    public void addByOrder(PersonNode node) &#123;        &#x2F;&#x2F;因为头节点不移动，仍通过一个辅助变量来找添加的位置        &#x2F;&#x2F;因为是单链表，所以找的temp时位于添加位置的前一个结点，否则不能插入        PersonNode temp &#x3D; head;        boolean flag &#x3D; false;&#x2F;&#x2F;标识添加的编号是否存在        while (true) &#123;            if (temp.next &#x3D;&#x3D; null) &#x2F;&#x2F;说明temp在链表最后                break;            if (temp.next.no &gt; node.no) &#123;&#x2F;&#x2F;位置找到了，就在temp后面                break;            &#125; else if (temp.next.no &#x3D;&#x3D; node.no) &#123;&#x2F;&#x2F;希望添加的编号已存在                flag &#x3D; true;                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag) &#123;&#x2F;&#x2F;编号已存在，不能添加            System.out.println(&quot;already exist no.&quot; + node.no + &quot;, you can&#39;t add it.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125; else &#123;            node.next &#x3D; temp.next;            temp.next &#x3D; node;        &#125;    &#125;    public void edit(PersonNode node) &#123;        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        PersonNode temp;        temp &#x3D; head.next;        boolean flag &#x3D; false;&#x2F;&#x2F;判断是否找到该结点        while (true) &#123;            if (temp &#x3D;&#x3D; null)                break;&#x2F;&#x2F;到了链表最后            if (temp.no &#x3D;&#x3D; node.no) &#123;                flag &#x3D; true;&#x2F;&#x2F;找到                break;            &#125;            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F;根据flag判断是否找到        if (flag) &#123;            temp.name &#x3D; node.name;            temp.score &#x3D; node.score;        &#125; else &#123;            System.out.println(&quot;not found no.&quot; + node.no + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;        public void delete(int no) &#123;        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        PersonNode temp &#x3D; head;&#x2F;&#x2F;temp指向待删除结点的前一个结点        boolean flag &#x3D; false;        while (true) &#123;            if (temp.next &#x3D;&#x3D; null) &#123;                                break;&#x2F;&#x2F;已经到链表最后            &#125;            if (temp.next.no &#x3D;&#x3D; no) &#123;                flag &#x3D; true;&#x2F;&#x2F;找到了待删除结点的前一个结点temp                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag) &#123;            temp.next &#x3D; temp.next.next;        &#125; else &#123;            System.out.println(&quot;not found&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F;Java会自动回收未被访问的数据    &#125;    &#x2F;&#x2F;显示链表(遍历)    public void list() &#123;        &#x2F;&#x2F;判断链表是否为空        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        &#x2F;&#x2F;头节点不动，需要一个辅助变量来遍历        PersonNode temp &#x3D; head.next;        while (true) &#123;            &#x2F;&#x2F;判断是否到链表最后            if (temp &#x3D;&#x3D; null) &#123;                break;            &#125;            &#x2F;&#x2F;输出节点信息            System.out.println(temp);            &#x2F;&#x2F;由于之前重写了toString，这里直接打印temp就可以打印出节点的所有信息            temp &#x3D; temp.next;        &#125;    &#125;&#125;</code></pre><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="求单链表中有效结点个数"><a href="#求单链表中有效结点个数" class="headerlink" title="求单链表中有效结点个数"></a>求单链表中有效结点个数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;如果带头节点的链表，不统计头节点public static int getLength(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null)        return 0;    int length &#x3D; 0;    PersonNode current &#x3D; head.next;&#x2F;&#x2F;定义辅助变量    while (current !&#x3D; null) &#123;        length++;        current &#x3D; current.next;    &#125;    return length;&#125;</code></pre><p>在主函数中测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(getLength(list.getHead()));</code></pre><h4 id="查找单链表中倒数第n个结点-新浪"><a href="#查找单链表中倒数第n个结点-新浪" class="headerlink" title="查找单链表中倒数第n个结点(新浪)"></a>查找单链表中倒数第n个结点(新浪)</h4><p>思路</p><ul><li>编写一个方法，接收head结点，同时接收一个index</li><li>index表示是倒数第index个结点</li><li>先把链表从头到尾遍历，得到链表的总长度 getLength</li><li>得到size后，我们从链表第一个开始遍历<code>(size-index)</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static PersonNode findLastIndexNode(PersonNode head, int index)&#123;    if (head.next &#x3D;&#x3D; null)        return null;    int size &#x3D; getlength(head);&#x2F;&#x2F;第一次遍历，获取链表大小    if (index &lt;&#x3D; 0 || index &gt; size)&#x2F;&#x2F;判断倒数的序号是否超出容量        return null;    PersonNode current &#x3D; head.next;    for (int i &#x3D; 0; i &lt; size - index; i++) &#123;        current &#x3D; current.next;&#x2F;&#x2F;遍历size-index次    &#125;    return current;&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">PersonNode res &#x3D; findLastIndexNode(list.getHead(), 1);System.out.println(res);</code></pre><h4 id="单链表反转-腾讯"><a href="#单链表反转-腾讯" class="headerlink" title="单链表反转(腾讯)"></a>单链表反转(腾讯)</h4><p>思路</p><ul><li>先定义一个结点<code>reverseHead = new PersonNode();</code></li><li>从头到尾遍历原来的链表，每遍历一个链表，就将其取出，放在新链表最前端</li><li>原来链表的<code>head.next = reverseHead.next;</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void reverseList(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)        return;    &#x2F;&#x2F; 定义一个辅助遍历，帮助遍历原来的链表    PersonNode current &#x3D; head.next;    PersonNode next &#x3D; null;&#x2F;&#x2F;指向当前结点[current]的下一个结点    PersonNode reverseHead &#x3D; new PersonNode(0, &quot;&quot;, 0);    while (current !&#x3D; null) &#123;        next &#x3D; current.next;&#x2F;&#x2F;先暂时保存当前结点的下一个结点，后面会用到        current.next &#x3D; reverseHead.next;&#x2F;&#x2F;把current的下一个结点指向新链表最前端        reverseHead.next &#x3D; current;&#x2F;&#x2F;将current连接到新链表        current &#x3D; next;&#x2F;&#x2F;让current后移&#x2F;*每一次循环，reverseHead.next都会按照原链表的顺序定位到current，遍历结束，刚到reverseHead.next定位到链表最后一个，此时把reverseHead.next地址赋给head.next，这样就可以倒着来遍历链表*&#x2F;    &#125;    head.next &#x3D; reverseHead.next;&#x2F;&#x2F;头结点拼接，实现反转&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">reverseList(list.getHead());list.list();</code></pre><h4 id="从尾到头打印单链表-百度"><a href="#从尾到头打印单链表-百度" class="headerlink" title="从尾到头打印单链表(百度)"></a>从尾到头打印单链表(百度)</h4><p>思路</p><ul><li>1.先反转后再打印(有个问题：只要求逆序打印，不要求反转，这样会破坏原链表结构)</li><li>2.用栈的方法，利用栈先进后出的特点，实现逆序打印的效果</li></ul><blockquote><p><code>stack.java</code></p></blockquote><p>下面是栈的实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Stack;public class stack&#123;    public static void main(String[] args)&#123;        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();        stack.add(&quot;James&quot;);        stack.add(&quot;Kboe&quot;);        stack.add(&quot;Jordan&quot;);        while(stack.size() &gt; 0)&#123;            System.out.println(stack.pop());        &#125;    &#125;&#125;</code></pre><p>用栈的方法实现从头到尾打印单链表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void reversePrint(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null)        return;    &#x2F;&#x2F;创建一个栈，将各个结点压入栈    Stack&lt;PersonNode&gt; stack &#x3D; new Stack&lt;PersonNode&gt;();    PersonNode current &#x3D; head.next;    while (current !&#x3D; null) &#123;        stack.push(current);        current &#x3D; current.next;    &#125;    while (stack.size() &gt; 0) &#123;        System.out.println(stack.pop());    &#125;&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">reversePrint(list.getHead());</code></pre>]]></content>
    
    
    <summary type="html">Java版的链表</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组和队列(数组)</title>
    <link href="https://jaydenchang.top/post/0x001F.html"/>
    <id>https://jaydenchang.top/post/0x001F.html</id>
    <published>2021-08-05T16:00:00.000Z</published>
    <updated>2021-12-11T06:06:16.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>当一个数组中大部分元素是0时，或者为同一个值的数组时，可以用稀疏数组来保存该数组，节省储存空间(二维数组储存太浪费空间了)</p><!--more>应用场景- 五子棋、围棋记录黑白子，无占位处记为0，黑白分别记为1，2- 扫雷- 象棋类，跳棋等处理方法：- 记录数组有几行几列，有多少个不同的值- 把有不同值的元素的行列及值记录在一个小规模的数组里，从而缩小程序的规模二维数组转化稀疏数组的思路- 遍历原始二维数组，得到有效数据的个数- 根据sum就可以创建稀疏数组 `int spareseArr[sum + 1][3]`- 将二维数组的有效数据的个数sum存入稀疏数组稀疏数组转原始二维数组- 先读稀疏数组第一行，根据第一行数据创建原始二维数组- 在读取稀疏数组后几行的数据，并赋予原始的二维数组`int originArr[size][size]`即可#### 代码<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;spareseArray.javaimport java.util.Scanner;public class spareseArray&#123;    public static void main(String[] args)&#123;        public static void main(String[] args) &#123;        Scanner scan &#x3D; new Scanner(System.in);        int size &#x3D; scan.nextInt();        scan.close();        int chessArr[][] &#x3D; new int[size][size];&#x2F;&#x2F;创建一个11*11的棋盘        chessArr[1][2] &#x3D; 1;        chessArr[2][3] &#x3D; 2;        chessArr[4][6] &#x3D; 1;        int sum &#x3D; 0;        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                if (chessArr[i][j] !&#x3D; 0)                    sum++;            &#125;        &#125;        &#x2F;&#x2F;创建稀疏数组        int spareseArr[][] &#x3D; new int[sum + 1][3];        &#x2F;&#x2F;给稀疏数组赋值        spareseArr[0][0] &#x3D; size;        spareseArr[0][1] &#x3D; size;        spareseArr[0][2] &#x3D; sum;        &#x2F;&#x2F;遍历二维数组，把非0的值存放在稀疏数组中        int count &#x3D; 0;&#x2F;&#x2F;计数器，记录非0数据个数        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                if (chessArr[i][j] !&#x3D; 0) &#123;                    count++;                    spareseArr[count][0] &#x3D; i;                    spareseArr[count][1] &#x3D; j;                    spareseArr[count][2] &#x3D; chessArr[i][j];                &#125;            &#125;        &#125;        &#x2F;&#x2F;输出稀疏数组的形式        System.out.println(&quot;the sparese Array:&quot;);        for (int i &#x3D; 0; i &lt; sum + 1; i++) &#123;            System.out.printf(&quot;%d %d %d\n&quot;, spareseArr[i][0], spareseArr[i][1], spareseArr[i][2]);        &#125;        &#x2F;&#x2F;稀疏数组恢复二维数组        int originArr[][] &#x3D; new int[spareseArr[0][0]][spareseArr[0][1]];        &#x2F;&#x2F;输出恢复后的二维数组        for (int i &#x3D; 1; i &lt; spareseArr.length; i++) &#123;            originArr[spareseArr[i][0]][spareseArr[i][1]] &#x3D; spareseArr[i][2];        &#125;        System.out.println(&quot;the origin array:&quot;);        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                System.out.print(originArr[i][j] + &quot; &quot;);            &#125;            System.out.println();        &#125;        &#125;&#125;</code></pre><p>参考链接：<a href='https://www.bilibili.com/video/BV1E4411H73v?from=search&seid=10722391219764061578'>尚硅谷–Java数据结构p7-p9  bilibili</a></p><h3 id="队列-数组"><a href="#队列-数组" class="headerlink" title="队列(数组)"></a>队列(数组)</h3><p>队列是一个有序列表，可以用数组或者链表来实现。遵循先入先出原则，这一部分用数组来模拟</p><p>应用场景：银行排队案例</p><p>队列本身是有序列表，需要两个变量front和rear分别标记队列前后端，front随着数据输出而改变，rear随着数据输入而改变。还有需要一个maxSize来标记队列的最大容量。</p><p>当存数据入列时</p><ul><li>把尾指针后移：rear+1，当front=rear [ 空 ]</li><li>若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。<code>rear == maxSize-1</code> =&gt; 队列满</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;import java.util.Scanner;public class Queue &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建一个队列        ArrayQueue queue &#x3D; new ArrayQueue(3);        char key &#x3D; &#39; &#39;;        Scanner scan &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        &#x2F;&#x2F;输出一个菜单        while (loop) &#123;            System.out.println(&quot;s(show queue)&quot;);            System.out.println(&quot;e(exit)&quot;);            System.out.println(&quot;a(add)&quot;);            System.out.println(&quot;g(get)&quot;);            System.out.println(&quot;h(head)&quot;);            key &#x3D; scan.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;output a num:&quot;);                    int value &#x3D; scan.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;get the num is: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                        break;                    &#125;                    break;                case &#39;h&#39;:                    &#x2F;&#x2F;查看队列头数据                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;head data: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:&#x2F;&#x2F;退出                    scan.close();                    loop &#x3D; false;&#x2F;&#x2F;退出while循环                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class ArrayQueue &#123;    private int maxSize;&#x2F;&#x2F;数组最大容量    private int front;&#x2F;&#x2F;队列头    private int rear;&#x2F;&#x2F;队列尾    private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列    &#x2F;&#x2F;创建队列的构造器    public ArrayQueue(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; -1;&#x2F;&#x2F;指向队列头部，指向数据头部前一个位置        rear &#x3D; -1;&#x2F;&#x2F;指向队列尾，指向队列尾的数据(即队列最后一个数据)    &#125;    &#x2F;&#x2F;判断队列是否满    public boolean isFull() &#123;        return rear &#x3D;&#x3D; maxSize - 1;    &#125;    &#x2F;&#x2F;判断队列是否空    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F;添加数据到队列    public void addQueue(int n) &#123;        &#x2F;&#x2F;判断队列是否满        if (isFull()) &#123;            System.out.println(&quot;the queue is full~~&quot;);            return;        &#125;        &#x2F;&#x2F;rear++;&#x2F;&#x2F;rear后移        &#x2F;&#x2F;arr[rear] &#x3D; n;        arr[++rear] &#x3D; n;&#x2F;&#x2F;这是上两行代码简写    &#125;    &#x2F;&#x2F;获取队列数据，出队列    public int getQueue() &#123;        &#x2F;&#x2F;判断是否为空        if (isEmpty()) &#123;            &#x2F;&#x2F;抛出异常            throw new RuntimeException(&quot;empty queue~~&quot;);        &#125;        front++;        return arr[front];    &#125;    &#x2F;&#x2F;显示队列所有数据    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;empty queue~~&quot;);            return;        &#125;        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);        &#125;    &#125;    &#x2F;&#x2F;显示队列的头数据，不是取出数据    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty queue~~&quot;);        &#125;        return arr[front + 1];&#x2F;&#x2F;使front指向头数据    &#125;&#125;</code></pre><p>缺点：</p><ul><li>数组只能用一次</li></ul><p>优化：</p><ul><li>改进成为环形队列 算法思想：取模%</li></ul><h3 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h3><p>思路：</p><ul><li>front变量含义做一个调整：front指向队列第一个元素，也就是<code>arr[front]</code>就是队列第一个元素</li><li>rear变量含义做一个调整：rear指向队列最后一个元素的后一个位置。留出一个空间来判断队列是空或满</li><li>当队列满时，条件是：<code>(rear+1)&amp;maxSize == front</code>  =&gt;队列满</li></ul><p>队列中有效数据的个数 <code>(rear + maxSize - front) % maxSize</code></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class CircleArrayQueue &#123;    public static void main(String[] args) &#123;        CircleArray queue &#x3D; new CircleArray(4);&#x2F;&#x2F;队列有效数据是3        char key &#x3D; &#39; &#39;;        Scanner scan &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        &#x2F;&#x2F;输出一个菜单        while (loop) &#123;            System.out.println(&quot;s(show queue)&quot;);            System.out.println(&quot;e(exit)&quot;);            System.out.println(&quot;a(add)&quot;);            System.out.println(&quot;g(get)&quot;);            System.out.println(&quot;h(head)&quot;);            key &#x3D; scan.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;output a num:&quot;);                    int value &#x3D; scan.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;get the num is: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                        break;                    &#125;                    break;                case &#39;h&#39;:                    &#x2F;&#x2F;查看队列头数据                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;head data: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:                    scan.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class CircleArray &#123;    private int maxSize;&#x2F;&#x2F;数组最大容量    private int front;&#x2F;&#x2F;队列头，队列的第一个元素，不一定是0    private int rear;&#x2F;&#x2F;队列尾    private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列    public CircleArray(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; 0;        rear &#x3D; 0;    &#125;    public boolean isFull() &#123;        return (rear + 1) % maxSize &#x3D;&#x3D; front;&#x2F;&#x2F;+1是利用了留出的空位来判断队列是否为满    &#125;    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;&#x2F;&#x2F;初始化时rear和front都是0，如果没有add，即可判断为空    &#125;    public void addQueue(int n) &#123;        if (isFull()) &#123;            System.out.println(&quot;full array~~&quot;);            return;        &#125;        arr[rear] &#x3D; n;&#x2F;&#x2F;直接把n赋给arr        rear &#x3D; (rear + 1) % maxSize;&#x2F;&#x2F;考虑取模    &#125;    public int getQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty array~~&quot;);        &#125;        &#x2F;&#x2F;这里要分析出front是指向队列的第一个元素        &#x2F;&#x2F;1.先把front对应的值保留到一个临时变量        &#x2F;&#x2F;2.把front后移        &#x2F;&#x2F;3.把临时保存的变量返回        int value &#x3D; arr[front];            front &#x3D; (front + 1) % maxSize;        return value;    &#125;    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;empty array~~&quot;);            return;        &#125;        for (int i &#x3D; front; i &lt; front + size(); i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i % maxSize, arr[i % maxSize]);        &#125;    &#125;    &#x2F;&#x2F;求出当前队列有效数据个数    public int size() &#123;        return (rear + maxSize - front) % maxSize;    &#125;    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty array~~&quot;);        &#125;        return arr[front];    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">简单记录稀疏数组的用法</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>js简单实现拦截访问指定网页</title>
    <link href="https://jaydenchang.top/post/0x001E.html"/>
    <id>https://jaydenchang.top/post/0x001E.html</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-12-11T06:06:47.305Z</updated>
    
    <content type="html"><![CDATA[<p>最近闲的无事，写个脚本玩玩，实现拦截访问指定网址</p><h3 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h3><p>要想实现这个功能，就要自定义一个浏览器插件</p><p>最简单的浏览器插件有两个文件，分别是<code>manifest.json</code>和<code>**.js</code>。首先新建一个文件夹，然后在文件夹目录新建上述两个文件。</p><h4 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a><code>manifest.json</code></h4><p><a href='https://ask.dcloud.net.cn/article/94'> <code>manifest.json</code> </a>是插件的配置文件，用于描述插件的元数据，插件的配置信息</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;name&quot;: &quot;hello&quot;,    &quot;description&quot;: &quot;hello&quot;,    &quot;version&quot;: &quot;1.0&quot;,    &quot;manifest_version&quot;: 2,    &quot;content_scripts&quot;: [&#123;        &quot;matches&quot;: [            &#39;http:&#x2F;&#x2F;*&#x2F;*&#39;, &quot;https:&#x2F;&#x2F;*&#x2F;*&quot;        ],        &quot;js&quot;: [            &quot;test.js&quot;        ]    &#125;]&#125;</code></pre><p>这里的matches通配http和https，js对应的文件名一定要和自己命名的js相同(包括路径)</p><h4 id="test-js"><a href="#test-js" class="headerlink" title="test.js"></a><code>test.js</code></h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">var url;url &#x3D; window.location.host;&#x2F;&#x2F;获取当前网页urlif(url &#x3D;&#x3D; &#39;www.google.com.hk&#39; || url &#x3D;&#x3D; &#39;www.google.com&#39;)&#123;    alert(&quot;反正你就是打不开这个页面doge&quot;);    window.location.href &#x3D; &#39;cn.bing.com&#39;;&#x2F;&#x2F;跳转到指定页面&#125;</code></pre><h3 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h3><p>edge用户在浏览器输入<code>edge://extensions</code>，chrome用户在浏览器输入<code>chrome://extensions</code> <del>(其他浏览器没用过)</del> ，然后把刚才装json和js的文件夹拖动到刚才打开的页面，重启浏览器就好了。</p>]]></content>
    
    
    <summary type="html">写了一个脚本来拦截网页</summary>
    
    
    
    <category term="FrontEnd" scheme="https://jaydenchang.top/categories/FrontEnd/"/>
    
    
    <category term="JavaScript" scheme="https://jaydenchang.top/tags/JavaScript/"/>
    
    <category term="技术" scheme="https://jaydenchang.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>练字时我在想什么</title>
    <link href="https://jaydenchang.top/post/0x001C.html"/>
    <id>https://jaydenchang.top/post/0x001C.html</id>
    <published>2021-07-19T16:00:00.000Z</published>
    <updated>2021-12-11T06:07:22.127Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天在练字，在练字时，脑子里有些奇怪的想法，趁着现在有时间，把自己的想法记录下</p><h4 id="小学"><a href="#小学" class="headerlink" title="小学"></a>小学</h4><p>犹记得是在四年级时，我看着爸妈、老师写连笔字很帅，于是也自己尝试写，就在我开始写连笔字的第二天，班主任发现不对，马上私信我爸妈，在我爸妈的连哄带骗下，我开始练字，练的啥呢，正楷，每天中午放学回家恰饭前就拿出字帖来练，字帖嘛，照着描，当时我给老师看了，嗯，写出来还是不错的，当字帖换成作业本时，他傻了，差点嘴吐芬芳，于是我又开始练字，就这样我练到了小学毕业，感觉也没什么长进，写出来有时候我都不知道自己在写啥 (<del>年代久远，小学的作业本找不到就不放图了</del>)</p><h4 id="初中"><a href="#初中" class="headerlink" title="初中"></a>初中</h4><p>刚进班级，我的班主任就注意到了我的字，马上找我和我爸妈谈话，毕竟我现在的字在中考上很吃亏，不过班主任没有让我去练正楷，让我去学一点行楷。好在我初中老师和我一些同学的字都比较好看，我时不时去模仿他们的字迹。</p><p>在初二时，我偶然知道，井柏然的字很好看，于是我去搜索他的微博，我勒个去，这是神仙写的字吧</p><p><a href='https://weibo.com/boranjing?is_all=1&is_search=1&key_word=手写'>井柏然的微博–#手写微博</a></p><p>正巧，当时小米收录了井柏然的字，我咬咬牙，省了几天生活费，买了下来装到手机上，在此之后我的字和以前有一些不一样了，虽然带有一点点点文艺范，但字本质上还是很潦草，特别是是写语文和政治时，心疼改卷老师φ(゜▽゜*)♪</p><p><del>(感觉也找不到以前的作业本了)</del></p><h4 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h4><p>让我的字开始定型是在我高一文理分科时，我注意到了我舍友的字，哎呀word麻鸭，这恰到好处的布局，word麻鸭，这刚劲有力的笔锋，word麻鸭，这行云流水的笔顺……真是妙到了米奇妙妙屋</p><p>放一张我高一的字</p><img src='https://jaydenchang.gitee.io/images/images/0x001C-1.jpg' style="border-radius: 5em; zoom: 20%;"><p>当时的我，觉得自己写的比初中好些了，不过，每到语文考试40min极限作文时，我的字又打回原形。</p><p>大概是在高三吧，那时候我开始写日记，经常和我舍友交流问题，两人在讨论过程就开始练字，在这个阶段了，我的字又有了质的飞跃<del>(感觉也就那样)</del>。</p><h4 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h4><p>大学里，关于练字这个话题，我身边比较少有人练字，都程序员了，练什么字，敲代码不香吗。曾经我试过3天没摸笔，果然，提笔忘字，这让我很是头疼，没办法，只能减少打代码时间，每天抽出10分钟写点字。然后就是大一下的思想汇报，写了大概几千字吧，是一个很好的练字机会，很庆幸当时自己能把自己摁下来乖乖一笔一划写好每个字<del>(有错字整页无了)</del>。</p><p>大一暑假，终于有时间练字了，还是照着井柏然的微博来练，坐在书桌前，听着周杰伦和林俊杰的歌，一笔一划，有种坐在咖啡厅里的感觉。</p><img src='https://jaydenchang.gitee.io/images/images/0x001C-2.jpg' style='border-radius:5em;zoom:20%;border-color:lightskyblue;'><img src='https://jaydenchang.gitee.io/images/images/0x001C-3.jpg' style='border-radius:5em;zoom:20%;border-color:lightskyblue;'><p>练字也有一周了，练字时我在想什么呢，答案是，什么也没想，看着别人的字，自己一笔一划照着写一遍，那种成就感、新鲜感无法形容，另外再配上林俊杰的歌，那环境简直惬意到起飞，那段时间，也是最容易迸发灵感的。</p><p>截止要到截稿时，我再回过头去看看我前几天写的字，突然感觉也没那么好看了，人嘛，就是在这样不断批判以前的自己中成长，寻之错并改之。练字真的是非常畅快的体验<del>(前提是内心要平静)</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近几天在练字，在练字时，脑子里有些奇怪的想法，趁着现在有时间，把自己的想法记录下&lt;/p&gt;
&lt;h4 id=&quot;小学&quot;&gt;&lt;a href=&quot;#小学&quot; class=&quot;headerlink&quot; title=&quot;小学&quot;&gt;&lt;/a&gt;小学&lt;/h4&gt;&lt;p&gt;犹记得是在四年级时，我看着爸妈、老师写连笔字很帅，于是也自己尝试写，就在我开始写连笔字的第二天，班主任发现不对，马上私信我爸妈，在我爸妈的连哄带骗下，我开始练字，练的啥呢，正楷，每天中午放学回家恰饭前就拿出字帖来练，字帖嘛，照着描，当时我给老师看了，嗯，写出来还是不错的，当字帖换成作业本时，他傻了，差点嘴吐芬芳，于是我又开始练字，就这样我练到了小学毕业，感觉也没什么长进，写出来有时候我都不知道自己在写啥 (&lt;del&gt;年代久远，小学的作业本找不到就不放图了&lt;/del&gt;)&lt;/p&gt;
&lt;h4 id=&quot;初中&quot;&gt;&lt;a href=&quot;#初中&quot; class=&quot;headerlink&quot; title=&quot;初中&quot;&gt;&lt;/a&gt;初中&lt;/h4&gt;&lt;p&gt;刚进班级，我的班主任就注意到了我的字，马上找我和我爸妈谈话，毕竟我现在的字在中考上很吃亏，不过班主任没有让我去练正楷，让我去学一点行楷。好在我初中老师和我一些同学的字都比较好看，我时不时去模仿他们的字迹。&lt;/p&gt;
&lt;p&gt;在初二时，我偶然知道，井柏然的字很好看，于是我去搜索他的微博，我勒个去，这是神仙写的字吧&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://weibo.com/boranjing?is_all=1&amp;is_search=1&amp;key_word=手写&quot;&gt;井柏然的微博–#手写微博&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正巧，当时小米收录了井柏然的字，我咬咬牙，省了几天生活费，买了下来装到手机上，在此之后我的字和以前有一些不一样了，虽然带有一点点点文艺范，但字本质上还是很潦草，特别是是写语文和政治时，心疼改卷老师φ(゜▽゜*)♪&lt;/p&gt;
&lt;p&gt;&lt;del&gt;(感觉也找不到以前的作业本了)&lt;/del&gt;&lt;/p&gt;
&lt;h4 id=&quot;高中&quot;&gt;&lt;a href=&quot;#高中&quot; class=&quot;headerlink&quot; title=&quot;高中&quot;&gt;&lt;/a&gt;高中&lt;/h4&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>接口和包</title>
    <link href="https://jaydenchang.top/post/0x001B.html"/>
    <id>https://jaydenchang.top/post/0x001B.html</id>
    <published>2021-07-17T16:00:00.000Z</published>
    <updated>2021-12-06T12:31:35.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="定义及基础用法"><a href="#定义及基础用法" class="headerlink" title="定义及基础用法"></a>定义及基础用法</h4><p>interface定义：没有字段的抽象类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface person&#123;    void hello();    String getName();&#125;&#x2F;*接口本质上就是抽象类abstract class person&#123;public abstract void fun();public abstract String getName();&#125;*&#x2F;</code></pre><p>如上代码，方法没有具体化，在需要调用的类里面通过覆写来实现具体功能，多个类之间重新覆写的功能相互不影响。继承接口时，一定要覆写接口里的所有方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class student implements person&#123;    private String name;    public student(String name)&#123;        this.name &#x3D; name;    &#125;    @override    public void hello()&#123;        System.out.print(&quot;hello, &quot; + this.name);    &#125;    @override    public String getName()&#123;        return this.name;    &#125;&#125;class teacher implements person&#123;    private String name;    public student(String name)&#123;        this.name &#x3D; name;    &#125;    @override    public void hello()&#123;        System.out.print(&quot;hello, Mr&#x2F;Mrs.&quot; + this.name);    &#125;    @override    public String getName()&#123;        return this.name;    &#125;&#125;</code></pre><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>普通类继承中，只能继承一个类，而接口可实现多继承</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class teacher implements person, parents&#123;&#x2F;**&#x2F;&#125;</code></pre><p>一个interface可以继承自另一个interface</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface hello&#123;    void hello();&#125;interface person extends hello&#123;    void fun();    String getName();    &#x2F;&#x2F;此时，person接口实际上有三个抽象方法前面，其中一个继承自hello&#125;</code></pre><h4 id="abstract和interface对比"><a href="#abstract和interface对比" class="headerlink" title="abstract和interface对比"></a>abstract和interface对比</h4><blockquote><p>abstract</p><ul><li>定义实例字段</li><li>定义抽象方法</li><li>定义非抽象方法</li><li>but，只能extends一个class</li></ul></blockquote><blockquote><p>interface</p><ul><li>可以implements多个interface</li><li>定义抽象方法</li><li>定义default方法</li><li>but，不能定义实例字段</li></ul></blockquote><br><h4 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa &#123;    public static void main(String[] args) &#123;        person p &#x3D; new student(&quot;aaaaa&quot;);        p.fun();    &#125;&#125;interface person &#123;    String getName();    default void fun() &#123;        System.out.println(getName() + &quot; fun()&quot;);    &#125;&#x2F;&#x2F;default修饰具体方法&#125;class student implements person &#123;    private String name;    public student(String name) &#123;        this.name &#x3D; name;    &#125;    public String getName() &#123;        return this.name;    &#125;    &#x2F;&#x2F;在这个例子中，student类就没有去重新覆写fun()函数&#125;</code></pre><p>当接口新增一个方法时，会涉及到修改全部子类，如果新增的是default方法，子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法</p><p>default和抽象类的普通方法是不太一样的，interface没有字段，default无法访问字段，而抽象类的普通方法可以访问实例字段。不过在interface中，default可以修饰具体方法</p><h4 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa &#123;    public static void main(String[] args) &#123;        person.setNumber(99);        System.out.println(person.number);    &#125;&#125;class person &#123;    public static int number;    public static void setNumber(int value) &#123;        number &#x3D; value;    &#125;&#125;</code></pre><p>静态方法属于class不属于实例，可以直接通过类名来调用</p><h4 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h4><p>尽管interface是纯抽象类，但它可以有静态字段，静态字段必须是final类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;person.javapublic interface person&#123;    public static final int male &#x3D; 1;    public static final int female &#x3D; 2;&#125;</code></pre><p>实际上，因为interface的字段只能是<code>public static final</code>类型，所以我们可以把int前面的修饰符去掉</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;person.javapublic interface person&#123;    int male &#x3D; 1;    int female &#x3D; 2;    &#x2F;&#x2F;编译器会自动把该字段变为public static final类型&#125;</code></pre><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>例如，在同一文件夹下，a写了一个person类，b也写了一个person类，c想用a和b的person类，这时候引入包(package)的概念</p><blockquote><p>aa.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;class person&#123;&#125;public class aa&#123;&#125;</code></pre><blockquote><p>bb.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;class person&#123;&#125;public class bb&#123;&#125;</code></pre><p>包可以是多层结构，用<code>.</code>隔开，例如<code>java.util</code></p><p>:::tip</p><p>包没有父子关系，<code>java.util</code>和<code>java.util.zip</code>是不同的包，两者没有继承关系</p><p>:::</p><h4 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h4><p>:::tip</p><p>例如，如果想要定义包hello，则需要新建一个文件夹并命名为hello，文件夹下存放有hello包的Java文件</p><p>:::</p><blockquote><p><code>hello\person.java</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;public class person&#123;    void hello()&#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;</code></pre><blockquote><p><code>hello\main.java</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;public class main&#123;    public static void main(String[] args)&#123;        person p &#x3D; new person();        p.hello();&#x2F;&#x2F;result: hello    &#125;&#125;</code></pre><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>在一个class中，我们会引用其他的class，例如，Jay的<code>person.jay</code>类，如果要引用jjlin的<code>hello.jjlin</code>类，需要引入这个包</p><blockquote><p><code>hello\jjlin.java</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;jjlin.javapackage hello;public class jjlin&#123;    public void fun()&#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;</code></pre><blockquote><p><code>person\jay.java</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;jay.javapackage person;import hello.jjlin;&#x2F;&#x2F;表示引入hello文件夹下的jjlin文件public class jay&#123;    public void run()&#123;        jjlin temp &#x3D; new jjlin();    &#125;&#125;</code></pre><p>除了引入包下的具体类，也可以使用*，把包下的所有class都导入进来(不辨认子包的class)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package person;import jay.*;&#x2F;&#x2F;引入jay文件夹下所有classpublic class jay&#123;    public void run()&#123;        jjlin temp &#x3D; new jjlin();    &#125;&#125;</code></pre><h4 id="import-static"><a href="#import-static" class="headerlink" title="import static"></a>import static</h4><p>此方法可以导入一个类的静态字段和静态方法，此语法比较少用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;package main;import static java.lang.System.*;&#x2F;&#x2F;导入System类的所有静态字段和静态方法public class main&#123;    public static void main(String[] args)&#123;        out.println(&quot;hello&quot;);        &#x2F;&#x2F;如果不引用System包，则要写成下面形式        &#x2F;&#x2F;System.out.println(&quot;hello&quot;);            &#125;&#125;</code></pre><p>Java编译器最终编译出的<code>.class</code>文件只是用完整类名，因此，在代码中，当编译器遇到一个class名称时：</p><ul><li>如果是完整类名，就直接根据完整类名来查找这个class</li><li>如果是简单类名，依次按照下面的顺序依次查找<ul><li>查找当前package是否存在这个class</li><li>查找import包是否含有这个class</li><li>查找<code>java.lang</code>包是否含有这个class</li></ul></li></ul><p>如果按照上面规则还无法确定类名，则编译报错</p><p>下面是一个例子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;main.javapackage test;import java.text.Format;public class main&#123;    public static void main(String[] args)&#123;        java.util.list list;&#x2F;&#x2F;ok，使用完整类名        Format format &#x3D; null;&#x2F;&#x2F;ok，使用import的类        String s &#x3D; &quot;hi&quot;;&#x2F;&#x2F;ok，使用java.lang的包的String        System.out.println(s);&#x2F;&#x2F;ok，使用java.lang的包的System        MessageFormat mf &#x3D; null;&#x2F;&#x2F;错误，无法找到MessageFormat    &#125;&#125;</code></pre><p>因此在编写class时，编译器会自动帮我们做两个import动作</p><ul><li>默认自动import当前package的其他class</li><li>默认<code>import java.lang.*</code></li></ul><p>:::tip</p><p>自动导入的是<code>java.lang</code>的包，但类似<code>java.lang.reflect</code>这些包还需要手动导入</p><p>:::</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>为避免名字冲突，我们需要确定唯一的包名，推荐使用倒置的域名来确保唯一性</p><ul><li><code>org.apache</code>，本质上是<code>/org/apache/</code>路径下的class，下同</li><li><code>org.apache.commons.log</code></li><li><code>com.jayden.sample</code></li></ul><p>子包就可以根据功能自行命名</p><p>注意不要和<code>java.lang</code>的包的类重名</p><ul><li><code>String</code></li><li><code>System</code></li><li><code>Runtime</code></li><li>…</li></ul><p>也不要和jdk常用的类重名</p><ul><li><code>java.util.List</code></li><li><code>java.text.Format</code></li><li><code>java.math.BigInteger</code></li><li>…</li></ul><p><a href='https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816'>参考链接-廖雪峰-Java-面向对象编程-接口</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976">参考链接-廖雪峰-Java-面向对象编程-包</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h3&gt;&lt;h4 id=&quot;定义及基础用法&quot;&gt;&lt;a href=&quot;#定义及基础用法&quot; class=&quot;headerlink&quot; title=&quot;定义及基础用法&quot;&gt;&lt;/a&gt;定义及基础用法&lt;/h4&gt;&lt;p&gt;interface定义：没有字段的抽象类&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;interface person&amp;#123;
    void hello();
    String getName();
&amp;#125;
&amp;#x2F;*接口本质上就是抽象类
abstract class person&amp;#123;
	public abstract void fun();
	public abstract String getName();
&amp;#125;
*&amp;#x2F;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码，方法没有具体化，在需要调用的类里面通过覆写来实现具体功能，多个类之间重新覆写的功能相互不影响。继承接口时，一定要覆写接口里的所有方法&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class student implements person&amp;#123;
    private String name;
    public student(String name)&amp;#123;
        this.name &amp;#x3D; name;
    &amp;#125;
    @override
    public void hello()&amp;#123;
        System.out.print(&amp;quot;hello, &amp;quot; + this.name);
    &amp;#125;
    @override
    public String getName()&amp;#123;
        return this.name;
    &amp;#125;
&amp;#125;
class teacher implements person&amp;#123;
    private String name;
    public student(String name)&amp;#123;
        this.name &amp;#x3D; name;
    &amp;#125;
    @override
    public void hello()&amp;#123;
        System.out.print(&amp;quot;hello, Mr&amp;#x2F;Mrs.&amp;quot; + this.name);
    &amp;#125;
    @override
    public String getName()&amp;#123;
        return this.name;
    &amp;#125;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;多继承&quot;&gt;&lt;a href=&quot;#多继承&quot; class=&quot;headerlink&quot; title=&quot;多继承&quot;&gt;&lt;/a&gt;多继承&lt;/h4&gt;&lt;p&gt;普通类继承中，只能继承一个类，而接口可实现多继承&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class teacher implements person, parents&amp;#123;&amp;#x2F;**&amp;#x2F;&amp;#125;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个interface可以继承自另一个interface&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于面向对象编程</title>
    <link href="https://jaydenchang.top/post/0x001A.html"/>
    <id>https://jaydenchang.top/post/0x001A.html</id>
    <published>2021-07-13T16:00:00.000Z</published>
    <updated>2021-12-06T12:31:35.097Z</updated>
    
    <content type="html"><![CDATA[<p>暑假预习Java，这里总结下面向对象中Java和C++一些不一样的地方</p><h3 id="super"><a href="#super" class="headerlink" title="super();"></a><code>super();</code></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class person &#123;    protected int age;    public person(int age) &#123;        this.age &#x3D; age;    &#125;&#125;class student extends person &#123;    protected int score;    public student(int age,int score) &#123;        &#x2F;&#x2F;super(age);        this.score &#x3D; score;    &#125;&#125;</code></pre><p>如果没有使用super，会得到一个编译错误，在student的构造方法中，无法调用person的构造方法</p><p>在java里，任何class的构造方法，第一行必须调用父类的构造方法，如果没有明确地调用父类的构造方法，编译器会自动加一句<code>super();</code>，but，这个super里没有参数，父类里没有无参数的构造方法，故编译失败，因此，需要把注释去掉，加上正确的super语句</p><h3 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h3><h4 id="官方版"><a href="#官方版" class="headerlink" title="官方版"></a>官方版</h4><blockquote><p>aa.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class aa&#123;&#x2F;* code *&#x2F;&#125;</code></pre><p>用<code>final</code>来修饰指定类</p><blockquote><p>bb.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class bb extends aa&#123;&#x2F;* code *&#x2F;&#125;</code></pre><p>编译完第一个类后再编译第二个类，JDK编译器会报错，编译器会在extends处提示错误</p><h4 id="非官方版"><a href="#非官方版" class="headerlink" title="非官方版"></a>非官方版</h4><blockquote><p>aa.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa&#123;    private aa()&#123;&#x2F;**&#x2F;&#125;    public static aa fun()&#123;        return new aa();    &#125;&#125;</code></pre><p>Java在继承时必须在构造器里的第一行调用super class的构造器。当父类构造器设为private权限时，其他类继承这个类时，编译器会尝试调用一个默认的super构造器，而super构造器时private的，就不能被调用，也就是不能被继承。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote><p>aa.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa&#123;    public static void main(String[] args)&#123;        person p &#x3D; new student();        p.run();        &#x2F;&#x2F;result: student.run    &#125;&#125;class person&#123;    public void fun()&#123;        System.out.println(&quot;person.run&quot;);    &#125;&#125;class student&#123;@override    &#x2F;&#x2F;override后面不要加分号    public void fun()&#123;        System.out.print(&quot;student.run&quot;);    &#125;&#125;</code></pre><p>下面是一个报税的例子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa &#123;    public static void main(String[] args) &#123;        income[] incomes &#x3D; new income[] &#123; new income(3000), new salary(7000), new allowance(10000) &#125;;        System.out.println(totalTax(incomes));        &#x2F;&#x2F;打印的结果是income，salary，allowance折扣后的总值    &#125;    public static double totalTax(income... incomes) &#123;        double total &#x3D; 0;        for (income in : incomes) &#123;            total +&#x3D; in.getTax();        &#125;        return total;    &#125;&#125;class income &#123;    &#x2F;&#x2F;收入    protected double in;    public income(double in) &#123;        this.in &#x3D; in;    &#125;    public double getTax() &#123;        return in * 0.1;    &#125;&#125;class salary extends income &#123;    &#x2F;&#x2F;工资    public salary(double in) &#123;        super(in);    &#125;    @Override    public double getTax() &#123;        if (in &lt;&#x3D; 5000)            return 0;        return (in-5000)*0.2;    &#125;&#125;class allowance extends income &#123;    &#x2F;&#x2F;特殊津贴    public allowance(double in) &#123;        super(in);    &#125;    @Override    public double getTax() &#123;        return 0;    &#125;&#125;</code></pre><h3 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class person&#123;    protected String name;    public String hello()&#123;        return &quot;hello, &quot; + name;    &#125;&#125;class student extends person&#123;    @override    public String hello()&#123;        &#x2F;&#x2F;调用父类的hello()方法        return super.hello() + &quot;!&quot;;    &#125;&#125;</code></pre><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class aa&#123;    public final String fun()&#123;&#x2F;**&#x2F;&#125;&#125;class bb&#123;@override    public String fun()&#123;&#x2F;**&#x2F;&#125;    &#x2F;&#x2F;父类成员用final修饰，子类不能重写    &#x2F;&#x2F;final修饰类，类不能被继承，final修饰变量，变量必须初始化&#125;</code></pre><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;定义一个抽象类class person&#123;    public abstract void fun();&#125;</code></pre><p>把一个方法声明为abstract，提示编译错误，无法编译person类，因为它包含抽象方法，所以必须把person也声明为abstract，这就叫抽象类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">abstract class person&#123;    public abstract void fun();&#125;</code></pre><p>但是，对于person类，我们无法使他实例化，即在main中执行<code>person p = new person();</code></p><p>因此，抽象类一般被设计来继承</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa &#123;    public static void main(String[] args) &#123;        person p &#x3D; new student();        person t &#x3D; new teacher();        p.fun();        t.fun();    &#125;&#125;abstract class person &#123;    public abstract void fun();&#125;class student extends person &#123;    @Override    public void fun() &#123;        System.out.println(&quot;student.fun&quot;);    &#125;&#125;class teacher extends person&#123;    @override    public void fun()&#123;        System.out.println(&quot;teacher.fun&quot;);    &#125;&#125;</code></pre><p>如上例子，person定义了抽象方法<code>fun()</code>，那么在实现子类时，就必须覆写<code>run()</code></p><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>刚才定义了抽象类<code>person()</code>，以及具体的student、teacher的子类，我们可以通过抽象类person去引用具体的子类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">person s &#x3D; new student();person t &#x3D; new teacher();</code></pre><p>这种引用抽象类的好处在于，我们调用其方法，并不关心person类型变量的具体子类型</p><pre class="line-numbers language-none"><code class="language-none">s.fun();t.fun();</code></pre><p>同样的，我们再用用一个新的子类，我们仍不关心具体类型。</p><p>因此，这种尽量引用高层类型，避免引用实际子类型的方式，叫面向对象编程</p><p>三个本质</p><ul><li>上层代码只定义规范(例如<code>abstract class person;</code>)；</li><li>不需要子类就可以实现业务逻辑(正常编译)</li><li>实现的业务逻辑由不同的子类实现，调用者并不关心</li></ul><p>:::tip</p><p>一个java文件里只能有一个public类</p><p>:::</p><p><del>感觉我的面向对象编程是在Java里学的</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;暑假预习Java，这里总结下面向对象中Java和C++一些不一样的地方&lt;/p&gt;
&lt;h3 id=&quot;super&quot;&gt;&lt;a href=&quot;#super&quot; class=&quot;headerlink&quot; title=&quot;super();&quot;&gt;&lt;/a&gt;&lt;code&gt;super();&lt;/code&gt;&lt;/h3&gt;&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class person &amp;#123;
    protected int age;

    public person(int age) &amp;#123;
        this.age &amp;#x3D; age;
    &amp;#125;
&amp;#125;

class student extends person &amp;#123;
    protected int score;

    public student(int age,int score) &amp;#123;
        &amp;#x2F;&amp;#x2F;super(age);
        this.score &amp;#x3D; score;
    &amp;#125;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有使用super，会得到一个编译错误，在student的构造方法中，无法调用person的构造方法&lt;/p&gt;
&lt;p&gt;在java里，任何class的构造方法，第一行必须调用父类的构造方法，如果没有明确地调用父类的构造方法，编译器会自动加一句&lt;code&gt;super();&lt;/code&gt;，but，这个super里没有参数，父类里没有无参数的构造方法，故编译失败，因此，需要把注释去掉，加上正确的super语句&lt;/p&gt;
&lt;h3 id=&quot;阻止继承&quot;&gt;&lt;a href=&quot;#阻止继承&quot; class=&quot;headerlink&quot; title=&quot;阻止继承&quot;&gt;&lt;/a&gt;阻止继承&lt;/h3&gt;&lt;h4 id=&quot;官方版&quot;&gt;&lt;a href=&quot;#官方版&quot; class=&quot;headerlink&quot; title=&quot;官方版&quot;&gt;&lt;/a&gt;官方版&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;aa.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public final class aa&amp;#123;&amp;#x2F;* code *&amp;#x2F;&amp;#125;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;final&lt;/code&gt;来修饰指定类&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于css的一些动画</title>
    <link href="https://jaydenchang.top/post/0x0018.html"/>
    <id>https://jaydenchang.top/post/0x0018.html</id>
    <published>2021-07-07T16:00:00.000Z</published>
    <updated>2021-12-11T05:57:02.470Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为期末复习周，博客更新鸽了很久，趁着考完试还记得这件事，把之前的大作业里出现过的css动画总结一下</p><h3 id="页脚的联系方式图标"><a href="#页脚的联系方式图标" class="headerlink" title="页脚的联系方式图标"></a>页脚的联系方式图标</h3><p>这个图片原型是一个静态图</p><img src='https://jaydenchang.gitee.io/images/images/footer-sprit.png'><p>动画效果如下</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-3.gif' style="zoom:67%;" ><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&#39;footer&#39;&gt;    &lt;div class&#x3D;&#39;container&#39;&gt;        &lt;div class&#x3D;&#39;footer-main&#39;&gt;            &lt;div class&#x3D;&#39;col-md-6 footer-left&#39;&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;a href&#x3D;&#39;#&#39;&gt;&lt;span class&#x3D;&#39;fb&#39;&gt; &lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                    &lt;li&gt;&lt;a href&#x3D;&#39;#&#39;&gt;&lt;span class&#x3D;&#39;twit&#39;&gt; &lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                    &lt;li&gt;&lt;a href&#x3D;&#39;#&#39;&gt;&lt;span class&#x3D;&#39;in&#39;&gt; &lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                &lt;&#x2F;ul&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.footer&#123;    background: #3193d1;&#x2F;*可选，动画的父级div的背景颜色*&#x2F;    padding: 2em 0;    width: 100%;&#x2F;*decide by yourself*&#x2F;    margin-left: 0;&#125;.footer-left ul&#123;    padding: 0;&#125;.footer-left ul li&#123;    list-style: none;    display: inline-block;&#125;.footer-left ul li span&#123;    background-image: url(..&#x2F;img&#x2F;footer-sprit.png);    width: 30px;    height: 30px;    &#x2F;*这样设置行高考虑到图片的大小，只展现这么大的方块来显示图标*&#x2F;    display: block;    &#x2F;*以块形式呈现元素*&#x2F;    transition: 0.5s all;    -webkit-transition:0.5s all;-moz-transition:0.5s all;-o-transition:0.5s all;-ms-transition:0.5s all;    &#x2F;*display on different browsers*&#x2F;&#125;.footer-left ul li span.fb&#123;    background-position: 0 0;&#125;.footer-left ul li span.twit&#123;    background-position: -30px 0;    &#x2F;*向右移动30px，显示中上位置的图标*&#x2F;&#125;.footer-left ul li span.in&#123;    background-position: -60px 0;&#125;.footer-left ul li span.fb:hover&#123;background-position:0px -30px;    &#x2F;*第一个参数是向左偏移，第二个是向下偏移，取负数则向相反的方向移动*&#x2F;&#125;.footer-left ul li span.twit:hover&#123;background-position:-30px -30px;&#125;.footer-left ul li span.in:hover&#123;background-position:-60px -30px;&#125;</code></pre><h3 id="展示板块"><a href="#展示板块" class="headerlink" title="展示板块"></a>展示板块</h3><p>该展示板块用css过渡，鼠标指针悬浮出现动画</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-1.gif'><h4 id="html-1"><a href="#html-1" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&#39;mg&#39; style&#x3D;&#39;margin-left: 20px&#39;&gt;    &lt;div class&#x3D;&#39;tile&#39; style&#x3D;&#39;margin-left: 120px&#39;&gt;        &lt;div class&#x3D;&#39;text11&#39;&gt;            &lt;h1&gt;text&lt;&#x2F;h1&gt;            &lt;!--&lt;img src&#x3D;&#39;#&#39;&gt; 方块的背景图--&gt;            &lt;h2 class&#x3D;&#39;animate-text&#39;&gt;text&lt;&#x2F;h2&gt;            &lt;p class&#x3D;&#39;animate-text&#39;&gt;text&lt;&#x2F;p&gt;            &lt;div class&#x3D;&#39;dots&#39;&gt;                &lt;span&gt;&lt;&#x2F;span&gt; &lt;span&gt;&lt;&#x2F;span&gt; &lt;span&gt;&lt;&#x2F;span&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.mg .tile&#123;margin-left: 120px&#125;.tile &#123;    width: 570px;    height: 300px;    margin: 20px;    background-color: #99aeff;&#x2F;*加载动画后的方块的颜色*&#x2F;    display: inline-block;    &#x2F;*block和inline-block的区别，前者独占一行，后者可以并排*&#x2F;    background-size: cover;&#x2F;*把图片放大到元素容器合适的尺寸*&#x2F;    &#x2F;*如果设置一个100%，平铺x轴，两个100%铺满容器，图片可能会被拉伸*&#x2F;    position: relative;    cursor: pointer;    transition: all 0.4s ease-out;    &#x2F;*默认值为all 0 ease    all是设置过渡效果 第一个数字是过渡时间 ease是一个函数，用来控制过渡的快慢状态*&#x2F;    box-shadow: 0px 35px 77px -17px rgba(0, 0, 0, 0.44);    &#x2F;*四个数字，水平阴影位置，垂直阴影位置，模糊距离(可选)，阴影大小(可选)，阴影颜色*&#x2F;    overflow: hidden;&#x2F;*隐藏溢出部分*&#x2F;    color: white;    font-family: &#39;HPE&#39;;&#125;</code></pre><h3 id="read-more"><a href="#read-more" class="headerlink" title="read more"></a>read more</h3><p>同上一个，也是通过指针悬浮来显示动画</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-2.gif'><h4 id="html-2"><a href="#html-2" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&#39;tool&#39;&gt;    &lt;a class&#x3D;&#39;tooltips&#39; href&#x3D;&#39;#&#39;&gt;&lt;span&gt;Read more&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css-2"><a href="#css-2" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.tool&#123;position: relative; display: inline;&#125;a.tooltips span &#123;position: absolute;width: 168px;background: #FFFFFF;border: 2px solid #ea5b60;height: 42px;text-align: center;color: #000;padding: 14px 0px 0px 0px;&#125;a.tooltips span:hover &#123;background: #ea5b60;color: #fff;transition: 0.5s all;-webkit-transition: 0.5s all;-moz-transition: 0.5s all;-o-transition: 0.5s all;-ms-transition: 0.5s all;&#125;a.tooltips span:before &#123;content: &#39;&#39;;position: absolute;top: 22%;left: 81%;margin-left: -12px;width: 0;height: 0;border-top: 29px solid #ea5b60;border-right: 28px solid transparent;border-left: 28px solid transparent;transform: rotate(90deg);&#125;a.tooltips span:after &#123;content: &#39;&#39;;position: absolute;top: 21%;left: 79%;margin-left: -8px;width: 0;height: 0;border-top: 30px solid #FFFFFF;border-right: 31px solid transparent;border-left: 30px solid transparent;transform: rotate(90deg);&#125;.container1&#123;    padding-right: 15px;    padding-left: 15px;    margin-left: auto;    margin-right: auto;&#125;</code></pre><h3 id="划线动态"><a href="#划线动态" class="headerlink" title="划线动态"></a>划线动态</h3><p>在文字上下方加动态划线</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-4.gif'><h4 id="html-3"><a href="#html-3" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&#39;text1&#39;&gt;    &lt;a href&#x3D;&#39;#&#39;&gt;text&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css-3"><a href="#css-3" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.text1&#123;    position: relative;&#125;.text1::before,.text1::after&#123;  content: &quot;&quot;;  z-index: -1;  position: absolute;  left: 0;  right: 0;  height: 2px;  background: lightskyblue;  transform: scaleX(0);  transition: transform 0.2s ease-in-out;&#125;.text1::before&#123;    top: 0;    tranform-origin: center right;&#125;.text1::after&#123;    bottom: 0;    transform-origin: center left;&#125;.text1:hover&#123;cursor: pointer;&#125;.text1:hover::before&#123;    transform-origin: center left;    transform: scaleX(1);&#125;.text:hover::after&#123;    transform-origin: center right;    transform: sclaeX(1);&#125;</code></pre><h3 id="划线动画-升级版"><a href="#划线动画-升级版" class="headerlink" title="划线动画(升级版)"></a>划线动画(升级版)</h3><p>在上一个的基础上，对相关元素重写，呈现如下图效果</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-5.gif'><h4 id="html-4"><a href="#html-4" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&quot;row&quot;&gt;    &lt;div class&#x3D;&quot;type both clock&quot;&gt;text        &lt;div class&#x3D;&quot;inner&quot;&gt;&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css-4"><a href="#css-4" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.type &#123;    position: relative;    &#x2F;* font-size: 1em; *&#x2F;    &#x2F;* 不加relative会显示全屏划线 *&#x2F;&#125;.type .inner &#123;    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;&#125;&#x2F;* 如果说只要上下或者左右划线动画，可以不用加.inner标签，如果需要四条边，则需要加上.inner标签的before和after，并设置相关属性 *&#x2F;.type::before, .type::after, .type .inner::before, .type .inner::after&#x2F;* 这里有个一定要设置四个对象，一个对象对应一条边，before对应左和上，after对应右和下 *&#x2F;    &#123;    position: absolute;    content: &#39;&#39;;    display: block;    background: lightskyblue;    -webkit-transition: -webkit-transform 1s;    transition: -webkit-transform 1s;    transition: transform 1s;    transition: transform 1s, -webkit-transform 1s;&#125;.type.both::before, .type.both::after &#123;    left: 0;    width: 100%;    height: 2px;    -webkit-transform: scaleX(0);    transform: scaleX(0);&#125;.type.both .inner::after, .type.both .inner::before &#123;    top: 0;    width: 2px;    height: 100%;    -webkit-transform: scaleY(0);    transform: scaleY(0);&#125;.type.both .inner::before &#123;    left: 0;&#125;.type.both .inner::after &#123;    right: 0;&#125;.type.both .inner:hover::before, .type.both .inner:hover::after &#123;    transform: scaleY(1);    -webkit-transform: scaleY(1);&#125;.type.both::before &#123;    top: 0;&#125;.type.both::after &#123;    bottom: 0;&#125;.type.both:hover::before, .type.both:hover::after &#123;    transform: scaleX(1);    -webkit-transform: scaleX(1);&#125;.type.both:hover .inner::before, .type.both:hover .inner::after &#123;    transform: scaleY(1);    -webkit-transform: scaleY(1);&#125;&#x2F;* 关于transform-origin属性top left | left top 等价于 0 0；top | top center | center top 等价于 50% 0right top | top right 等价于 100% 0left | left center | center left 等价于 0 50%center | center center 等价于 50% 50%（默认值）right | right center | center right 等价于 100% 50%bottom left | left bottom 等价于 0 100%bottom | bottom center | center bottom 等价于 50% 100%bottom right | right bottom 等价于 100% 100%*&#x2F;.type.both.clock .inner::before &#123;    transform-origin: top center;    -webkit-transform-origin: top center;&#125;.type.both.clock .inner::after &#123;    transform-origin: bottom center;    -webkit-transform-origin: bottom center;&#125;.type.both.clock::before &#123;    transform-origin: right center;    -webkit-transform-origin: right center;&#125;.type.both.clock::after &#123;    transform-origin: left center;    -webkit-transform-origin: left center;&#125;.type.both.clock:hover .inner::before &#123;    transform-origin: bottom center;    -webkit-transform-origin: bottom center;&#125;.type.both.clock:hover .inner::after &#123;    transform-origin: top center;    -webkit-transform-origin: top center;&#125;.type.both.clock:hover::before &#123;    transform-origin: left center;    -webkit-transform-origin: left center;&#125;.type.both.clock:hover::after &#123;    transform-origin: right center;    -webkit-transform-origin: right center;&#125;.row &#123;    &#x2F;* padding: 0.5em 1em 0.65em; *&#x2F;    width: 50px;    height: 20px;&#125;.type &#123;    padding: 0.5em 1em 0.5em;    &#x2F;* margin: 0 10px; *&#x2F;    width: 22px;    height: 20px;&#125;</code></pre><p>如果不设置<code>transform-origin</code>属性，将会变为这种形式</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-6.gif'><p>css</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">.type &#123;    position: relative;    &#x2F;* font-size: 1em; *&#x2F;    &#x2F;* 不加relative会显示全屏划线 *&#x2F;&#125;.type .inner &#123;    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;&#125;&#x2F;* 如果说只要上下或者左右划线动画，可以不用加.inner标签，如果需要四条边，则需要加上.inner标签的before和after，并设置相关属性 *&#x2F;.type::before, .type::after, .type .inner::before, .type .inner::after&#x2F;* 这里有个一定要设置四个对象，一个对象对应一条边，before对应左和上，after对应右和下 *&#x2F;    &#123;    position: absolute;    content: &#39;&#39;;    display: block;    background: lightskyblue;    -webkit-transition: -webkit-transform 1s;    transition: -webkit-transform 1s;    transition: transform 1s;    transition: transform 1s, -webkit-transform 1s;&#125;.type.both::before, .type.both::after &#123;    left: 0;    width: 100%;    height: 2px;    -webkit-transform: scaleX(0);    transform: scaleX(0);&#125;.type.both .inner::after, .type.both .inner::before &#123;    top: 0;    width: 2px;    height: 100%;    -webkit-transform: scaleY(0);    transform: scaleY(0);&#125;.type.both .inner::before &#123;    left: 0;&#125;.type.both .inner::after &#123;    right: 0;&#125;.type.both .inner:hover::before, .type.both .inner:hover::after &#123;    transform: scaleY(1);    -webkit-transform: scaleY(1);&#125;.type.both::before &#123;    top: 0;&#125;.type.both::after &#123;    bottom: 0;&#125;.type.both:hover::before, .type.both:hover::after &#123;    transform: scaleX(1);    -webkit-transform: scaleX(1);&#125;.type.both:hover .inner::before, .type.both:hover .inner::after &#123;    transform: scaleY(1);    -webkit-transform: scaleY(1);&#125;.row &#123;    &#x2F;* padding: 0.5em 1em 0.65em; *&#x2F;    width: 50px;    height: 20px;&#125;.type &#123;    padding: 0.5em 1em 0.5em;    &#x2F;* margin: 0 10px; *&#x2F;    width: 22px;    height: 20px;&#125;</code></pre><h3 id="其他总结"><a href="#其他总结" class="headerlink" title="其他总结"></a>其他总结</h3><blockquote><ul><li>一个div里套了多个div，如果浏览器在低分辨率下，子div换行，除了检查子div有没有设置<code>display: inline-block;</code>，还要看看父div有没有设置具体宽度</li><li>如果很多时候如果样式的效果和图片不符，不妨检查下div的相关css参数，如长宽、<code>display</code> ，<code>position</code>等</li><li>浏览器f12里的element一栏里可对css进行实时调试</li><li><code>transform-origin</code>的方向，决定了动画线条的移动方向，在设置参数时自己在脑里演示一遍</li></ul></blockquote><blockquote><p>参考链接</p><p><a href="https://blog.csdn.net/llll789789/article/details/98383686">https://blog.csdn.net/llll789789/article/details/98383686</a></p><p><a href="https://www.jq22.com/yanshi20783">https://www.jq22.com/yanshi20783</a></p></blockquote>]]></content>
    
    
    <summary type="html">一些css动画的整理</summary>
    
    
    
    <category term="FrontEnd" scheme="https://jaydenchang.top/categories/FrontEnd/"/>
    
    
    <category term="html" scheme="https://jaydenchang.top/tags/html/"/>
    
    <category term="css" scheme="https://jaydenchang.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js轮播图改进版</title>
    <link href="https://jaydenchang.top/post/0x0017.html"/>
    <id>https://jaydenchang.top/post/0x0017.html</id>
    <published>2021-06-20T16:00:00.000Z</published>
    <updated>2021-12-11T05:57:50.061Z</updated>
    
    <content type="html"><![CDATA[<p>在肝前端大作业时，产生了使用轮播图的想法，翻阅了之前自己发过的一篇帖子，发现完全不能满足现在的需求，发现csdn上一篇帖子的代码写的不错，于是摘录下来学习</p><blockquote><p>实现的效果：</p><ul><li>自动播放</li><li>鼠标停留时停止播放，显示左右切换</li><li>点击左右切换、下方圆形可以手动切换</li><li>图片无缝切换，首位切换无违和感</li></ul></blockquote><p>采用胶片播放方式来切换图片</p><img src='https://jaydenchang.gitee.io/images/images/0x0017-2.gif'><p>经过css修饰后</p><img src='https://jaydenchang.gitee.io/images/images/0x0017-1.gif'><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;box&quot;&gt;        &lt;div id&#x3D;&quot;slider&quot;&gt;            &lt;ul class&#x3D;&quot;slieder-item-container&quot;&gt;                &lt;li&gt;                    &lt;a href&#x3D;&quot;#&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;index1.jpg&quot; &#x2F;&gt;&lt;&#x2F;a&gt;                &lt;&#x2F;li&gt;                &lt;li&gt;                    &lt;a href&#x3D;&quot;#&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;index2.jpg&quot; &#x2F;&gt;&lt;&#x2F;a&gt;                &lt;&#x2F;li&gt;                &lt;li&gt;                    &lt;a href&#x3D;&quot;#&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;index3.jpg&quot; &#x2F;&gt;&lt;&#x2F;a&gt;                &lt;&#x2F;li&gt;            &lt;&#x2F;ul&gt;            &lt;div class&#x3D;&quot;arrow-container&quot;&gt;                &lt;span class&#x3D;&quot;left-arrow&quot;&gt;&lt;&lt;&#x2F;span&gt;                &lt;span class&#x3D;&quot;right-arrow&quot;&gt;&gt;&lt;&#x2F;span&gt;                &lt;!-- 这个是左右箭头，用于切换图片 --&gt;            &lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;indicator-container&quot;&gt;                &lt;span class&#x3D;&quot;indicator active&quot;&gt;&lt;&#x2F;span&gt;                &lt;span class&#x3D;&quot;indicator&quot;&gt;&lt;&#x2F;span&gt;                &lt;span class&#x3D;&quot;indicator&quot;&gt;&lt;&#x2F;span&gt;                &lt;!-- 这个是图片下方的小圆点，定位第几张图 --&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;</code></pre><h4 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">#slider,#slider ul,#slider ul li a &#123;    width: 800px;    height: 400px;    margin: 0;    padding: 0;&#125;#slider &#123;    position: absolute;    &#x2F;* position: relative; *&#x2F;    border: 2px solid black;    &#x2F;*padding: 3px;*&#x2F;    margin: 10px 0 0 10px;    &#x2F;* z-index: 1; *&#x2F;    overflow: hidden;    &#x2F;* 隐藏显示区域外的图片 *&#x2F;    -webkit-user-select: none;    -moz-user-select: none;    -ms-user-select: none;    user-select: none;&#125;#slider ul &#123;    position: absolute;    list-style-type: none;    width: 6000px;    &#x2F;* 设置图片列表的长度 *&#x2F;    &#x2F;*transition-duration: 0.3s;*&#x2F;&#125;#slider li &#123;    float: left;&#125;#slider a &#123;    &#x2F;* display: inline-block; *&#x2F;    display: block;&#125;img &#123;    width: 100%;    height: 100%;&#125;#slider:hover .arrow-container &#123;    display: block;&#125;.arrow-container &#123;    position: absolute;    width: 100%;    height: 50px;    top: 50%;    margin-top: -25px;    display: none;&#125;&#x2F;* 箭头的样式设计 *&#x2F;.arrow-container span &#123;    position: absolute;    width: 50px;    height: 50px;    font-size: 40px;    &#x2F;*display: inline-block;*&#x2F;    text-align: center;    line-height: 50px;    background: rgba(0, 0, 0, 0.2);    color: white;&#125;.left-arrow &#123;    left: 0px;    cursor: pointer;&#125;.right-arrow &#123;    right: 0px;    cursor: pointer;&#125;&#x2F;* 小圆点的样式设计 *&#x2F;.indicator-container &#123;    position: absolute;    width: 150px;    height: 30px;    line-height: 30px;    bottom: 0;    left: 50%;    margin-left: -75px;    text-align: center;&#125;.indicator &#123;    display: inline-block;    width: 15px;    height: 15px;    border-radius: 100%;    background: white;    cursor: pointer;&#125;.indicator.active &#123;    background: lightskyblue;&#125;</code></pre><h4 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">var autoplay &#x3D; true;var autoplay_Delay &#x3D; 2000; &#x2F;&#x2F; msvar autoplayId;var intervalId;var slider;var slider_item_container;var slider_items;var indicator_container;var slider_item_width;var curIndex &#x3D; 0;window.onload &#x3D; function() &#123;    initElement();    initEvent();    if (autoplay) &#123;        startAnimation(slider_item_container);    &#125;&#125;&#x2F;&#x2F; 初始化元素function initElement() &#123;    slider &#x3D; document.getElementById(&quot;slider&quot;);    slider_items &#x3D; slider.getElementsByTagName(&quot;li&quot;);    slider_item_container &#x3D; slider.getElementsByClassName(&quot;slieder-item-container&quot;)[0];    indicator_container &#x3D; slider.getElementsByClassName(&quot;indicator-container&quot;)[0];        var firstItem &#x3D; slider_items[0].cloneNode(true);    slider_item_container.appendChild(firstItem);        slider_item_width &#x3D; slider_items[0].offsetWidth;&#125;&#x2F;&#x2F; 初始化相关事件function initEvent() &#123;    slider.addEventListener(&quot;mouseover&quot;, function () &#123;        clearTimeout(autoplayId);        autoplay &#x3D; false;    &#125;);    slider.addEventListener(&quot;mouseout&quot;, function () &#123;        autoplay &#x3D; true;        startAnimation(slider_item_container);    &#125;);        var indicators &#x3D; indicator_container.children;    for (var i &#x3D; 0; i &lt; indicators.length; i++) &#123;        indicators[i].setAttribute(&quot;index&quot;, i);        indicators[i].addEventListener(&quot;click&quot;, function () &#123;            var index &#x3D; parseInt(this.getAttribute(&quot;index&quot;));            next(index);        &#125;);    &#125;        var left_arrow &#x3D; slider.getElementsByClassName(&quot;left-arrow&quot;)[0];    var right_arrow &#x3D; slider.getElementsByClassName(&quot;right-arrow&quot;)[0];    left_arrow.addEventListener(&quot;click&quot;, function () &#123;        prev();    &#125;);    right_arrow.addEventListener(&quot;click&quot;, function () &#123;        next();    &#125;);&#125;&#x2F;&#x2F; 动画效果，传入的形参未要移动的元素以及移动的目标值&#x2F;&#x2F; 默认每10ms移动10px，手动翻页时，移动事件缩短，每次移动step值增大function animate(element, target) &#123;    var step &#x3D; 10;    var time &#x3D; 10;    var gap &#x3D; (Math.abs(target - element.offsetLeft) &#x2F; slider_item_width);    if (gap &gt; 1) &#123;        step &#x3D; step * gap;        time &#x3D; time &#x2F; gap;    &#125;    if (element) &#123;        step &#x3D; (element.offsetLeft &gt; target) ? -step : step;        clearInterval(intervalId);        setCurrentActiveIndicator(curIndex);        intervalId &#x3D; setInterval(function () &#123;            if ((step &lt; 0) &amp;&amp; (Math.abs(element.offsetLeft + step) &lt; Math.abs(target))) &#123;                element.style.left &#x3D; element.offsetLeft + step + &quot;px&quot;;            &#125; else &#123;                if (Math.abs(target - element.offsetLeft) &gt; Math.abs(step)) &#123;                    element.style.left &#x3D; element.offsetLeft + step + &quot;px&quot;;                &#125; else &#123;                    clearInterval(intervalId);                    intervalId &#x3D; -1;                    element.style.left &#x3D; target + &quot;px&quot;;                    if (autoplay) &#123;                        startAnimation(element);                    &#125;                &#125;            &#125;        &#125;, time);    &#125;&#125;&#x2F;*&#x2F; 左右翻页，改变轮播图的left值，改变当前显示的图片，再进行翻页动作，使用户感受不到过明显的跳转变化，*&#x2F;function prev() &#123;    var element &#x3D; slider_item_container;    var li &#x3D; element.children;    curIndex &#x3D; curIndex - 1;    if (curIndex &lt; 0) &#123;        element.style.left &#x3D; -((li.length-1)*slider_item_width) + &quot;px&quot;;        curIndex &#x3D; li.length-2;    &#125;    animate(element, -(curIndex*slider_item_width));&#125;&#x2F;&#x2F; 点击小圆点，也就是单词调用next()，但需要将要跳转的下标值传入function next(nextIndex) &#123;    var element &#x3D; slider_item_container;    var li &#x3D; element.children;    if ((nextIndex !&#x3D; null) &amp;&amp; (typeof(nextIndex) !&#x3D; &quot;undefined&quot;)) &#123;        curIndex &#x3D; nextIndex;    &#125; else &#123;        curIndex &#x3D; curIndex + 1;        if (curIndex &gt; (li.length-1)) &#123;            element.style.left &#x3D; 0 + &quot;px&quot;;            curIndex &#x3D; 1;        &#125;    &#125;    animate(element, -(curIndex*slider_item_width));&#125;&#x2F;&#x2F; 自动播放，每次轮播图移动到目标位置后，持续调用startAnimation()，内部也是调用next()function startAnimation(element) &#123;    if (autoplayId) &#123;        clearTimeout(autoplayId);    &#125;    autoplayId &#x3D; setTimeout(function () &#123;        next();    &#125;, autoplay_Delay);&#125;function setCurrentActiveIndicator(index) &#123;    var indicators &#x3D; indicator_container.children;    if (index &#x3D;&#x3D; indicators.length) &#123;        index &#x3D; 0;    &#125;    for (var i &#x3D; 0; i &lt; indicators.length; i++) &#123;        if (i &#x3D;&#x3D; index) &#123;            indicators[i].className &#x3D; &quot;indicator active&quot;;        &#125; else &#123;            indicators[i].className &#x3D; &quot;indicator&quot;;        &#125;        &#x2F;&#x2F; 判断当前是第几张图并对小圆点加颜色    &#125;&#125;</code></pre><blockquote><p>总结以上一些小细节</p><ul><li>span设置宽高无效，但设置<code>position: absolute;</code>或<code>display: inline-block;</code>就有效了</li><li>子元素设置了<code>float: left</code>，父元素的<code>text-align</code>就失效了</li><li>圆形<code>border-radius: 50%;</code></li><li>文字上下居中：<code>line-height</code>设置和<code>height</code>一样的值</li><li>水平文字居中<code>text-align: center;</code></li></ul></blockquote><p><a href='https://blog.csdn.net/u013347241/article/details/107054441/'>JS实现无缝切换轮播图(自动+手动)-f清风q的博客</a></p>]]></content>
    
    
    <summary type="html">实现一个基于JavaScript的轮播图效果</summary>
    
    
    
    <category term="FrontEnd" scheme="https://jaydenchang.top/categories/FrontEnd/"/>
    
    
    <category term="html" scheme="https://jaydenchang.top/tags/html/"/>
    
    <category term="JavaScript" scheme="https://jaydenchang.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>网页的注册、登录、拦截</title>
    <link href="https://jaydenchang.top/post/0x0016.html"/>
    <id>https://jaydenchang.top/post/0x0016.html</id>
    <published>2021-06-19T16:00:00.000Z</published>
    <updated>2021-12-11T06:07:09.102Z</updated>
    
    <content type="html"><![CDATA[<p>本次作业是简单实现网页的注册、登录、拦截</p><h3 id="注册部分"><a href="#注册部分" class="headerlink" title="注册部分"></a>注册部分</h3><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;reg.css&quot;&gt;    &lt;script src&#x3D;&quot;fun.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;&#x2F;head&gt;&lt;body&gt;    &lt;table align&#x3D;&quot;center&quot; cellpadding&#x3D;&quot;5px&quot;&gt;        &lt;tr&gt;            &lt;td&gt;&amp;nbsp;&lt;&#x2F;td&gt;            &lt;td align&#x3D;&quot;left&quot;&gt;register&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td align&#x3D;&quot;right&quot;&gt;username:&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; autocomplete&#x3D;&quot;off&quot; placeholder&#x3D;&quot;enter your name&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td align&#x3D;&quot;right&quot;&gt;password&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; placeholder&#x3D;&quot;enter your password&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td align&#x3D;&quot;right&quot;&gt;confirm password&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;repwd&quot; placeholder&#x3D;&quot;confirm your password&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;&amp;nbsp;&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;register&quot; id&#x3D;&quot;register&quot; onclick&#x3D;&quot;reg()&quot;&gt;                &lt;a href&#x3D;&quot;login.html&quot;&gt;login&lt;&#x2F;a&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;reg.css&quot;&gt;    &lt;script src&#x3D;&quot;fun.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;&#x2F;head&gt;&lt;body&gt;    &lt;table align&#x3D;&quot;center&quot; cellpadding&#x3D;&quot;5px&quot;&gt;        &lt;tr&gt;            &lt;td&gt;&amp;nbsp;&lt;&#x2F;td&gt;            &lt;td align&#x3D;&quot;left&quot;&gt;register&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td align&#x3D;&quot;right&quot;&gt;username:&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; autocomplete&#x3D;&quot;off&quot; placeholder&#x3D;&quot;enter your name&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td align&#x3D;&quot;right&quot;&gt;password&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; placeholder&#x3D;&quot;enter your password&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td align&#x3D;&quot;right&quot;&gt;confirm password&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;repwd&quot; placeholder&#x3D;&quot;confirm your password&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;&amp;nbsp;&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;register&quot; id&#x3D;&quot;register&quot; onclick&#x3D;&quot;reg()&quot;&gt;                &lt;a href&#x3D;&quot;login.html&quot;&gt;login&lt;&#x2F;a&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">*&#123;    font-size: 18px;&#125;table&#123;    margin-top: 150px;&#125;tr&#123;    height: 50px;&#125;a&#123;    text-decoration: none;&#125;#register&#123;    background-color: gray;    border-radius: 10px;    box-shadow: 1px 1px 2px 2px #232;&#125;#username&#123;    background-image: url(img&#x2F;user.JPG);    background-repeat: no-repeat;    background-position-x: 5px;    background-position-y: 5px;    &#x2F;* 设置背景图,也就是那个用户名头像的位置 *&#x2F;    height: 30px;    padding-left: 35px;    border: 1px solid gray;    outline: none;&#125;#username:hover&#123;    border: 1px solid purple;&#125;#password,#repwd&#123;    background-image: url(img&#x2F;password.JPG);    background-repeat: no-repeat;    background-position-x: 5px;    background-position-y: 5px;    height: 30px;    padding-left: 35px;    border: 1px solid gray;    outline: none;&#125;#password:hover,#repwd:hover&#123;    border: 1px solid purple;&#125;</code></pre><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function reg() &#123;    var username &#x3D; document.getElementById(&quot;username&quot;).value;    var pwd &#x3D; document.getElementById(&quot;password&quot;).value;    var repwd &#x3D; document.getElementById(&quot;repwd&quot;).value;    if (username &#x3D;&#x3D; &#39;&#39;) &#123;        alert(&quot;username can&#39;t be empty&quot;);        return false;    &#125;    if (pwd !&#x3D; repwd) &#123;        alert(&quot;passwords aren&#39;t the same&quot;);        return false;    &#125;    if (pwd &#x3D;&#x3D; &#39;&#39; || repwd &#x3D;&#x3D; &#39;&#39;) &#123;        alert(&quot;password can&#39;t be empty&quot;);        return false;    &#125;    localStorage.setItem(&quot;username&quot;, username);    localStorage.setItem(&quot;password&quot;, pwd);    &#x2F;&#x2F; 在浏览器本地添加数据    alert(&quot;register successful&quot;);    window.location.href &#x3D; &quot;login.html&quot;;    &#x2F;&#x2F; 跳转到指定界面&#125;</code></pre><h3 id="登录部分"><a href="#登录部分" class="headerlink" title="登录部分"></a>登录部分</h3><h4 id="html-1"><a href="#html-1" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;login.css&quot;&gt;    &lt;script src&#x3D;&quot;fun.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;&#x2F;head&gt;&lt;body&gt;    &lt;table align&#x3D;&quot;center&quot; cellpadding&#x3D;&quot;5px&quot;&gt;        &lt;tr&gt;            &lt;td&gt;&amp;nbsp;&lt;&#x2F;td&gt;            &lt;td align&#x3D;&quot;left&quot;&gt;login&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td align&#x3D;&quot;right&quot;&gt;username:&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; autocomplete&#x3D;&quot;off&quot; placeholder&#x3D;&quot;enter your name&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td align&#x3D;&quot;left&quot;&gt;password&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; placeholder&#x3D;&quot;enter your password&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;&amp;nbsp;&lt;&#x2F;td&gt;            &lt;td&gt;                &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;login&quot; id&#x3D;&quot;login&quot; onclick&#x3D;&quot;login()&quot;&gt;&amp;nbsp;                &lt;a href&#x3D;&quot;reg.html&quot;&gt;register&lt;&#x2F;a&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">*&#123;    font-size: 18px;&#125;table&#123;    margin-top: 150px;&#125;tr&#123;    height: 50px;&#125;a&#123;    text-decoration: none;&#125;#login&#123;    background-color: gray;    border-radius: 10px;    box-shadow: 1px 1px 2px 2px #232;&#125;#username&#123;    background-image: url(img&#x2F;user.JPG);    background-repeat: no-repeat;    background-position-x: 5px;    background-position-y: 5px;    height: 30px;    padding-left: 35px;    border: 1px solid gray;    outline: none;&#125;#username:hover&#123;    border: 1px solid purple;&#125;#password&#123;    background-image: url(img&#x2F;password.JPG);    background-repeat: no-repeat;    background-position-x: 5px;    background-position-y: 5px;    height: 30px;    padding-left: 35px;    border: 1px solid gray;    outline: none;&#125;#password:hover&#123;    border: 1px solid purple;&#125;</code></pre><h4 id="js-1"><a href="#js-1" class="headerlink" title="js"></a>js</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function login() &#123;    var username &#x3D; document.getElementById(&quot;username&quot;).value;    var pwd &#x3D; document.getElementById(&quot;password&quot;).value;    if (username &#x3D;&#x3D; &#39;&#39;) &#123;        alert(&quot;username can&#39;t be empty&quot;);        return false;    &#125;    if (pwd &#x3D;&#x3D; &#39;&#39;) &#123;        alert(&quot;password can&#39;t be empty&quot;);        return false;    &#125;    if (localStorage.getItem(&quot;username&quot;)) &#123;        var name &#x3D; localStorage.getItem(&quot;username&quot;).toString();        var pass &#x3D; localStorage.getItem(&quot;password&quot;).toString();        &#x2F;&#x2F; 从本地数据库获取信息,判断是否存在相关信息        if (name &#x3D;&#x3D; username)            if (pwd &#x3D;&#x3D; pass) &#123;                sessionStorage.setItem(&quot;username&quot;, name);                &#x2F;&#x2F; 在临时数据库载入数据,用于临时性判断是否有登录过                alert(&quot;login success&quot;);                window.location.href &#x3D; &quot;index.html&quot;;                            &#125; else &#123;                alert(&quot;wrong password&quot;);            &#125;        else            alert(&quot;wrong username&quot;);    &#125; else &#123;        alert(&quot;username doesn&#39;t exist,please register first&quot;);            &#125;&#125;</code></pre><h3 id="拦截部分"><a href="#拦截部分" class="headerlink" title="拦截部分"></a>拦截部分</h3><h4 id="html-2"><a href="#html-2" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;script src&#x3D;&quot;fun.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body onload&#x3D;&quot;check()&quot;&gt;    &lt;!-- 直接在body部分添加check(),触发函数 --&gt;    &lt;div style&#x3D;&quot;margin: 0 auto;text-align: center;margin-top: 200px;font-size: 32px;&quot; &gt;welcome&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4 id="js-2"><a href="#js-2" class="headerlink" title="js"></a>js</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function check() &#123;    if (sessionStorage.getItem(&quot;username&quot;)) &#123;        alert(&quot;welcome:&quot;+sessionStorage.getItem(&quot;username&quot;).toString());    &#125; else &#123;        alert(&quot;please login first&quot;);        window.location.href &#x3D; &quot;login.html&quot;;    &#125;    &#x2F;&#x2F; 这个判断起到拦截的作用&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本次作业是简单实现网页的注册、登录、拦截&lt;/p&gt;
&lt;h3 id=&quot;注册部分&quot;&gt;&lt;a href=&quot;#注册部分&quot; class=&quot;headerlink&quot; title=&quot;注册部分&quot;&gt;&lt;/a&gt;注册部分&lt;/h3&gt;&lt;h4 id=&quot;html&quot;&gt;&lt;a href=&quot;#html&quot; class=&quot;headerlink&quot; title=&quot;html&quot;&gt;&lt;/a&gt;html&lt;/h4&gt;&lt;pre class=&quot;line-numbers language-html&quot; data-language=&quot;html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang&amp;#x3D;&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset&amp;#x3D;&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv&amp;#x3D;&amp;quot;X-UA-Compatible&amp;quot; content&amp;#x3D;&amp;quot;IE&amp;#x3D;edge&amp;quot;&amp;gt;
    &amp;lt;meta name&amp;#x3D;&amp;quot;viewport&amp;quot; content&amp;#x3D;&amp;quot;width&amp;#x3D;device-width, initial-scale&amp;#x3D;1.0&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;&amp;#x2F;title&amp;gt;
    &amp;lt;link rel&amp;#x3D;&amp;quot;stylesheet&amp;quot; href&amp;#x3D;&amp;quot;reg.css&amp;quot;&amp;gt;
    &amp;lt;script src&amp;#x3D;&amp;quot;fun.js&amp;quot;&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;    
&amp;lt;&amp;#x2F;head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;table align&amp;#x3D;&amp;quot;center&amp;quot; cellpadding&amp;#x3D;&amp;quot;5px&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;amp;nbsp;&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td align&amp;#x3D;&amp;quot;left&amp;quot;&amp;gt;register&amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td align&amp;#x3D;&amp;quot;right&amp;quot;&amp;gt;username:&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input type&amp;#x3D;&amp;quot;text&amp;quot; id&amp;#x3D;&amp;quot;username&amp;quot; autocomplete&amp;#x3D;&amp;quot;off&amp;quot; placeholder&amp;#x3D;&amp;quot;enter your name&amp;quot;&amp;gt;
            &amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td align&amp;#x3D;&amp;quot;right&amp;quot;&amp;gt;password&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input type&amp;#x3D;&amp;quot;password&amp;quot; id&amp;#x3D;&amp;quot;password&amp;quot; placeholder&amp;#x3D;&amp;quot;enter your password&amp;quot;&amp;gt;
            &amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td align&amp;#x3D;&amp;quot;right&amp;quot;&amp;gt;confirm password&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input type&amp;#x3D;&amp;quot;password&amp;quot; id&amp;#x3D;&amp;quot;repwd&amp;quot; placeholder&amp;#x3D;&amp;quot;confirm your password&amp;quot;&amp;gt;
            &amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;amp;nbsp;&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input type&amp;#x3D;&amp;quot;button&amp;quot; value&amp;#x3D;&amp;quot;register&amp;quot; id&amp;#x3D;&amp;quot;register&amp;quot; onclick&amp;#x3D;&amp;quot;reg()&amp;quot;&amp;gt;
                &amp;lt;a href&amp;#x3D;&amp;quot;login.html&amp;quot;&amp;gt;login&amp;lt;&amp;#x2F;a&amp;gt;
            &amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
    &amp;lt;&amp;#x2F;table&amp;gt;
&amp;lt;&amp;#x2F;body&amp;gt;
&amp;lt;&amp;#x2F;html&amp;gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang&amp;#x3D;&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset&amp;#x3D;&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv&amp;#x3D;&amp;quot;X-UA-Compatible&amp;quot; content&amp;#x3D;&amp;quot;IE&amp;#x3D;edge&amp;quot;&amp;gt;
    &amp;lt;meta name&amp;#x3D;&amp;quot;viewport&amp;quot; content&amp;#x3D;&amp;quot;width&amp;#x3D;device-width, initial-scale&amp;#x3D;1.0&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;&amp;#x2F;title&amp;gt;
    &amp;lt;link rel&amp;#x3D;&amp;quot;stylesheet&amp;quot; href&amp;#x3D;&amp;quot;reg.css&amp;quot;&amp;gt;
    &amp;lt;script src&amp;#x3D;&amp;quot;fun.js&amp;quot;&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;    
&amp;lt;&amp;#x2F;head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;table align&amp;#x3D;&amp;quot;center&amp;quot; cellpadding&amp;#x3D;&amp;quot;5px&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;amp;nbsp;&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td align&amp;#x3D;&amp;quot;left&amp;quot;&amp;gt;register&amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td align&amp;#x3D;&amp;quot;right&amp;quot;&amp;gt;username:&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input type&amp;#x3D;&amp;quot;text&amp;quot; id&amp;#x3D;&amp;quot;username&amp;quot; autocomplete&amp;#x3D;&amp;quot;off&amp;quot; placeholder&amp;#x3D;&amp;quot;enter your name&amp;quot;&amp;gt;
            &amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td align&amp;#x3D;&amp;quot;right&amp;quot;&amp;gt;password&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input type&amp;#x3D;&amp;quot;password&amp;quot; id&amp;#x3D;&amp;quot;password&amp;quot; placeholder&amp;#x3D;&amp;quot;enter your password&amp;quot;&amp;gt;
            &amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td align&amp;#x3D;&amp;quot;right&amp;quot;&amp;gt;confirm password&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input type&amp;#x3D;&amp;quot;password&amp;quot; id&amp;#x3D;&amp;quot;repwd&amp;quot; placeholder&amp;#x3D;&amp;quot;confirm your password&amp;quot;&amp;gt;
            &amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;amp;nbsp;&amp;lt;&amp;#x2F;td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input type&amp;#x3D;&amp;quot;button&amp;quot; value&amp;#x3D;&amp;quot;register&amp;quot; id&amp;#x3D;&amp;quot;register&amp;quot; onclick&amp;#x3D;&amp;quot;reg()&amp;quot;&amp;gt;
                &amp;lt;a href&amp;#x3D;&amp;quot;login.html&amp;quot;&amp;gt;login&amp;lt;&amp;#x2F;a&amp;gt;
            &amp;lt;&amp;#x2F;td&amp;gt;
        &amp;lt;&amp;#x2F;tr&amp;gt;
    &amp;lt;&amp;#x2F;table&amp;gt;
&amp;lt;&amp;#x2F;body&amp;gt;
&amp;lt;&amp;#x2F;html&amp;gt;&lt;/code&gt;&lt;/pre&gt;



&lt;h4 id=&quot;css&quot;&gt;&lt;a href=&quot;#css&quot; class=&quot;headerlink&quot; title=&quot;css&quot;&gt;&lt;/a&gt;css&lt;/h4&gt;&lt;pre class=&quot;line-numbers language-css&quot; data-language=&quot;css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;*&amp;#123;
    font-size: 18px;
&amp;#125;
table&amp;#123;
    margin-top: 150px;
&amp;#125;
tr&amp;#123;
    height: 50px;
&amp;#125;
a&amp;#123;
    text-decoration: none;
&amp;#125;
#register&amp;#123;
    background-color: gray;
    border-radius: 10px;
    box-shadow: 1px 1px 2px 2px #232;
&amp;#125;
#username&amp;#123;
    background-image: url(img&amp;#x2F;user.JPG);
    background-repeat: no-repeat;
    background-position-x: 5px;
    background-position-y: 5px;
    &amp;#x2F;* 设置背景图,也就是那个用户名头像的位置 *&amp;#x2F;
    height: 30px;
    padding-left: 35px;
    border: 1px solid gray;
    outline: none;
&amp;#125;
#username:hover&amp;#123;
    border: 1px solid purple;
&amp;#125;
#password,#repwd&amp;#123;
    background-image: url(img&amp;#x2F;password.JPG);
    background-repeat: no-repeat;
    background-position-x: 5px;
    background-position-y: 5px;
    height: 30px;
    padding-left: 35px;
    border: 1px solid gray;
    outline: none;
&amp;#125;
#password:hover,#repwd:hover&amp;#123;
    border: 1px solid purple;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;



&lt;h4 id=&quot;js&quot;&gt;&lt;a href=&quot;#js&quot; class=&quot;headerlink&quot; title=&quot;js&quot;&gt;&lt;/a&gt;js&lt;/h4&gt;&lt;pre class=&quot;line-numbers language-javascript&quot; data-language=&quot;javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function reg() &amp;#123;
    var username &amp;#x3D; document.getElementById(&amp;quot;username&amp;quot;).value;
    var pwd &amp;#x3D; document.getElementById(&amp;quot;password&amp;quot;).value;
    var repwd &amp;#x3D; document.getElementById(&amp;quot;repwd&amp;quot;).value;
    if (username &amp;#x3D;&amp;#x3D; &amp;#39;&amp;#39;) &amp;#123;
        alert(&amp;quot;username can&amp;#39;t be empty&amp;quot;);
        return false;
    &amp;#125;
    if (pwd !&amp;#x3D; repwd) &amp;#123;
        alert(&amp;quot;passwords aren&amp;#39;t the same&amp;quot;);
        return false;
    &amp;#125;
    if (pwd &amp;#x3D;&amp;#x3D; &amp;#39;&amp;#39; || repwd &amp;#x3D;&amp;#x3D; &amp;#39;&amp;#39;) &amp;#123;
        alert(&amp;quot;password can&amp;#39;t be empty&amp;quot;);
        return false;
    &amp;#125;
    localStorage.setItem(&amp;quot;username&amp;quot;, username);
    localStorage.setItem(&amp;quot;password&amp;quot;, pwd);
    &amp;#x2F;&amp;#x2F; 在浏览器本地添加数据
    alert(&amp;quot;register successful&amp;quot;);
    window.location.href &amp;#x3D; &amp;quot;login.html&amp;quot;;
    &amp;#x2F;&amp;#x2F; 跳转到指定界面
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;





&lt;h3 id=&quot;登录部分&quot;&gt;&lt;a href=&quot;#登录部分&quot; class=&quot;headerlink&quot; title=&quot;登录部分&quot;&gt;&lt;/a&gt;登录部分&lt;/h3&gt;&lt;h4 id=&quot;html-1&quot;&gt;&lt;a href=&quot;#html-1&quot; class=&quot;headerlink&quot; title=&quot;html&quot;&gt;&lt;/a&gt;html&lt;/h4&gt;</summary>
    
    
    
    <category term="FrontEnd" scheme="https://jaydenchang.top/categories/FrontEnd/"/>
    
    
    <category term="html" scheme="https://jaydenchang.top/tags/html/"/>
    
    <category term="JavaScript" scheme="https://jaydenchang.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>拖拽式页面的简单实现</title>
    <link href="https://jaydenchang.top/post/0x0015.html"/>
    <id>https://jaydenchang.top/post/0x0015.html</id>
    <published>2021-06-02T16:00:00.000Z</published>
    <updated>2021-12-11T05:58:51.849Z</updated>
    
    <content type="html"><![CDATA[<p>本次作业是实现一个拖拽式简易点餐系统</p><h3 id="html部分-实现逻辑的主要部分"><a href="#html部分-实现逻辑的主要部分" class="headerlink" title="html部分(实现逻辑的主要部分)"></a>html部分(实现逻辑的主要部分)</h3><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;exp.css&quot;&gt;    &lt;script src&#x3D;&quot;exp.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;center&gt;        &lt;div border&#x3D;&quot;1px solid grey&quot;&gt;            &lt;table border&#x3D;&quot;1px solid grey&quot; celllspacing&#x3D;&quot;0&quot; class&#x3D;&quot;style1&quot;&gt;                &lt;caption&gt;please select a dish and drag it to the proper position&lt;&#x2F;caption&gt;                &lt;tr class&#x3D;&quot;text1&quot;&gt;                    &lt;td&gt;                        &lt;p align&#x3D;&quot;center&quot;&gt;customer 1&lt;&#x2F;p&gt;                    &lt;&#x2F;td&gt;                    &lt;td&gt;                        &lt;p align&#x3D;&quot;center&quot;&gt;customer 2&lt;&#x2F;p&gt;                    &lt;&#x2F;td&gt;                    &lt;td&gt;                        &lt;p align&#x3D;&quot;center&quot;&gt;customer 3&lt;&#x2F;p&gt;                    &lt;&#x2F;td&gt;                &lt;&#x2F;tr&gt;                &lt;tr&gt;                    &lt;td width&#x3D;&quot;33%&quot; align&#x3D;&#39;center&#39; ondrop&#x3D;&quot;droplt(this,event)&quot; ondragenter&#x3D;&quot;return false&quot;                        ondragover&#x3D;&quot;return false&quot;&gt;                        &lt;span draggable&#x3D;&quot;true&quot; id&#x3D;&quot;A&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot;&gt;                            &lt;img src&#x3D;&quot;img&#x2F;1.JPG&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;&#x2F;span&gt;                    &lt;&#x2F;td&gt;                    &lt;td width&#x3D;&quot;33%&quot; align&#x3D;&quot;center&quot; ondrop&#x3D;&quot;droplt(this,event)&quot; ondragenter&#x3D;&quot;return false&quot;                        ondragover&#x3D;&quot;return false&quot;&gt;                        &lt;span draggable&#x3D;&quot;true&quot; id&#x3D;&quot;A&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot;&gt;                            &lt;img src&#x3D;&quot;img&#x2F;2.JPG&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;&#x2F;span&gt;                    &lt;&#x2F;td&gt;                    &lt;td width&#x3D;&quot;33%&quot; align&#x3D;&quot;center&quot; ondrop&#x3D;&quot;droplt(this,event)&quot; ondragenter&#x3D;&quot;return false&quot;                        ondragover&#x3D;&quot;return false&quot;&gt;                        &lt;span draggable&#x3D;&quot;true&quot; id&#x3D;&quot;C&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot;&gt;                            &lt;img src&#x3D;&quot;img&#x2F;3.JPG&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;&#x2F;span&gt;                    &lt;&#x2F;td&gt;                &lt;&#x2F;tr&gt;            &lt;&#x2F;table&gt;&lt;br&gt;&lt;br&gt;            &lt;table border&#x3D;&quot;1px solid grey&quot; cellspacing&#x3D;0 cellpadding&#x3D;2&gt;                &lt;tr &gt;                    &lt;td width&#x3D;&quot;80%&quot;  class&#x3D;&quot;style2&quot;&gt;                        &lt;p align&#x3D;&quot;center&quot;&gt;the dish can be selected&lt;&#x2F;p&gt;                    &lt;&#x2F;td&gt;                    &lt;td width&#x3D;&quot;20%&quot; class&#x3D;&quot;style3&quot;&gt;&lt;p align&#x3D;&#39;center&#39;&gt;delete&lt;&#x2F;p&gt;&lt;&#x2F;td&gt;                &lt;&#x2F;tr&gt;                &lt;tr width&#x3D;&quot;80%&quot;&gt;                    &lt;td class&#x3D;&quot;style2&quot; ondrop&#x3D;&quot;droplt(this,event)&quot; ondragenter&#x3D;&quot;return false&quot; ondragover&#x3D;&quot;return false&quot;&gt;                        &lt;img src&#x3D;&quot;img&#x2F;4.JPG&quot; id&#x3D;&quot;1&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;img src&#x3D;&quot;img&#x2F;5.JPG&quot; id&#x3D;&quot;2&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;img src&#x3D;&quot;img&#x2F;6.JPG&quot; id&#x3D;&quot;3&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;img src&#x3D;&quot;img&#x2F;7.JPG&quot; id&#x3D;&quot;4&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;img src&#x3D;&quot;img&#x2F;8.JPG&quot; id&#x3D;&quot;5&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;img src&#x3D;&quot;img&#x2F;9.JPG&quot; id&#x3D;&quot;6&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;img src&#x3D;&quot;img&#x2F;10.JPG&quot; id&#x3D;&quot;7&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot; draggable&#x3D;&quot;true&quot;&gt;                        &lt;img src&#x3D;&quot;img&#x2F;11.JPG&quot; id&#x3D;&quot;8&quot; ondragstart&#x3D;&quot;draglt(this,event)&quot; draggable&#x3D;&quot;true&quot;&gt;                    &lt;&#x2F;td&gt;                    &lt;td width&#x3D;&quot;20%&quot; class&#x3D;&quot;style3&quot;&gt;                        &lt;img src&#x3D;&quot;img&#x2F;12.JPG&quot; draggable&#x3D;&quot;false&quot; ondragenter&#x3D;&quot;return false&quot; ondragover&#x3D;&quot;return false&quot; ondrop&#x3D;&quot;trashlt(this,event)&quot;&gt;                    &lt;&#x2F;td&gt;                &lt;&#x2F;tr&gt;            &lt;&#x2F;table&gt;         &lt;&#x2F;div&gt;    &lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css">td&#123;    width: 150px;&#125;caption&#123;    border: 1px solid grey;&#125;img&#123;    margin: 0 auto;&#125;.style1 tr td&#123;    width: 220px;&#125;.text1 td p&#123;      background-color: lightgray;          margin-top: 1px;    margin-bottom: 1px;&#125;.style2&#123;    width: 550px;&#125;.style2 p&#123;    background-color: lightgray;    margin-top: 0px;    margin-bottom: 0px;&#125;.style3     &#123;    width: 120px;&#125;.style3 p&#123;    background-color: lightgray;    margin-top: 0px;    margin-bottom: 0px;&#125;</code></pre><h3 id="JavaScript部分"><a href="#JavaScript部分" class="headerlink" title="JavaScript部分"></a>JavaScript部分</h3><h4 id="section-1"><a href="#section-1" class="headerlink" title="section 1"></a>section 1</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function draglt(target, e) &#123;    e.dataTransfer.setData(&#39;SpanImg&#39;, target.id);&#125;function droplt(target, e) &#123;    var id &#x3D; e.dataTransfer.getData(&#39;SpanImg&#39;);    target.appendChild(document.getElementById(id));    e.preventDefault();&#125;function trashlt(target, e) &#123;    var id &#x3D; e.dataTransfer.getData(&#39;SpanImg&#39;);    removeElement(id);    e.preventDefault();&#125;function removeElement(id) &#123;    var d_node &#x3D; document.getElementById(id);    d_node.parentNode.removeChild(d_node);&#125;</code></pre><h4 id="section-2"><a href="#section-2" class="headerlink" title="section 2"></a>section 2</h4><p>js部分还有一种写法(当然，方法有很多种，这里列出我所见过的)</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;相应的，img标签部分函数也要更新&#x2F;&#x2F;&lt;img src&#x3D;&quot;x.jpg&quot; ondragenter&#x3D;&quot;enter()&quot; ondragover&#x3D;&quot;enter()&quot; ondrop&#x3D;&quot;getObj(this)&quot; ondragstart&#x3D;&quot;startDrag(this)&quot;&gt;&#x2F;&#x2F;实质上，ondragover ondragenter这两个可以设置为禁用，下面会提到var objImg;function startDrag(that)&#123;    objImg&#x3D;that;&#125;function enter()&#123;    e&#x3D;window.event;    e.preventDefault();&#125;function getObj(that)&#123;    that.appendChild(objImg);&#125;function delObj()&#123;    objImg.parentElement.removeChild(objImg);&#125;</code></pre><h3 id="几个要注意的点"><a href="#几个要注意的点" class="headerlink" title="几个要注意的点"></a>几个要注意的点</h3><ul><li>img或者img的父级标签要有id号，不然js部分不能捕获img的id</li><li>ondrop的函数，有两类，可选择的子选项和删除类(trash)</li><li>return false是阻止控件的默认行为，作业要求的是拖动到限定区域再释放，这时候就不需要在拖动过程中触发相关事件，所以返回false禁用相关函数</li></ul><p>最后的效果</p><img src="https://jaydenchang.gitee.io/images/images/0x0015.png">]]></content>
    
    
    <summary type="html">前端作业--拖拽点餐系统</summary>
    
    
    
    <category term="FrontEnd" scheme="https://jaydenchang.top/categories/FrontEnd/"/>
    
    
    <category term="html" scheme="https://jaydenchang.top/tags/html/"/>
    
    <category term="JavaScript" scheme="https://jaydenchang.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>模板类链表</title>
    <link href="https://jaydenchang.top/post/0x0014.html"/>
    <id>https://jaydenchang.top/post/0x0014.html</id>
    <published>2021-06-01T16:00:00.000Z</published>
    <updated>2021-12-11T05:59:43.099Z</updated>
    
    <content type="html"><![CDATA[<p>本次作业要求补写课本样例的链表模板</p><h4 id="node-h-节点类模板"><a href="#node-h-节点类模板" class="headerlink" title="node.h (节点类模板)"></a>node.h (节点类模板)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef __NODE_H_#define __NODE_H_ template&lt;class tt&gt;class node&#123;private :node&lt;tt&gt; * next; &#x2F;&#x2F;pointer to nextpublic :tt data;&#x2F;&#x2F; data spacenode(const tt&amp; data, node&lt;tt&gt; *next);void insertAfter(node&lt;tt&gt; *p);&#x2F;&#x2F;insert the same node after this nodenode&lt;tt&gt; * deleteAfter();&#x2F;&#x2F;delete the node after this node,return the addressnode&lt;tt&gt; * nextNode();&#x2F;&#x2F;get the address after this node&#125;; template &lt;class tt&gt;node&lt;tt&gt;::node(const tt&amp; data, node&lt;tt&gt; * next):data(data), next(next)&#123;&#125; template &lt;class tt&gt;void node&lt;tt&gt;::insertAfter(node&lt;tt&gt; *p)&#123;p-&gt;next &#x3D; next;next &#x3D; p;&#125;  template &lt;class tt&gt;node&lt;tt&gt; * node&lt;tt&gt;::deleteAfter()&#123;node&lt;tt&gt; * tempPtr &#x3D; next;if(next &#x3D;&#x3D; 0)return 0;next &#x3D; tempPtr-&gt;next;return tempPtr;&#125; template &lt;class tt&gt;node&lt;tt&gt; * node&lt;tt&gt;::nextNode()&#123;return next;&#125; #endif</code></pre><h4 id="link-h-链表类模板"><a href="#link-h-链表类模板" class="headerlink" title="link.h (链表类模板)"></a>link.h (链表类模板)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef _LINK_H_#define _LINK_H_#include &lt;bits&#x2F;stdc++.h&gt;#include &quot;node.h&quot;template &lt;class tt&gt;class link&#123;private:    node&lt;tt&gt; *front, *rear;&#x2F;&#x2F;head and the end of the list    node&lt;tt&gt; *prePtr, *currPtr;&#x2F;&#x2F;record the current pointer    int size, position;&#x2F;&#x2F;the num of the element and record the list    node&lt;tt&gt; *newNode(const tt &amp;item, node&lt;tt&gt; *preNext);    &#x2F;&#x2F;create new node     void freeNode(node&lt;tt&gt; *p);&#x2F;&#x2F;free node    void copy(const link&lt;tt&gt; &amp;l);    &#x2F;&#x2F;copy the list L to the current listpublic:    link();    link(const link&lt;tt&gt; &amp;l);    ~link();    link&lt;tt&gt; &amp;operator&#x3D;(const link&lt;tt&gt; &amp;l);    int getSize() const &#123; return size; &#125;    bool isEmpty() const &#123; return size &#x3D;&#x3D; 0; &#125;    void reset(int pos);    &#x2F;&#x2F;reset the pointer to special position    void next();    bool endOfList() const &#x2F;*&#123; return position &#x3D;&#x3D; size; &#125;*&#x2F;    &#123;        &#x2F;&#x2F; std::cout &lt;&lt; &quot;the last data: &quot; &lt;&lt; data() &lt;&lt; std::endl;        return position &#x3D;&#x3D; size;    &#125;    &#x2F;&#x2F;judge if the pointer move the end of the list    bool judgeEnd() const &#123; return position &#x3D;&#x3D; size - 1; &#125;    &#x2F;&#x2F;judge if the pointer move the end of the list    &#x2F;*this is different from the former, this function is used to judge if the     current data is the last data, the former function is to judge if pointer     move the rear position*&#x2F;    int currentPostion() const &#123; return position; &#125;    &#x2F;&#x2F;pointer return to current position    void insertFront(tt &amp;item);    &#x2F;&#x2F;insert at the head of the list    void insertRear(tt &amp;item);    &#x2F;&#x2F;insert at the end of the list    void insertAt(tt &amp;item);    &#x2F;&#x2F;insert before the current node    void insertAfter(tt &amp;item);    &#x2F;&#x2F;insert after the current node    tt deleteFront();&#x2F;&#x2F;delete head node    void deleteCurrent();&#x2F;&#x2F;delete current node    tt &amp;data() &#123; return currPtr-&gt;data; &#125;    &#x2F;&#x2F;return current data of the member    const tt &amp;data() const &#123; return currPtr-&gt;data; &#125;    &#x2F;&#x2F;return current data of the member (const)    void clear();    &#x2F;&#x2F;clear the list,free all the memory space&#125;;template &lt;class tt&gt;void link&lt;tt&gt;::freeNode(node&lt;tt&gt; *p)&#123;    delete p;&#125;template &lt;class tt&gt;void link&lt;tt&gt;::copy(const link&lt;tt&gt; &amp;l)&#123;    front &#x3D; l.front;    rear &#x3D; l.rear;    currPtr &#x3D; l.currPtr;    prePtr &#x3D; l.prePtr;    size &#x3D; l.size;    position &#x3D; l.position;&#125;template &lt;class tt&gt;link&lt;tt&gt;::link()&#123;    front &#x3D; NULL;    rear &#x3D; NULL;    currPtr &#x3D; NULL;    prePtr &#x3D; NULL;    size &#x3D; 0;    position &#x3D; 0;&#125;template &lt;class tt&gt;link&lt;tt&gt;::link(const link&lt;tt&gt; &amp;l)&#123;    copy(l);&#125;template &lt;class tt&gt;link&lt;tt&gt;::~link()&#123;    clear();    delete prePtr;    delete currPtr;&#125;template &lt;class tt&gt;link&lt;tt&gt; &amp;link&lt;tt&gt;::operator&#x3D;(const link&lt;tt&gt; &amp;l)&#123;    copy(l);&#125;template &lt;class tt&gt;void link&lt;tt&gt;::reset(int pos)&#123;    if (pos &gt;&#x3D; 0 &amp;&amp; pos &lt;&#x3D; size)    &#123;        position &#x3D; 0;        currPtr &#x3D; front;        prePtr &#x3D; NULL;        while (pos--)            next();    &#125;    else    &#123;        position &#x3D; pos;        currPtr &#x3D; prePtr &#x3D; NULL;    &#125;&#125;template &lt;class tt&gt;void link&lt;tt&gt;::next()&#123;    ++position;    prePtr &#x3D; currPtr;    if (currPtr !&#x3D; NULL)        currPtr &#x3D; currPtr-&gt;nextNode();&#125;template &lt;class tt&gt;node&lt;tt&gt; *link&lt;tt&gt;::newNode(const tt &amp;item, node&lt;tt&gt; *preNext)&#123;    node&lt;tt&gt; *p &#x3D; new node&lt;tt&gt;(item, preNext);    assert(p !&#x3D; NULL);    return p;&#125;template &lt;class tt&gt;void link&lt;tt&gt;::insertFront(tt &amp;item)&#123;    front &#x3D; newNode(item, front);    if (isEmpty())        rear &#x3D; front;    ++size;    reset(++position);&#125;template &lt;class tt&gt;void link&lt;tt&gt;::insertRear(tt &amp;item)&#123;    node&lt;tt&gt; *p &#x3D; newNode(item,currPtr);    if (isEmpty())        front &#x3D; rear &#x3D; p;    else    &#123;        rear-&gt;insertAfter(p);        rear &#x3D; p;    &#125;    ++size;    reset(position);&#125;template &lt;class tt&gt;void link&lt;tt&gt;::insertAt(tt &amp;item)&#123;    if (currPtr !&#x3D; NULL)    &#123;        node&lt;tt&gt; *p &#x3D; newNode(item, currPtr);        if (prePtr !&#x3D; NULL)            prePtr-&gt;insertAfter(p);        else            front &#x3D; rear &#x3D; p;        ++size;        reset(++position);    &#125;&#125;template&lt;class tt&gt;void link&lt;tt&gt;::insertAfter(tt&amp;item)&#123;    if(currPtr !&#x3D; NULL)    &#123;        node&lt;tt&gt; *p &#x3D; newNode(item, currPtr-&gt;nextNode());        currPtr-&gt;insertAfter(p);        ++size;        reset(position);    &#125;    &#125;template&lt;class tt&gt;tt link&lt;tt&gt;::deleteFront()&#123;    assert(!isEmpty());    node&lt;tt&gt; *p &#x3D; front;    front &#x3D; front-&gt;nextNode();    if(--size &#x3D;&#x3D; 0)        front &#x3D; rear &#x3D; NULL;    reset(--position);    tt item &#x3D; p-&gt;data;    freeNode(p);    return item;&#125;template&lt;class tt&gt;void link&lt;tt&gt;::deleteCurrent()&#123;    node&lt;tt&gt; *tempPtr &#x3D; currPtr;    prePtr-&gt;deleteAfter();    delete currPtr;    currPtr &#x3D; prePtr;    size--;    &#x2F;*there may be error in here, I forgot to link the currPtr with the     prePtr, this lead to the data after this node can&#39;t be showed*&#x2F;&#125;template&lt;class tt&gt;void link&lt;tt&gt;::clear()&#123;    while(!isEmpty())        deleteFront();&#125;#endif</code></pre><h4 id="main-cpp-主函数"><a href="#main-cpp-主函数" class="headerlink" title="main.cpp(主函数)"></a>main.cpp(主函数)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; #include&lt;bits&#x2F;stdc++.h&gt;#include &quot;link.h&quot;using namespace std;int main()&#123;    link&lt;int&gt; list;    int n;    cin &gt;&gt; n;    for (int i &#x3D; 0; i &lt; n; i++)    &#123;        int x;        cin &gt;&gt; x;        list.insertRear(x);    &#125;    cout &lt;&lt; &quot;list:&quot;;    list.reset(0);    while (!list.endOfList())    &#123;        cout &lt;&lt; list.data() &lt;&lt; &#39; &#39;;        list.next();    &#125;    cout &lt;&lt; endl;    &#x2F;&#x2F;search    int temp;    list.reset(0);    cout &lt;&lt; &quot;enter the data that you wanna search: &quot;;    cin &gt;&gt; temp;    while (!list.endOfList())    &#123;        if (list.data() &#x3D;&#x3D; temp)        &#123;            cout &lt;&lt; &quot;the result: &quot; &lt;&lt; list.data() &lt;&lt; endl;                        break;        &#125;        else        &#123;                        if (list.judgeEnd())            &#123;                cout &lt;&lt; &quot;not found\n&quot;;                break;            &#125;            list.next();        &#125;    &#125;    &#x2F;&#x2F;delete    list.reset(0);    cout &lt;&lt; &quot;enter the data that you wanna remove: &quot;;    cin &gt;&gt; temp;    while (!list.endOfList())    &#123;        if (list.data() &#x3D;&#x3D; temp)        &#123;            list.deleteCurrent();            break;        &#125;        else        &#123;            if(list.judgeEnd())            &#123;                cout &lt;&lt; &quot;not found\n&quot;;                break;            &#125;            list.next();        &#125;    &#125;    &#x2F;&#x2F;output the linklist    cout &lt;&lt; &quot;list: &quot;;    list.reset(0);    while (!list.endOfList())    &#123;        cout &lt;&lt; list.data() &lt;&lt; &#39; &#39;;        list.next();    &#125;    cout &lt;&lt; endl;&#125;</code></pre>]]></content>
    
    
    <summary type="html">补写课本的链表模板(找csdn找了好久)</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
</feed>
