<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="https://jaydenchang.gitee.io/images/Jayden.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="https://jaydenchang.gitee.io/images/Jayden.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://jaydenchang.gitee.io/images/Jayden.jpg">
  <link rel="mask-icon" href="https://jaydenchang.gitee.io/images/Jayden.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jaydenchang.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"waline","storage":true,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="用七天实现一个类Gin的Web框架">
<meta property="og:type" content="article">
<meta property="og:title" content="七天用go实现一个web框架">
<meta property="og:url" content="https://jaydenchang.top/post/0x002F.html">
<meta property="og:site_name" content="Jayden&#39;s Blog">
<meta property="og:description" content="用七天实现一个类Gin的Web框架">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jaydenchang.gitee.io/images/images/0x002F/gee_day0_2.jpg">
<meta property="og:image" content="https://jaydenchang.gitee.io/images/images/0x002F/gee_day3_trie_tree.jpg">
<meta property="og:image" content="https://jaydenchang.gitee.io/images/images/0x002F/gee_day3_trie_tree_web.jpg">
<meta property="og:image" content="https://jaydenchang.gitee.io/images/images/0x002F/gee_day6.png">
<meta property="article:published_time" content="2022-08-06T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-30T09:15:50.827Z">
<meta property="article:author" content="Jayden Chang">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jaydenchang.gitee.io/images/images/0x002F/gee_day0_2.jpg">


<link rel="canonical" href="https://jaydenchang.top/post/0x002F.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://jaydenchang.top/post/0x002F.html","path":"/post/0x002F.html","title":"七天用go实现一个web框架"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>七天用go实现一个web框架 | Jayden's Blog</title>
  







<link rel="dns-prefetch" href="jayden-valine-vercel.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><link rel="alternate" href="/atom.xml" title="Jayden's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Jayden's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">14</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">7</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">52</span></a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day0.-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6"><span class="nav-text">day0. 设计一个框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E8%AF%B4%E6%98%8E"><span class="nav-text">框架说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day1.-http.handler"><span class="nav-text">day1. http.Handler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#base1"><span class="nav-text">base1</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%90%AF%E5%8A%A8web%E6%9C%8D%E5%8A%A1"><span class="nav-text">标准库启动Web服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0http.handler%E6%8E%A5%E5%8F%A3"><span class="nav-text">实现http.Handler接口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#base2"><span class="nav-text">base2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#base3"><span class="nav-text">base3</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#gee%E6%A1%86%E6%9E%B6%E7%9A%84%E9%9B%8F%E5%BD%A2"><span class="nav-text">Gee框架的雏形</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day2.-%E4%B8%8A%E4%B8%8B%E6%96%87-context"><span class="nav-text">day2. 上下文 Context</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1context"><span class="nav-text">设计Context</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-text">必要性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1router"><span class="nav-text">路由(Router)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E5%85%A5%E5%8F%A3"><span class="nav-text">框架入口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day3-%E5%89%8D%E7%BC%80%E6%A0%91%E8%B7%AF%E7%94%B1router"><span class="nav-text">day3 前缀树路由Router</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trie%E6%A0%91%E7%AE%80%E4%BB%8B"><span class="nav-text">Trie树简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trie%E6%A0%91%E5%AE%9E%E7%8E%B0"><span class="nav-text">Trie树实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#router"><span class="nav-text">Router</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#context%E4%B8%8Ehandle%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-text">Context与handle的变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8demo"><span class="nav-text">使用DEMO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#day3%E5%B0%8F%E7%BB%93"><span class="nav-text">day3小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day4.-%E5%88%86%E7%BB%84%E6%8E%A7%E5%88%B6group"><span class="nav-text">day4. 分组控制Group</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">分组的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8demo-1"><span class="nav-text">使用Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day5.-%E4%B8%AD%E9%97%B4%E4%BB%B6-middleware"><span class="nav-text">day5. 中间件 Middleware</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">中间件是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="nav-text">中间件设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8demo-2"><span class="nav-text">使用demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day6.-%E6%A8%A1%E6%9D%BF-html-template"><span class="nav-text">day6. 模板 (HTML Template)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93"><span class="nav-text">服务器渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6-serve-static-files"><span class="nav-text">静态文件 (Serve Static Files)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#html-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93"><span class="nav-text">HTML 模板渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8demo-3"><span class="nav-text">使用Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day7.-%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D-panic-recover"><span class="nav-text">day7. 错误恢复 (Panic Recover)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#panic"><span class="nav-text">panic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer"><span class="nav-text">defer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#recover"><span class="nav-text">recover</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gee%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">Gee的错误处理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8demo-4"><span class="nav-text">使用Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95"><span class="nav-text">一些想法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-text">参考链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jayden Chang"
      src="https://jaydenchang.gitee.io/images/Jayden.jpg">
  <p class="site-author-name" itemprop="name">Jayden Chang</p>
  <div class="site-description" itemprop="description">身在井隅，心向星光。眼中有诗，自在远方。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/JaydenChang" title="Github → https:&#x2F;&#x2F;github.com&#x2F;JaydenChang" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang44378@163.com" title="E-Mail → mailto:zhang44378@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/jaydenchang" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;jaydenchang" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/JaydenChang7" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;JaydenChang7" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/@jaydenchang7" title="YouTuBe → https:&#x2F;&#x2F;www.youtube.com&#x2F;@jaydenchang7" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTuBe</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/jaydenchang7" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;jaydenchang7" rel="noopener me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://500px.com.cn/jaydenchang" title="500px → https:&#x2F;&#x2F;500px.com.cn&#x2F;jaydenchang" rel="noopener me" target="_blank"><i class="fa-brands fa-500px fa-fw"></i>500px</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jaydenchang.top/post/0x002F.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://jaydenchang.gitee.io/images/Jayden.jpg">
      <meta itemprop="name" content="Jayden Chang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jayden's Blog">
      <meta itemprop="description" content="身在井隅，心向星光。眼中有诗，自在远方。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="七天用go实现一个web框架 | Jayden's Blog">
      <meta itemprop="description" content="用七天实现一个类Gin的Web框架">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          七天用go实现一个web框架
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-07T00:00:00+08:00">2022-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BackEnd/" itemprop="url" rel="index"><span itemprop="name">BackEnd</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline: </span>
  
    <a title="waline" href="/post/0x002F.html#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/post/0x002F.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>49k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>44 mins.</span>
    </span>
</div>

            <div class="post-description">用七天实现一个类Gin的Web框架</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><hr/>
<h3 id="前言">前言</h3>
<p>本文学习自<a target="_blank" rel="noopener" href="https://geetktutu.com">geektutu</a> , 大部分内容摘自 <a target="_blank" rel="noopener" href="https://geektutu.com/post/gee.html">7天用Go从零实现Web框架Gee教程 | 极客兔兔 (geektutu.com)</a>，并在此基础上稍加个人的学习历程和理解。</p>
<p>作者仓库地址：<a target="_blank" rel="noopener" href="https://github.com/geektutu/7days-golang">geektutu/7days-golang: 7 days golang programs from scratch (web framework Gee, distributed cache GeeCache, object relational mapping ORM framework GeeORM, rpc framework GeeRPC etc) 7天用Go动手写/从零实现系列 (github.com)</a></p>
<h3 id="day0.-设计一个框架">day0. 设计一个框架</h3>
<p>大部分时候 , 实现一个Web应用 , 第一反应是用哪个框架 , 在Golang中 , 新框架层出不穷 , 例如<code>Beego</code> , <code>Gin</code> , <code>Iris</code> 等 , 那为什么不用标准库 , 而必须使用框架呢 ? 在设计一个框架时 , 我们需要知道核心框架为我们解决了什么问题 , 只有明白这一点 , 才能想明白我们要在框架内实现什么功能。</p>
<p>刚好最近学院开展了一个软件实训课程 , 在五天之内搭好了一个Java游戏框架 , 基本框架搭好之后 , 只需要替换配置文档和游戏元素 , 就可以做出另一款新的游戏 , 当然 , 在理解这个框架的搭建思路的背后是异常痛苦的 (前后花了6天左右去看课程视频 , 各种修bug) , 在做出作品那一刻，虽然运行起来的会让人莫名想笑 , 心情舒畅，不过总算实现了代码和人一个能跑了bushi , 很敬佩游戏框架设计师的奇思妙想 <del>(脑洞)</del> 。</p>
<p>有点扯远了 , 我们先看看Golang标准库<code>net/http</code>如何处理一个请求。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
    &quot;net&#x2F;http&quot;
    &quot;fmt&quot;
)

func main() &#123;
    http.HandleFunc(&quot;&#x2F;&quot;, handler)
    http.HandleFunc(&quot;&#x2F;count&quot;, handler)
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))
&#125;

func handler(w http.ResponseWriter, r *http.Request) &#123;
    fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, r.URL.Path)
&#125;</code></pre>
<h5 id="基础知识">基础知识</h5>
<h6 id="interface">interface</h6>
<p>首先定义一个<code>Animal</code>的接口</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Animal interface &#123;
    Speak() string
&#125;</code></pre>
<p>golang中没有 implements 关键字，那么如何实现接口呢？</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Dog struct &#123;&#125;

func (d Dog) Speak() string &#123;
    return &quot;Woof!&quot;
&#125;

type Cat struct &#123;&#125;

func (c Cat) Speak() string &#123;
    return &quot;Meow!&quot;
&#125;
&#x2F;&#x2F; 只要实现了Speak()，就算是实现了Animal接口</code></pre>
<h6 id="interface-1">interface</h6>
<p>interface{} 类型，空接口，很容易和interface弄混。interface{} 是没有方法的接口。由于没有 implements 关键字，所以所有类型都至少实现了0个方法，所以 <strong>所有类型都实现了空接口</strong>。这意味着，如果在写一个函数以 interface{} 为参数，那么可以为该函数提供任何值。例如</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func DoSomething(v interface&#123;&#125;) &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>
<p>在DoSomething 内部，开始我也认为v时任意类型，但这是错误的，v 不是任意类型，它的静态类型是<code>interface&#123;&#125;</code>类，动态类型由传入的参数的类型决定，当然返回参数时，就不要返回<code>interface&#123;&#125;</code>类了。</p>
<p><code>interface&#123;&#125;</code>可以承载任意值，但不代表任意类型就可以承接空接口类型的值。当将值传递给DoSomething 函数时，golang将执行类型转换 (if necessary)，并将值转换为<code>interface&#123;&#125;</code>类型的值。</p>
<blockquote>
<p>题外话，<code>interface&#123;&#125;</code>动态类型慎用，特别是面对需求容易改动的项目，另外，一般不要对动态类型的值进行比较操作</p>
</blockquote>
<h6 id="http.responsewriter">http.ResponseWriter</h6>
<p>首先需要了解<code>HandleFunc</code>这个函数的一些信息，其声明如下。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;
    DefaultServeMux.HandleFunc(pattern, handler)
&#125;</code></pre>
<p>在main函数中，字符串部分容易理解，那handler呢，来看看它的参数的源码。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type ResponseWriter interface &#123;
    Header() Header
    Write([]byte) (int, error)
    WriteHeader(statusCode int)
&#125;</code></pre>
<p>还是不太清楚，再点击<code>Header</code>看看。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Header map[string][]string</code></pre>
<p>http.Header结构包含请求头信息，常见信息实例如下。</p>
<pre class="line-numbers language-none"><code class="language-none">Host: example.com
accept-encoding: gzip, deflate
Accept-Language: en-us
foo: Bar</code></pre>
<p>接下来看看<code>Write([]byte) (int, error)</code>，这是一个接口，实现通用的<code>io.Writer</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Writer interface &#123;
    Write(p []byte) (n int, err error)
    &#x2F;&#x2F; 这个byte其实是个切片,而Write方法在server.go里被重写了,具体先不贴代码,本身含有Fprintf方法,后文会用到
&#125;</code></pre>
<p>最后到<code>WriteHeader(statusCode int)</code>。</p>
<p><code>WriteHeader</code>这个方法名有点误导，并不是来设置响应头的，该方法支持传入一个整形数据表示响应状态码，不调用该方法的话，默认值是<code>200 OK</code>。</p>
<h6 id="http.request">http.Request</h6>
<p>直接看源码的声明。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Request struct &#123;
    Method string
    URL *url.URL
    Proto string   &#x2F;&#x2F;eg &quot;HTTP&#x2F;1.0&quot;
    ProtoMajor int  
    ProtoMinor int
    Header Header
    Body io.ReaderCloser
    GetBody func() (io.ReadCloser, error)
    ContentLength int64
    TransferEncoding []string
    Close bool
    Host string
    Form url.Values
    PostForm url.Values
    MultipartForm *multipart.Form
    Trailer Header
    RemoteAddr string
    RequestURI string
    TLS *tls.ConnectionState
    Cancel &lt;-chan struct&#123;&#125;
    Response *Response
    ctx context.Context
&#125;</code></pre>
<p>常见的Request报文段信息如下：</p>
<p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day0_2.jpg'></p>
<h6 id="http.listenandserve">http.ListenAndServe</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func ListenAndServe(addr string, handler Handler) error &#123;
    server :&#x3D; &amp;Server&#123;Addr: addr, Handler: handler&#125;
    return server.ListenAndServe()
&#125;</code></pre>
<p>在<code>ListenAndServe</code>中，再查看<code>Server</code>和<code>ListenAndServe()</code>的源码</p>
<blockquote>
<p>http.Server</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Server struct &#123;
	Addr string   &#x2F;&#x2F; 服务器的IP地址和端口信息
    Handler Handler  &#x2F;&#x2F; 请求处理函数的路由复用器
    ReadTimeout time.Duration
    WriteTimeout time.Duration
    MaxHeaderBytes int
    TLSConfig *tls.Config
    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)
    ConnState func(net.Conn, ConnState)
    ErrorLog *log.Logger
    disableKeepAlives int32
&#125;</code></pre>
<blockquote>
<p>http.ListenAndServe()</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (srv *Server) ListenAndServe() error &#123;
    if srv.shuttingDown() &#123;
        return ErrServerClosed  &#x2F;&#x2F; 如果Server已关闭，直接返回ErrServerClosed
    &#125;
    addr :&#x3D; srv.Addr
    if addr &#x3D;&#x3D; &quot;&quot; &#123;
        addr &#x3D; &quot;:http&quot;
    &#125;
    ln, err :&#x3D; net.Listen(&quot;tcp&quot;, addr) 
    if err !&#x3D; nil &#123;
        return err
    &#125;
    return srv.Serve(ln)
&#125;</code></pre>
<p>在本例中，传入了端口号和handler，如果不指定ip就用本机地址 (localhost)，如果不指定服务器地址信息，则默认以<code>:http</code>作为地址信息</p>
<h6 id="fmt.fprintf">fmt.Fprintf</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Fprintf(w io.Writer, format string, a ...any) (n int, err error) &#123;
    p :&#x3D; newPrinter()
    p.doPrintf(format, a)
    n, err &#x3D; w.Write(p.buf)
    p.free()
    return
&#125;</code></pre>
<h6 id="log.fatal">log.Fatal</h6>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Fatal(v ...any) &#123;
    std.Output(2, fmt.Sprint(v...))
    os.Exit(1)
&#125;</code></pre>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (l *Logger) Fatal(v ...any) &#123;
    l.Output(2, fmt.Sprint(v...))
    os.Exit(1)
&#125;</code></pre>
<p>在函数上面的定义，Fatal等价于<code>Print()</code>，执行完打印直接退出程序，之前通过<code>defer</code>设置延迟的函数不会被运行</p>
<h5 id="框架说明">框架说明</h5>
<p><code>net/http</code>提供了基础的Web功能 , 即监听端口 , 解析HTTP报文。一些Web开发中简单的需求并不支持，需要手工实现。</p>
<ul>
<li>动态路由 : 例如<code>hello/:name</code> , <code>hello/*</code>这类的规则</li>
<li>鉴权 (authentication) : 没有分组/统一鉴权的能力 , 需要在每个路由映射的handler中实现</li>
<li>模板 : 没有统一简化的HTML机制</li>
<li>...</li>
</ul>
<p>可以发现，当我们离开框架，使用基础库时，需要频繁手工处理的地方，就是框架的价值所在。</p>
<h3 id="day1.-http.handler">day1. http.Handler</h3>
<h4 id="base1">base1</h4>
<h5 id="标准库启动web服务">标准库启动Web服务</h5>
<p>Golang内置了<code>net/http</code>库 , 封装了HTTP网络编程的基础的接口 , 本次复刻的<code>Gee</code> Web框架便是基于<code>net/http</code>的 , 下面通过一个例子 , 简单介绍下这个库的使用。</p>
<blockquote>
<p>day1/base1/main.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net&#x2F;http&quot;
    &quot;log&quot;
)

func main() &#123;
    http.HandleFunc(&quot;&#x2F;&quot;, indexHandler)
    http.HandleFunc(&quot;&#x2F;hello&quot;, helloHandler)
    log.Fatal(http.ListenAndServe(&quot;:9999&quot;, nil))
&#125;

func indexHandler(w.http.ResponseWriter, req *http.Request) &#123;
    fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, req.URL.Path)
&#125;

func helloHandler(w http.ResponseWriter, req *http.Request) &#123;
    for k, v :&#x3D; range req.Header &#123;
        fmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\n&quot;, k, v)
    &#125;
&#125;</code></pre>
<p>在上面 , 设置了两个路由 , <code>/</code>和<code>/hello</code> , 分别绑定<code>indexHandler</code>和<code>helloHandler</code> , 根据不同的HTTP请求会调用不同的处理函数 , 访问<code>/</code> , 响应是<code>URL.Path=/</code> , 而<code>/hello</code>的相应则是请求头 (header)中键值对信息。</p>
<p>用curl工具测试 , 会得到以下结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;
URL.Path &#x3D; &quot;&#x2F;&quot;
$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;hello
Header[&quot;User-Agent&quot;]&#x3D;[&quot;curl&#x2F;7.68.0&quot;]
Header[&quot;Accept&quot;]&#x3D;[&quot;*&#x2F;*&quot;]
$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloWorld
URL.Path &#x3D; &quot;&#x2F;helloWorld&quot;</code></pre>
<p>main函数的最后一行 , 是来启动服务的 , 第一个是参数地址 , <code>:9999</code>表示在<code>9999</code>端口监听 , 而第二个参数则代表处理所有的HTTP请求的实例 , <code>nil</code>代表使用标准库中的实例处理 , 也是我们基于<code>net/http</code>标准库实现Web框架的入口。</p>
<p>这里第三个命令 , 访问了<code>/helloWorld</code> , 而在文件中未定义<code>/helloWorld</code>这个路由 , 用curl工具仅从测试 , 得到的却是<code>URL.Path</code> , 关于这个bug , 后文会进行修改。</p>
<h5 id="实现http.handler接口">实现http.Handler接口</h5>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package http

type Handler interface &#123;
    ServeHTTP(w ResponseWriter, r *Request)
&#125;

func ListenAndServe(address string, h Handler) error</code></pre>
<p>查阅<code>net/http</code>源码发现 , <code>Handler</code>是一个接口 , 需要实现方法 ServeHTTP , 也就是说 , 只要传入任何实现了 ServeHTTP接口的实例 , 所有的HTTP请求 , 就都交给了该实例处理。</p>
<h4 id="base2">base2</h4>
<blockquote>
<p>day1/base2/main.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&#x2F;http&quot;
)

type Engine struct&#123;&#125;
&#x2F;&#x2F; 定义一个空的结构体,并命名为Engine,后期可以直接用Engine加&#39;.&#39;加成员名的方式调用

func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;
    &#x2F;&#x2F; 这里engine作为Engine类型的对象,拥有Engine的所有方法
    switch req.URL.Path &#123;
        case &quot;&#x2F;&quot;:
            fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, req.URL.Path)
        case &quot;&#x2F;hello&quot;:
            for k, v :&#x3D; range req.Header &#123;
                fmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\n&quot;, k, v)
            &#125;
        default:
            fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)
    &#125;
&#125;

func main() &#123;
    engine :&#x3D; new(Engine)
    log.Fatal(http.ListenAndServe(&quot;:9999&quot;, engine))
&#125;</code></pre>
<p>后面复盘时，有一点一直搞不懂，究竟<code>ServeHTTP</code>是怎么被调用的？在这个go文件里面，感觉还是得从<code>ListenAndServe</code>下手，<code>ListenAndServe</code>的定义是这样的</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func ListenAndServe(addr string, handler Handler) error &#123;
    serve :&#x3D; &amp;Server&#123;Addr: addr, Handler: handler&#125; &#x2F;&#x2F; 创建一个Server结构体
    return server.ListenAndServe()
    &#x2F;&#x2F; 这里开始也还是没怎么看懂,后面也去查了下资料,这里返回的ListenAndServe,传入到Fatal里,如果不报错的话,是正常打印switch中的内容,有错误就打印错误信息
&#125;</code></pre>
<p>继续追溯<code>server.ListenAndServe()</code></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (srv *Server) ListenAndServe() error &#123;
    addr :&#x3D; srv.Addr
    if addr &#x3D;&#x3D; &quot;&quot; &#123;
        addr &#x3D; &quot;:http&quot;
    &#125;
    ln, err :&#x3D; net.Listen(&quot;tcp&quot;, addr)
    if err !&#x3D; nil &#123;
        return err
    &#125;
    return srv.Serve(ln)
&#125;</code></pre>
<p>此方法只是开始侦听给定的地址,并用新创建的侦听器调用<code>Server</code>方法</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (srv *Server) Serve(l net.Listener) error &#123;
    defer l.close()
    ...
    for&#123;
        rw, e :&#x3D; l.Accept()
        ...
        c :&#x3D; srv.newConn(rw)
        c.setState(c.rwc, StateNew)
        go c.serve(ctx)
    &#125;
&#125;</code></pre>
<p>从<code>Serve</code>方法我们可以看到 , 这是我们接受新连接并开始在它自己的<code>goroutine</code>中处理它的地方</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (c *Conn) serve(ctx context.Context) &#123;
    ...
    for &#123;
        w, err :&#x3D; c.readRequest(ctx)
        ...
        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)
        ...
    &#125;
&#125;</code></pre>
<p>在这里 , 才调用了<code>ServeHTTP</code>方法 , 正如我们在上面看到的 , 我们对这个ServeHTTP方法进行重写 , 打印输出HTTP请求的信息</p>
<hr>
<p>回到<code>main.go</code> , 这里定义了一个空的结构体<code>Engine</code> , 实现了方法<code>ServrHTTP</code> , 这个方法有两个参数 , 第二个参数是Request , 该对象包含了该HTTP请求的所有信息 , 比如请求地址 , Header和Body等信息 ; 第一个参数是ResponseWriter , 利用ResponseWriter可以构造指针对该请求的相应。</p>
<p>在main函数里 , 我们给ListenAndServe方法的第二个参数传入了刚才创建的<code>engine</code>实例 , 至此已经踏出了实现Web框架的第一步 , 即将所有的HTTP请求转向了我们自己的处理逻辑 。</p>
<p>在实现<code>Engine</code>之前 , 我们调用<code>http.HandleFunc</code>实现了路由和Handler的映射 , 也就是只能针对具体的路由写处理逻辑 , 比如<code>\hello</code> , 但在实现<code>engine</code>后 , 我们拦截了所有的HTTP请求 , 拥有了统一的控制入口 , 在这里我们可以自由定义路由映射的规则 , 也可以统一添加一些处理逻辑 , 例如日志 , 异常处理等。</p>
<p>代码运行结果前两行代码的结果一致 , 第三行代码结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloWorld
404 NOT FOUND: &#x2F;helloWorld</code></pre>
<h4 id="base3">base3</h4>
<h5 id="gee框架的雏形">Gee框架的雏形</h5>
<p>下面重新来组织上面的代码 , 搭建整个框架的雏形。</p>
<pre class="line-numbers language-none"><code class="language-none">gee&#x2F;
  |--gee.go
  |--go.mod
main.go
go.mod</code></pre>
<blockquote>
<p>day1/base3/go.mod</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">module example

go 1.18

require gee v1.0.0

replace gee &#x3D;&gt; .&#x2F;gee</code></pre>
<blockquote>
<p>day1/base3/main.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
	&quot;fmt&quot;
    &quot;net&#x2F;http&quot;
    &quot;gee&quot;
)

func main() &#123;
    r :&#x3D; gee.New()
    r.GET(&quot;&#x2F;&quot;, func(w http.ResponseWriter, req *http.Request) &#123;
        fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, req.URL.Path)
    &#125;)
    
    r.GET(&quot;&#x2F;hello&quot;, func(w http.RequestWriter, req *http.Request) &#123;
        for k, v :&#x3D; range req.Header &#123;
            fmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\n&quot;, k, v)
        &#125;
    &#125;)
    
    r.Run(&quot;:9999&quot;)
&#125;</code></pre>
<p>在这里 , 使用<code>GET()</code>方法添加路由 , 最后使用<code>Run()</code>启动Web服务 , 这里的路由 , 只是静态路由 , 不支持<code>/hello/:name</code>这样的动态路由 , 动态路由将在下一次实现。</p>
<blockquote>
<p>day1/base3/gee/go.mod</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">module gee

go 1.18</code></pre>
<p>因为我是用vscode进行代码编辑，工作区选择gee的根目录，而不是<code>src</code>，这里的<code>go.mod</code>管理需要做一点额外工作，按照教程写好mod后，会提示无法导入gee模块，查了各种帖子，对<code>Go111Module</code>进行设置也没效果，后面查到了一篇帖子，要在设置里搜 <strong>go.useLanguageServer</strong>，并将其关闭</p>
<blockquote>
<p>day1/base3/gee/gee.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package gee

import (
    &quot;fmt&quot;
    &quot;net&#x2F;http&quot;
)

type HandlerFunc func(http.ResponseWriter, *http.Request) 
&#x2F;&#x2F; 定义了一个HandlerFunc的函数类型,其签名必须符合输入为 http.ResponseWriter和*http.Request

type Engine struct &#123;
    router map[string]HandlerFunc
&#125;

func New() *Engine &#123;
    return &amp;Engine&#123;router: make(map[string]HandlerFunc)&#125;
&#125;

func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) &#123;
    key :&#x3D; method + &quot;-&quot; +pattern
    engine.router[key] &#x3D; router
&#125;

func (engine *Engine) GET(pattern string, handler HandlerFunc) &#123;
    engine.addRoute(&quot;GET&quot;, pattern, handler)
&#125;

func (engine *Engine) POST(pattern string, handler HandlerFunc) &#123;
    engine.addRoute(&quot;POST&quot;, pattern, handler)
&#125;

func (engine *Engine) Run(addr string) (err error) &#123;
    return http.ListenAndServe(addr, engine)
&#125;

func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;
    key :&#x3D; req.Method + &quot;-&quot; + req.URL.Path
    if handlerm ok :&#x3D; engine.router[key]; ok &#123;
        hanlder(w, req)
    &#125; else &#123;
        fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)
    &#125;
&#125;</code></pre>
<p>在<code>gee.go</code> , 介绍下这几部分的实现。</p>
<ul>
<li>定义了类型<code>HandlerFunc</code> , 这是提供给框架用户的 , 用来定义路由映射的基本方法。我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>，key由请求方法和静态路由地址构成，例如<code>GET-/</code>，<code>GET-/hello</code>，<code>POST-/hello</code>，这样针对相同的路由，如果请求方式不同，可以映射不同的处理方法(Handler)，value是用户映射的处理方法。</li>
<li>当用户调用<code>(*Engine).Run()</code>方法，会将路由和处理方法注册到映射表router中，<code>(*Engine).Run()</code>，是 ListenAndServe的包装。</li>
<li><code>Engine</code>实现的ServeHTTP方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法，如果查不到，就返回404 NOT FOUND。</li>
</ul>
<p>执行<code>go run main.go</code>，再用curl访问，结果和base2的结果一致</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;
URL.Path &#x3D; &quot;&#x2F;&quot;
$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;hello
Header[&quot;Accept&quot;] &#x3D; [&quot;*&#x2F;*&quot;]
Header[&quot;User-Agent&quot;] &#x3D; [&quot;curl&#x2F;7.68.0&quot;]
$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloWorld
404 NOT FOUND: &#x2F;helloWorld</code></pre>
<p>至此，整个Gee框架的原型就已经出来了。有了基本路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当然到目前为止，我们还没有实现比<code>net/http</code>标准库更强大的能力，这些会在后面将动态路由、中间件等功能添加上去。</p>
<h3 id="day2.-上下文-context">day2. 上下文 Context</h3>
<ul>
<li>将 路由(router) 独立出来 , 方便之后改进。</li>
<li>设计 上下文 (Context)，封装 Request和 Response，提供对JSON、HTML等返回类型的支持。</li>
<li>第二天的框架内容，代码约140行，新增约90行。</li>
<li>后面每一天贴出的代码基本为原文件基础上新增的内容或修改后的内容</li>
</ul>
<h4 id="设计context">设计Context</h4>
<h5 id="必要性">必要性</h5>
<ol type="1">
<li>对Web服务来说，无非是根据请求<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的相应，需要考虑消息头(Header)和消息体(Body)，而Header包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复、繁冗的代码，且容易出错。针对常用场景，能够高效地构造出HTTP相应是一个好的框架必须考虑的点。</li>
</ol>
<p>用返回JSON数据作比较，对比封装前后的差异：</p>
<blockquote>
<p>封装前</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">obj &#x3D; map[string]interface&#123;&#125; &#123;
    &quot;name&quot;: &quot;abc&quot;,
    &quot;password&quot;: &quot;1234&quot;,
&#125;
w.Header().Set(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)
w.WriteHeader(http.StatusOK)
encoder :&#x3D; json.NewEncoder(w)
if err :&#x3D; encoder.Encode(obj); err !&#x3D; nil &#123;
    http.Error(w, err.Error(), 500)
&#125;</code></pre>
<blockquote>
<p>封装后</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">c.JSON(http.StatusOK, gee.H&#123;
    &quot;username&quot;: c.PostForm(&quot;username&quot;),
    &quot;password&quot;: c.PostForm(&quot;password&quot;),
&#125;)</code></pre>
<ol start="2" type="1">
<li>针对使用场景，封装<code>*http.Request</code>和<code>http.ResponseWriter</code>的方法，简化相关接口的调用，只是设计Context的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由<code>/hello/:name</code>，参数<code>name</code>的值放在哪？再比如，框架需要支持中间件，那中间件产生的信息放在哪？Context随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由Context承载。因此，设计Context结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用Context实例</li>
</ol>
<h5 id="具体实现">具体实现</h5>
<blockquote>
<p>day2/gee/context.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type H map[string]interface&#123;&#125;

type Context struct &#123;
    &#x2F;&#x2F; origin objects
    Writer http.ResponseWriter
    Req *http.Request
    &#x2F;&#x2F; request info
    Path string
    Method string
    &#x2F;&#x2F; response info
    StatusCode int
&#125;

func newContext(w http.ResponseWriter, req *http.Request) *Context &#123;
    return &amp;Context &#123;
        Writer: w,
        Req req,
        Path: req.URL.Path,
        Method: req.Method,
    &#125;
&#125;

func (c *Context) PostForm(key string) string &#123;
    return c.Req.FormValue(key)
&#125;

func (c *Context) Query(key string) string &#123;
    return c.Req.URL.Query().Get(key)
&#125;

func (c *Context) Status(code int) &#123;
    c.StatusCode &#x3D; code
    c.Writer.WriteHeader(code)
&#125;

func (c *Context) SetHeader(key string, value string) &#123;
    c.Writer.Header().Set(key, value)
&#125;

func (c *Context) String(code int, format string, values ...interface&#123;&#125;) &#123;
    c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;)
    c.Status(code)
    c.Writer.Write([]byte(fmt.Sprintf(format, values...)))
&#125;

func (c *Context) JSON(code int, obj interface&#123;&#125;) &#123;
    c.SetHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)
    c.Status(code)
    encoder :&#x3D; json.NewEncoder(c.Writer)
    if err :&#x3D; encoder.Encode(obj); err !&#x3D; nil &#123;
        http.Error(c.Writer, err.Error(), 500)
    &#125;
    &#x2F;&#x2F; 这里的obj,在后文的测试中,就是一个map,输出为[&quot;passowrd&quot;:&quot;xxx&quot;,&quot;username&quot;:&quot;xxx&quot;]
&#125;

func (c *Context) Data(code int, data []byte) &#123;
    c.Status(code)
    c.Writer.Write(data)
&#125;

func (c *Context) HTML(code int, html string) &#123;
    c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)
    c.Status(code)
    c.Writer.Write([]byte(html))
&#125;</code></pre>
<ul>
<li>代码最开头，给<code>map[string]interface&#123;&#125;</code>起了一个别名<code>gee.H</code>，构建JSON数据时，显得更简洁。</li>
<li><code>Context</code>目前只包含了<code>http.ResponseWriter</code>和<code>*http.Request</code>，另外提供了对Method和Path这两个常用的属性的直接访问。</li>
<li>提供了访问Query和PostForm参数的方法。</li>
<li>提供了快速构造String/Data/JSON/HTML相应的方法。</li>
</ul>
<h4 id="路由router">路由(Router)</h4>
<p>我们将和路由相关的方法和结构提取了出来，放到了一个新的文件<code>router.go</code>，方便下一次对router的功能进行增强，例如提供动态路由的支持。router的handle方法作了一个细微的调整，即handler的参数，变成了Context。</p>
<blockquote>
<p>day2/gee/router.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type router struct &#123;
    handlers map[string]HandlerFunc
&#125;

func newRouter() *router &#123;
    return &amp;router&#123;handlers: make(map[string]HandlerFunc)&#125;
&#125;

func (r *router) addRoute(method string, pattern string, handler HandlerFunc) &#123;
    log.Printf(&quot;Route %4s - %s&quot;, method, pattern)
    key :&#x3D; method + &quot;-&quot; + pattern
    r.handlers[key] &#x3D; handler
    &#x2F;&#x2F; 注册路由
&#125;

func (r *router) handle(c *Context) &#123;
    key :&#x3D; c.Method + &quot;-&quot; + c.Path
    if handler, ok :&#x3D; r.handlers[key]; ok &#123;
        &#x2F;&#x2F; 这里根据输入的方法和路径查找handlers中值,返回HandlerFunc,赋给handler,此时handler就是一个带有HandlerFunc签名的函数(http.ResponseWriter和*http.Request),输入的参数类型为*Context,handler再根据输入的Context
        handler(c)
    &#125; else &#123;
        c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)
    &#125;
&#125;</code></pre>
<h4 id="框架入口">框架入口</h4>
<blockquote>
<p>day2/gee/gee.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package gee

import &quot;net&#x2F;http&quot;

&#x2F;&#x2F; HandlerFunc defines the request handler used by gee
&#x2F;&#x2F; HandlerFunc包含Context所有属性和方法
type HandlerFunc func(*Context)

&#x2F;&#x2F; Engine implement the interface of ServeHTTP
type Engine struct &#123;
    router *router
&#125;

&#x2F;&#x2F; New is the constructor of gee.Engine
func New() *Engine &#123;
    return &amp;Engine&#123;router: newRouter()&#125;
&#125;

func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) &#123;
    engine.router.addRoute(method, pattern, handler) &#x2F;&#x2F; 调用router的addRoute方法
    &#x2F;&#x2F; router的addRoute方法类似于一个私有函数,通过engine的addRoute传入参数再传递给router
&#125;
&#x2F;&#x2F; 把第一天的addRoute修改为这样,</code></pre>
<p>将<code>router</code>相关的代码独立后，<code>gee.go</code>简单了不少。最重要的还是通过实现了ServeHTTP接口，接管了所有的HTTP请求。相比第一天的diamond，这个方法也有细微的调整，在调用router.handle之前，构造了一个Context对象。这个对象目前还非常简单，仅仅是包装了原来的两个参数，之后我们会慢慢地给Context加上更多内容。</p>
<blockquote>
<p>day2/main.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import(
    &quot;net&#x2F;http&quot;
    &quot;gee&quot;
)

func main() &#123;
    r :&#x3D; gee.New()
    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;
        c.HTML(http.StatusOK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;\n&quot;)
    &#125;) 
    &#x2F;&#x2F; 思路: 向GET传入一个&quot;&#x2F;&quot;的路由和一个匿名的HandlerFunc函数,该函数内部含有相关HTTP请求信息(HTML函数),然后GET把这个路由和handler传给engine的addRoute,经过套娃,再到达router的addRoute
    &#x2F;&#x2F; 下面的GET也同理,只不过String和HTML传入的切片不同
    r.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;
        &#x2F;&#x2F; expect &#x2F;hello?name&#x3D;abc
        c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Query(&quot;name&quot;), c.Path)
    &#125;)
    r.POST(&quot;&#x2F;login&quot;, func(c *gee.Context) &#123;
        &#x2F;&#x2F; 在服务器端输出的是 &quot;POST - &#x2F;login&quot;
        c.JSON(http.StatusOK, gee.H&#123;
            &quot;username&quot;: c.PostForm(&quot;username&quot;),
            &quot;password&quot;: c.PostForm(&quot;password&quot;),
        &#125;)
    &#125;)
    r.Run(&quot;:9999&quot;)
&#125;</code></pre>
<p>运行<code>main.go</code>，看看day2的成果：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">$ curl -i http:&#x2F;&#x2F;localhost:9999&#x2F;
HTTP&#x2F;1.1 200 OK
Content-Type: text&#x2F;html
Date: Fri, 08 Jul 2022 08:29:52 GMT
Content-Length: 19

&lt;h1&gt;Hello Gee&lt;&#x2F;h1&gt;

$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;hello?name&#x3D;abc
hello abc, you&#39;re at&#x2F;hello

$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;login -X POST -d &quot;username&#x3D;abc&amp;password&#x3D;1234&quot;
&#123;&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;abc&quot;&#125;

$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;xxx
404 NOT FOUND: &#x2F;xxx</code></pre>
<p>服务器端输出</p>
<pre class="line-numbers language-none"><code class="language-none">2022&#x2F;07&#x2F;09 11:38:15 Route  GET - &#x2F;
2022&#x2F;07&#x2F;09 11:38:15 Route  GET - &#x2F;hello
2022&#x2F;07&#x2F;09 11:38:15 Route POST - &#x2F;login</code></pre>
<h3 id="day3-前缀树路由router">day3 前缀树路由Router</h3>
<ul>
<li>使用Trie树实现动态路由(dynamic route)解析。</li>
<li>支持两种模式<code>:name</code>和<code>*filepath</code>，代码约150行。</li>
</ul>
<h4 id="trie树简介">Trie树简介</h4>
<p>之前，用了一个非常简单的<code>map</code>结构存储了路由表，用<code>map</code>存储键值对，索引非常高效，但是有一个弊端，键值对的存储方式，只能来索引静态路由。如果我们想支持类似于<code>/hello/:name</code>这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而并非某一条固定的路由，例如<code>/hello/:name</code>，可以匹配<code>/hello/abc</code>，<code>/hello/jayden</code>等。</p>
<p>动态路由有很多种实现方式，支持的规则，性能等有很大的差异。例如开源的路由实现<code>gorouter</code>支持在路由规则种嵌入正则表达式，例如<code>/p/[0-9A-Za-z]+</code>，即路径种的参数仅匹配数字和字母；另一个开源实现<code>httprouter</code>就不支持正则表达式。Web开源框架<code>gin</code>在早期的版本没有实现自己的路由，而是直接用了<code>httprouter</code>，后来又放弃了<code>httprouter</code>，自己实现了一个版本。</p>
<p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day3_trie_tree.jpg'></p>
<p>实现动态路由最常用的数据结构，被称为前缀树(Trie树)。每个节点的所有子节点都有相同的前缀。这种结构非常适用于路由匹配，例如我们定义了如下路由规则：</p>
<ul>
<li><code>/:lang/doc</code></li>
<li><code>/:lang/tutorial</code></li>
<li><code>/:lang/intro</code></li>
<li><code>/about</code></li>
<li><code>/p/blog</code></li>
<li><code>/p/related</code></li>
</ul>
<p>我们用前缀树表示，是这样的：</p>
<p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day3_trie_tree_web.jpg'></p>
<p>HTTP请求的路径恰好是由<code>/</code>分割的多端构成的，因此，每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。</p>
<p>接下来我们实现的动态路由具备以下俩功能：</p>
<ul>
<li>参数匹配：例如<code>/p/:lang/doc</code>，可以匹配<code>/p/c/doc</code>和<code>p/go/doc</code>。</li>
<li>通配<code>*</code>，例如<code>/static/*filepath</code>，可以匹配<code>/static/fav.ico</code>，也可以匹配<code>/static/js/jQuery.js</code>，这种模式常用于静态服务器，能够递归地匹配子路径。</li>
</ul>
<h4 id="trie树实现">Trie树实现</h4>
<p>首先需要设计树节点上应存储哪些信息。</p>
<blockquote>
<p>day3/gee/trie.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type node struct &#123;
    pattern string &#x2F;&#x2F; 待匹配路由，例如 &#x2F;p&#x2F;:lang
    part string &#x2F;&#x2F; 路由中一部分，例如 :lang
    children []*node &#x2F;&#x2F; 子节点，例如 [doc, tutorial, intro]
    isWild bool &#x2F;&#x2F; 是否精确匹配，part含有 : 或 * 时为true
&#125;

&#x2F;&#x2F; 这里重写String函数,便于后期查看相关参数的值(直接输出n.children是打印地址)
func (n node) String() string &#123;
    return fmt.Sprintf(&quot;pattern:%s, part:%s, children:%s, isWild:%t&quot;, n.pattern, n.part, n.children, n.isWild)
&#125;</code></pre>
<p>与普通的树不同，为了实现动态路由匹配，加上了<code>isWild</code>这个参数。即当我们匹配<code>/p/go/doc</code>这个路由时 (<code>/</code>算0个节点) ，第一层节点，<code>p</code>精确匹配到了<code>p</code>，第二层节点，<code>go</code>模糊匹配到<code>:lang</code>，那么会将<code>lang</code>这个参数赋值为<code>go</code>，继续下一层匹配。我们将匹配的逻辑，包装为一个辅助函数。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 第一个匹配成功的节点，用于插入
func (n *node) matchChild(part string) *node &#123;
    for _, child :&#x3D; range n.children &#123;
        &#x2F;&#x2F; 这里之前一直没搞懂为什么要忽略range的第一个参数,查阅资料后发现,第一个参数是索引值index,第二个参数是value,这里第二个参数,就是n的子节点
        if child.part &#x3D;&#x3D; part || child.isWild &#123;
            return child
        &#125;
    &#125;
    return nil
&#125;
&#x2F;&#x2F; 所有匹配成功的节点，用于查找
func (n *node) matchChildren(part string) []*node &#123;
    nodes :&#x3D; make([]*node, 0) &#x2F;&#x2F; new一个长度为0的切片
    for _, child :&#x3D; range n.children &#123;
        if child.part &#x3D;&#x3D; part || child.isWild &#123;
            nodes &#x3D; append(nodes, child)
            &#x2F;&#x2F; 将匹配成功的节点加入到nodes中
        &#125;
    &#125;
    return nodes
&#125;</code></pre>
<p>对于路由来说，最重要的当然是注册于匹配了。开发服务时，注册路由规则，映射handler；访问时，匹配路由规则，查找到对应的handler。因此，Trie树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前<code>part</code>的节点，则新建一个，有一点需要注意，<code>/p/:lang/doc</code>只有在第三层节点，即<code>doc</code>节点，<code>pattern</code>才会设置为<code>/p/:lang/doc</code>。<code>p</code>和<code>:lang</code>节点的<code>pattern</code>属性皆为空。因此，当匹配结束时，我们可以用<code>n.pattern == ""</code>来判断路由规则是否匹配成功。例如，<code>/p/python</code>虽能成功匹配到<code>:lang</code>，但<code>:lang</code>的<code>pattern</code>值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到 * ，匹配失败，或匹配到第<code>len(parts)</code>层节点。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (n *node) insert(pattern string, parts []string, height int) &#123;
    if len(parts) &#x3D;&#x3D; height &#123;
		&#x2F;&#x2F; 这里其实是层层递归
        n.pattern &#x3D; pattern
        return
    &#125;
    
    part :&#x3D; parts[height]
    child :&#x3D; n.matchChild(part)
    if child &#x3D;&#x3D; nil &#123;
        child &#x3D; &amp;node&#123;part: part, isWild: part[0] &#x3D;&#x3D; &#39;:&#39; || part[0] &#x3D;&#x3D; &#39;*&#39;&#125;
        n.children &#x3D; append(n.children, child)
    &#125;
    child.insert(pattern, parts, height + 1)
&#125;

func (n *node) search(parts []string, height int) *node &#123;
    if len(parts) &#x3D;&#x3D; height || strings.HasPrefix(n.part, &quot;*&quot;) &#123;
        if n.pattern &#x3D;&#x3D; &quot;&quot; &#123;
            return nil
        &#125;
        &#x2F;&#x2F; 若以*为开头的字串,直接以此节点为当前分支尾节点
        return n
    &#125;
    
    part :&#x3D; parts[height]
    &#x2F;&#x2F; (height+1)的值是当前搜索的层数
    children :&#x3D; n.matchChildren(part)
    &#x2F;&#x2F; children则含有搜索到每一层的part
    
    for _, child :&#x3D; range children &#123;
        result :&#x3D; child.search(parts, height + 1)
        if result !&#x3D; nil &#123;
            return result
        &#125;
    &#125;
    
    return nil
&#125;

func (n *node) travel(list *([]*node)) &#123;
    if n.pattern !&#x3D; &quot;&quot; &#123;
        *list &#x3D; append(*list, n)
    &#125;
    for _, child :&#x3D; range n.children &#123;
        child.travel(list)
    &#125;
&#125;</code></pre>
<h4 id="router">Router</h4>
<p>Trie树的插入与查找都成功实现了，接下来我们将Trie树应用到路由中。我们用roots来存储每种请求方式的Trie树根节点。使用handlers存储每种请求方式的HandlerFunc。getRoute函数中，还解析了<code>:</code>和<code>*</code>两种匹配符的参数，返回一个 map。例如<code>/p/go/doc</code>匹配到<code>/p/:lang/doc</code>，解析结果为<code>&#123;lang: "go"&#125;</code>，<code>/static/css/gee.css</code>匹配到<code>/static/*filepath</code>，解析结果为<code>&#123;filepath: "css/gee.css"&#125;</code>。</p>
<blockquote>
<p>day3/gee/router.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type router struct &#123;
    roots map[string]*node
    handlers map[string]HandlerFunc
&#125;

&#x2F;&#x2F; roots key eg, roots[&#39;GET&#39;] roots[&#39;POST&#39;]
&#x2F;&#x2F; handlers key eg, handlers[&#39;GET-&#x2F;p&#x2F;:lang&#x2F;doc&#39;], handlers[&#39;POST-&#x2F;p&#x2F;book&#39;]

func newRouter() *router &#123;
    return &amp;router &#123;
        roots: make(map[string]*node),
        handlers: make(map[string]HandlerFunc),
    &#125;
&#125;

&#x2F;&#x2F; Only one * is allowed
func parsePattern(pattern string) []string &#123;
    vs :&#x3D; strings.Split(pattern, &quot;&#x2F;&quot;)
    &#x2F;&#x2F; 一层层获取并判断是否为有效节点字串
    parts :&#x3D; make([]string, 0)
    for _, item :&#x3D; range vs &#123;
        if item !&#x3D; &quot;&quot; &#123;
            parts &#x3D; append(parts, item)
            if item[0] &#x3D;&#x3D; &#39;*&#39; &#123;
                break
                &#x2F;&#x2F; 这里只要当前节点为*,则结束后面的遍历,以*为当前分支尾节点
            &#125;
        &#125;
    &#125;
    return parts
&#125;

func (r *router) addRoute(method string, path string) (*node, map[string]string) &#123;
    searchParts :&#x3D; parsePattern(pattern)
    
    key :&#x3D; method + &quot;-&quot; + pattern
    _, ok :&#x3D; r.roots[method]
	&#x2F;&#x2F; 这里卡的比较久,第一个返回值是获取的值,第二个是判断值是否获取成功
    if !ok &#123;
        r.roots[method] &#x3D; &amp;node&#123;&#125;
        &#x2F;&#x2F; 一般来说,对于一个新路由,node默认是空,
    &#125;
    r.roots[method].insert(pattern, parts, 0)
    r.handlers[key] &#x3D; handler
&#125;

func (r *router) getRoute(method string, path string) (*node, map[string]string) &#123;
    searchParts :&#x3D; parsePattern(path)
    params :&#x3D; make(map[string]string)
    root, ok :&#x3D; r.roots[method]
    
    if !ok &#123;
        return nil, nil
    &#125;
    
    n :&#x3D; roots.search(searchParts, 0)
    
    if n !&#x3D; nil &#123;
        parts :&#x3D; parsePattern(n.pattern)
        for index, part :&#x3D; range parts &#123;
            &#x2F;&#x2F; getRoute的参数匹配,这里匹配:和*两种字符
            if part[0] &#x3D;&#x3D; &#39;:&#39; &#123;
                params[part[1:]] &#x3D; searchParts[index]
            &#125;
            if part[0] &#x3D;&#x3D; &#39;*&#39; &amp;&amp; len(part) &gt;1 &#123;
                params[part[1:]] &#x3D; strings.Join(searchParts[index:], &quot;&#x2F;&quot;)
                break
            &#125;
        &#125;
        return n, params
    &#125;
    return nil, nil
&#125;

func (r *router) getRoutes(method string) []*node &#123;
    root, ok :&#x3D; r.roots[method]
    if !ok &#123;
        return nil
    &#125;
    nodes :&#x3D; make([]*node, 0)
    root.travel(&amp;nodes)
    return nodes
&#125;</code></pre>
<h4 id="context与handle的变化">Context与handle的变化</h4>
<p>在HandleFunc中，希望能够访问到解析的参数，因此，需要对Context对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数储存到<code>Params</code>中，通过<code>c.Param("lang")</code>的方式获取到对应的值。</p>
<blockquote>
<p>day3/gee/context.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Context struct &#123;
    &#x2F;&#x2F; origin objects
    Writer http.ResponseWriter
    Req *http.Request
    &#x2F;&#x2F; request info
    Path string
    Method string
    Params map[string]string
    &#x2F;&#x2F; response info
    StatusCode int
&#125;

func (c *Context) Param(key string) string &#123;
    value :&#x3D; c.Params[key] 
    return value
&#125;</code></pre>
<blockquote>
<p>day3/gee/router.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *router) handle(c *Context) &#123;
    n, params :&#x3D; r.getRoute(c.Method, c.Path)
    if n !&#x3D; nil &#123;
        c.Params &#x3D; params
        key :&#x3D; c.Method + &quot;-&quot; +n.pattern
        r.handlers[key](c)
    &#125; else &#123;
        c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)
    &#125;
&#125;</code></pre>
<p><code>router.go</code>的变化比较小，比较重要的一点是，在调用匹配到的<code>handler</code>前，将解析出来的路由参数赋值给了<code>c.Params</code>。这样就能够在<code>handler</code>中，通过<code>Context</code>对象访问到具体的值了</p>
<h4 id="单元测试">单元测试</h4>
<blockquote>
<p>router_test.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package gee

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;testing&quot;
)

func newTestRouter() *router &#123;
    r :&#x3D; newRouter()
    r.addRoute(&quot;GET&quot;, &quot;&#x2F;&quot;, nil)
    r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;:name&quot;, nil)
    r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;b&#x2F;c&quot;, nil)
    r.addRoute(&quot;GET&quot;, &quot;&#x2F;hi&#x2F;:name&quot;, nil)
    r.addRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;*filepath&quot;, nil)
    return r
&#125;

func TestParsePattern (t *testing.T) &#123;
    r :&#x3D; newTestRouter()
    ok :&#x3D; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;:name&quot;), []string&#123;&quot;p&quot;, &quot;:name&quot;&#125;)
    ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*&quot;), []sring&#123;&quot;p&quot;, &quot;*&quot;&#125;)
    ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*name&#x2F;*&quot;), []string&#123;&quot;p&quot;, &quot;*name&quot;&#125;)
    if !ok &#123;
        t.Fatal(&quot;test parsePattern failed&quot;)
    &#125;    
&#125;

func TestGetRoute(t *testing.T) &#123;
    r :&#x3D; newTestRouter()
    n, ps :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;gee&quot;)
    
    if n &#x3D;&#x3D; nil &#123;
        t.Fatal(&quot;nil shouldn&#39;t be returned&quot;)
    &#125;
    
    if n.pattern !&#x3D; &quot;&#x2F;hello&#x2F;:name&quot; &#123;
        t.Fatal(&quot;should match &#x2F;hello&#x2F;:name&quot;)
    &#125;
    
    if ps[&quot;name&quot;] !&#x3D; &quot;gee&quot; &#123;
        t.Fatal(&quot;should match be equal to gee&quot;)
    &#125;
    
    fmt.Printf(&quot;matched path: %s, params[&#39;name&#39;]: %s\n&quot;, n.pattern, ps[&quot;name&quot;])
&#125;

func TestGetRoute2(t *testing.T) &#123;
    r :&#x3D; newTestRouter()
    n1, ps1 :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;file1.txt&quot;)
    ok1 :&#x3D; n1.pattern &#x3D;&#x3D; &quot;&#x2F;assets&#x2F;*filepath&quot; &amp;&amp; ps1[&quot;filepath&quot;] &#x3D;&#x3D; &quot;file1.txt&quot;
    if !ok1 &#123;
        t.Fatal(&quot;pattern should be &#x2F;assets&#x2F;*filepath &amp; filepath should be file1.txt&quot;)
    &#125;
    
    n2, ps2 :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;css&#x2F;test.css&quot;)
    ok2 :&#x3D; n2.pattern &#x3D;&#x3D; &quot;&#x2F;assets&#x2F;*filepath&quot; &amp;&amp; ps2[&quot;filepath&quot;] &#x3D;&#x3D; &quot;css&#x2F;test.css&quot;
    if !ok2 &#123;
        t.Fatal(&quot;pattern should be &#x2F;assets&#x2F;*filepath &amp;filepath should be css&#x2F;test.css&quot;)
    &#125;
&#125;

func TestGetRoutes(t *testing.T) &#123;
    r :&#x3D; newTestRouter()
    nodes :&#x3D; r.getRoutes(&quot;GET&quot;)
    for i, n :&#x3D; range nodes &#123;
        fmt.Println(i+1, n)
    &#125;
    
    if len(nodes) !&#x3D; 5 &#123;
        t.Fatal(&quot;the number of routes should be 4&quot;)
    &#125;
&#125;</code></pre>
<h4 id="使用demo">使用DEMO</h4>
<blockquote>
<p>day3/main.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
	&quot;gee&quot;
    &quot;net&#x2F;http&quot;
)

func main() &#123;
    r :&#x3D; gee.New()
    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;
        c.HTML(http.StatusOK, &quot;&lt;h1&gt;Hello gee&lt;&#x2F;h1&gt;&quot;)
    &#125;)
    
    r.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;
        &#x2F;&#x2F; expect &#x2F;hello?name&#x3D;xxx
        c.String(http.StatucOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Query(&quot;name&quot;), c.Path)
    &#125;)
    
    r.GET(&quot;&#x2F;assets&#x2F;*filepath&quot;, func(c *gee.Context) &#123;
        c.JSON(http.StatusOK, gee.H&#123;&quot;filepath&quot;: c.Param(&quot;filepath&quot;)&#125;)
    &#125;)
    
    r.Run(&quot;:9999&quot;)
&#125;</code></pre>
<p>使用curl测试</p>
<pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;hello&#x2F;abc
hello abd, you&#39;re at &#x2F;hello&#x2F;abc

$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;assets&#x2F;css&#x2F;abc.css&quot;
&#123;&quot;filepath&quot;:&quot;css&#x2F;abc.css&quot;&#125;</code></pre>
<h4 id="day3小结">day3小结</h4>
<p>之前因为一项暑期实践活动的工作 , 我没有很认真地过一遍 , 也只是草草地敲一遍代码 , 简单地挖几个函数的源码来看 , 后面因为实训项目就先搁置了这个gee框架的学习 , 等做完实训项目后 , 花了半天把代码敲了一遍 , 也运行了一遍 , 但还是觉得心里心里很没底，于是想着，从第一天的内容开始认真看一遍，然后就开始对着前两天的源码一顿操作，开始不断查看源码中函数引用的内容，在关键函数print相关变量，前两天内容并不算很难，到了第三天，可能是跳跃性太大，加上前两天基础不牢，我在这里卡了4天，加上这几天状态不太好，就学的比较慢，这几天意识到事情的严重性，稍微加快了脚步，对第三天的路由部分进行了更多的测试，也对这个路由部分有了更深的认识</p>
<h3 id="day4.-分组控制group">day4. 分组控制Group</h3>
<ul>
<li>本次实现路由分组控制(Route Group Control)，代码约50行。</li>
</ul>
<h4 id="分组的意义">分组的意义</h4>
<p>分组控制(Route Group Control) 是Web框架应提供的基础功能之一。所谓分组，是指的路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p>
<ul>
<li>以<code>/post</code>开头的路由匿名可访问</li>
<li>以<code>/admin</code>开头的路由需要鉴权</li>
<li>以<code>/api</code>开头的路由时RESTful接口 , 可以对接第三方平台 , 需要三方平台鉴权</li>
</ul>
<p>大部分情况下的路由分组 , 是以相同的前缀来区分的。因此，我们今天实现的分组控制也是以前缀来区分，并支持分组的嵌套。例如<code>/post</code>是一个分组，<code>/post/a</code>和<code>/post/b</code>可以是该分组下的子分组。作用在<code>/post</code>分组上 中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。</p>
<p>中间件可以给框架提供无限的扩展能力，应用在分组上，可以使得分组控制的收益更为明显，而不是共享相同的路由前缀这么简单。例如<code>/admin</code>的分组，可以应用鉴权中间件；<code>/</code>分组应用日志中间件，<code>/</code>是默认的最顶层的分组，也就意味着给所有的路由，即整个框架增加了日志的能力。</p>
<p><strong>分组嵌套</strong></p>
<p>一个Group对象需要具备哪些属性呢？首先是前缀(prefix)，比如<code>/</code>，或者<code>/api</code>；要支持分组嵌套，那么需要知道当前分组的父亲(parent)是谁；当然了，按照我们一开始的分析，中间件是应用在分组上的，那还需要储存应用在该分组上的中间件(middlewares)。还记得，我们之前调用函数<code>*(Engine).addRoute()</code>来映射所有的路由规则和 Handler。如果Group对象需要直接映射路由规则的画，比如我们想在使用框架时，这么调用</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">r :&#x3D; gee.New()
v1 :&#x3D; r.Group(&quot;&#x2F;v1&quot;)
v1.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;
    c.HTML(http.StatusK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;&quot;)
&#125;)</code></pre>
<p>那么Group对象，还需要有访问<code>Router</code>的能力，为了方便，我们可以在Group中，保存一个指针，指向<code>Engine</code>，整个框架的所有资源都是由<code>Engine</code>统一协调的，那么就可以通过<code>Engine</code>间接地访问各种接口了。</p>
<p>所以，最后的Group做出以下改动：</p>
<blockquote>
<p>day4/gee/gee.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type HandlerFunc func(*Context)

type (
    RouterGroup struct &#123;
        prefix string
        middlewares []HandlerFunc
        parent *RouterGroup
        engine *Engine
    &#125;
    &#x2F;&#x2F; 进一步抽象，将Engine作为最顶层的分组，也就是说Engine拥有RouterGroup的所有能力
    Engine struct &#123;
        *RouterGroup
        router *router
        groups []*RouterGroup
    &#125;
)

&#x2F;&#x2F; 下面是实现和路由有关的函数
func New() *Engine &#123;
    engine :&#x3D; &amp;Engine&#123;router: newRouter()&#125;
    engine.RouterGroup &#x3D; &amp;RouterGroup&#123;engine: engine&#125;
    engine.groups &#x3D; []*RouterGroup&#123;engine.RouterGroup&#125;
    return engine
&#125;

func (group *RouterGroup) Group(prefix string) *RouterGroup &#123;
    engine :&#x3D; group.engine
    newGroup :&#x3D; &amp;RouterGroup &#123;
        prefix: group.prefix + prefix,
        &#x2F;&#x2F; parent: group,
        engine: engine,
        &#x2F;&#x2F; 查阅评论区后，作者用gruop.prefix+prefix的方式初始化已经拼接了完整的prefix，不需要parent，于是可以删除
    &#125;
    engine.groups &#x3D; append(engine.groups, newGroup)
    return newGroup
&#125;

func (group *RouterGroup) addRoute(method string, comp string, handler HandlerFunc) &#123;
    pattern :&#x3D; group.prefix + comp
    log.Printf(&quot;Route %4s - %s&quot;, method, pattern)
    group.engine.router.addRoute(method, pattern, handler)
&#125;

func (group *RouterGroup) GET(pattern string, handler HandlerFunc) &#123;
    group.addRoute(&quot;GET&quot;, pattern, handler)
&#125;

func (group *RouteGroup) POST(pattern string, handler HandlerFunc) &#123;
    gourp.addRoute(&quot;POST&quot;, pattern, handler)
&#125;</code></pre>
<p>在这里可以观察到<code>addRoute</code>函数，调用了<code>group.engine.router.addRoute</code>来实现了路由的映射。由于<code>Engine</code>从某种意义上继承了<code>RouterGroup</code>的所有属性和方法，因为<code>(*Engine).engine</code>是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由。</p>
<h4 id="使用demo-1">使用Demo</h4>
<blockquote>
<p>day4/main.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
    r :&#x3D; gee.New()
    r.GET(&quot;&#x2F;index&quot;, func(c *gee.Context) &#123;
        c.HTML(http.StatusOK, &quot;&lt;h1&gt;Index Page&lt;&#x2F;h1&gt;&quot;)
    &#125;)
    v1 :&#x3D; r.Group(&quot;&#x2F;v1&quot;)
    &#123;
        v1.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;
            c.HTML(http.StatusOK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;&quot;)
        &#125;)
        
        v1.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;
            &#x2F;&#x2F; expect &#x2F;hello?name&#x3D;abc
            c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Query(&quot;name&quot;), c.Path)
        &#125;)
    &#125;
    v2 :&#x3D; r.Group(&quot;&#x2F;v2&quot;)
    &#123;
        v2.GET(&quot;&#x2F;hello&#x2F;:name&quot;, func(c *gee.Context) &#123;
            &#x2F;&#x2F; expect &#x2F;hello&#x2F;abc
            c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Param(&quot;name&quot;), c.Path)
        &#125;)
        v2.POST(&quot;&#x2F;login&quot;, func(c *gee.Context) &#123;
            c.JSON(http.StatusOK, gee.H&#123;
                &quot;username&quot;: c.PostForm(&quot;username&quot;),
                &quot;password&quot;: c.PostForm(&quot;password&quot;),
            &#125;)
        &#125;)
    &#125;
    
    r.Run(&quot;:9999&quot;)
&#125;</code></pre>
<p>通过curl的简单测试：</p>
<pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;v1&#x2F;hello?name&#x3D;abc&quot;
hello abc, you&#39;re at &#x2F;v1&#x2F;abc
$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;v2&#x2F;hello&#x2F;abc&quot;
hello abc, you&#39;re at &#x2F;hello&#x2F;abc</code></pre>
<h3 id="day5.-中间件-middleware">day5. 中间件 Middleware</h3>
<ul>
<li>设计并实现Web 框架的中间件 (Middlewares)机制</li>
<li>实现通用的 Logger 中间件，能够记录请求到响应所花费的时间，代码约50行</li>
</ul>
<h4 id="中间件是什么">中间件是什么</h4>
<p>中间件(middlewares)，简单说，就是非业务的技术类组件。Web框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此，框架需要有一个插口，允许用户自定义功能，嵌入到框架中，仿佛这个功能是框架原生支持的一样。因此，对中间件而言，需要考虑2个比较关键的点：</p>
<ul>
<li>插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂</li>
<li>中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。</li>
</ul>
<p>那对于一个Web框架而言，中间件应该设计成什么样呢？接下来的实现，基本参考了Gin框架。</p>
<h4 id="中间件设计">中间件设计</h4>
<p>Gee的中间件的定义与路由映射的Handler一致，处理的是输入的<code>Context</code>对象。插入点是框架接收到请求初始化<code>Context</code>对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对<code>Context</code>进行二次加工。另外通过调用<code>(*Context).Next()</code>函数，中间件可等待用户自己定义的<code>Handler</code>处理结束后，做一些额外的操作，例如计算本次处理所用时间等。即Gee的中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件，<code>c.Next()</code>表示等待执行其他的中间件或用户的<code>Handler</code>：</p>
<blockquote>
<p>day4/gee/logger.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Logger() HandlerFunc &#123;
    return func(c *Context) &#123;
        &#x2F;&#x2F; start timer
        t :&#x3D; time.Now()
        &#x2F;&#x2F; process request
        c.Next()
        &#x2F;&#x2F; calculate resolution time
        log.Printf(&quot;[%d] %s in %v&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))
    &#125;
&#125;</code></pre>
<p>另外，支持设置多个中间件，依次进行调用。</p>
<p>在第四天的 "分组控制 Group Control"讲到，中间件是应用在<code>RouterGroup</code>上的，应用在最顶层的Group，相当于作用域全局，所有的请求都会被中间件处理。那为什么不作用在每一条路由规则上呢？作用在某条路由规则，那还不如用户直接在Handler中调用。只作用在某条路由规则的功能通透性太差，不适合定义为中间件。</p>
<p>我们之前的框架设计是这样的，当接收到请求后，匹配路由，该请求的所有信息都保存在<code>Context</code>中。中间件也不例外，接收到请求后，应查找所有应作用于该路由的中间件，保存在<code>Context</code>中，依次进行调用。为什么依次调用后，还需要在<code>Context</code>中保存呢？因为在设计中，中间件不仅作用在处理流程前，也可以作用在处理流程后，即在用户定义的Handler处理完毕后，还可以执行剩下的操作。</p>
<blockquote>
<p>day4/gee/context.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Context struct &#123;
    &#x2F;&#x2F; origin objects
    Writer http.ResponseWriter
    Req *http.Request
    &#x2F;&#x2F; request info
    Path string
    Method string
    Params map[string]string
    &#x2F;&#x2F; response info
    StatusCode int
    &#x2F;&#x2F; middleware
    handlers []HandlerFunc
    index int
&#125;

func newContext(w http.RequestWriter, req *http.Request) *Context &#123;
    return &amp;Context &#123;
        Path: req.URL.Path,
        Method: req.Method,
        Req: req,
        Writer: w,
        index: -1,
    &#125;
&#125;

func (c *Context) Next() &#123;
    c.index++
    s :&#x3D; len(c.handlers)
    for ; c.index &lt; s; c.index++ &#123;
        c.handlers[c.index](c)
    &#125;
&#125;</code></pre>
<p><code>index</code>是记录当前执行到第几个中间件，当在中间件调用<code>Next</code>方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在<code>Next</code>方法之后定义的部分。如果我们将用户在映射路由时定义的<code>Handler</code>添加到<code>c.handlers</code>列表中，结果会怎么样呢？</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func A(c *Context) &#123;
    part1
    c.Next()
    part2
&#125;

func B(c *Context) &#123;
    part3
    c.Next()
    part4
&#125;</code></pre>
<p>假设我们应用了中间件A和B，和路由映射的Handler。<code>c.handlers</code>是这样的 <code>[A, B, Handler]</code>，<code>c.index</code>初始化为-1。调用<code>c.Next()</code>，接下来的流程是这样的：</p>
<ul>
<li>c.index++ , c.index=0</li>
<li>0 &lt; 3 , 调用<code>c.handlers[0]</code>，即A</li>
<li>执行part1，调用<code>c.Next()</code></li>
<li>c.index++，c.index=1</li>
<li>1 &lt; 3 , 调用<code>c.handlers[1]</code>，即B</li>
<li>执行part3，调用<code>c.Next()</code></li>
<li>c.index++ , c.index=2</li>
<li>2 &lt; 3 , 调用<code>c.handlers[2]</code>，即Handler</li>
<li>Handler调用完毕，返回到B中的part4，执行part4</li>
<li>part4执行完毕，返回到A中的part2，执行part2</li>
<li>part2执行完毕，结束</li>
</ul>
<p>说重点，执行顺序是<code>part1 -&gt; part3 -&gt; Handler -&gt; part4 -&gt;part2</code>。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。</p>
<h4 id="代码实现">代码实现</h4>
<p>定义<code>Use</code>函数，将中间件应用到某个Group</p>
<blockquote>
<p>day4/gee/gee.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Use is defined to add middlewares to the group
func (group *RouterGroup) Use(middlewares ...HandlerFunc) &#123;
    group.middlewares &#x3D; append(group.middlewares, middlewares...)
&#125;

func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;
    var middlewares []HandlerFunc
    for _, group :&#x3D; range engine.groups &#123;
        if strings.HasPrefix(req.URL.Path, group.prefix) &#123;
            middlewares &#x3D; append(middlewares, group.middlewares...)
        &#125;
    &#125;
    c :&#x3D; newContext(w, req)
    c.handlers &#x3D; middlewares
    engine.router.handle(c)
&#125;</code></pre>
<p>ServeHTTP函数也有变化，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过URL的前缀来判断。得到中间件列表，赋值给<code>c.handlers</code>。</p>
<p>handle函数中，将从路由匹配得到的Handler添加到<code>c.handlers</code>列表中，执行<code>c.Next()</code>。</p>
<blockquote>
<p>day4/gee/router.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *router) handle(c *Context) &#123;
    n, params :&#x3D; r.getRoute(c.Method, c.Path)
    
    if n !&#x3D; nil &#123;
        key :&#x3D; c.Method + &quot;-&quot; +n.pattern
        c.Params &#x3D; params
        c.handlers &#x3D; append(c.handlers, r.handlers[key])
    &#125; else &#123;
        c.handlers &#x3D; append(c.handlers, func(c *Context) &#123;
            c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)
        &#125;)
    &#125;
    c.Next()
&#125;</code></pre>
<h4 id="使用demo-2">使用demo</h4>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func onlyForV2() gee.HandlerFunc &#123;
    return func(c *gee.Context) &#123;
        &#x2F;&#x2F; start timer
        t :&#x3D; time.Now()
        &#x2F;&#x2F; if a server error occurred
        c.Fail(500, &quot;Internal Server Error&quot;)
        &#x2F;&#x2F; Calculate resolution time
        log.Printf(&quot;[%d] %s in %v for group v2&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))
    &#125;
&#125;

func main() &#123;
    r :&#x3D; gee.New()
    r.Use(gee.Logger()) &#x2F;&#x2F; global middleware
    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;
        c.HTML(http.StatusOK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;&quot;)
    &#125;)
    
    v2 :&#x3D; r.Group(&quot;&#x2F;v2&quot;)
    v2.Use(onlyForV2())
    &#123;
        v2.GET(&quot;&#x2F;hello&#x2F;:name&quot;, func(c *gee.Context) &#123;
            &#x2F;&#x2F; expect &#x2F;hello&#x2F;gee
            c.String(http.StatisOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Param(&quot;name&quot;), c.Path)
        &#125;)
    &#125;
    
    c.Run(&quot;:9999&quot;)
&#125;</code></pre>
<p><code>gee.Logger()</code>即我们一开始就介绍的中间件，我们将这个中间件和框架代码放在了一起，作为框架默认提供的中间件。在这个例子中，我们将<code>gee.Logger()</code>应用在了全局，所有的路由都会应用该中间件。<code>onlyForV2()</code>是用来测试功能的，尽在<code>v2</code>对应的Group中应用了。</p>
<p>接下来使用curl测试，可以看到，v2 Group 2个中间件都生效了。</p>
<pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;
&lt;h1&gt;Hello Gee&lt;&#x2F;h1&gt;

$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;v2&#x2F;hello&#x2F;abc
&#123;&quot;message&quot;:&quot;Internal Server Error&quot;&#125;</code></pre>
<p>服务器端</p>
<pre class="line-numbers language-none"><code class="language-none">2022&#x2F;07&#x2F;27 16:00:01 [200] &#x2F; in 300ns
2022&#x2F;07&#x2F;27 16:00:28 [500] &#x2F;v2&#x2F;hello&#x2F;abc in 0s for group v2
2022&#x2F;07&#x2F;27 16:00:28 [500] &#x2F;v2&#x2F;hello&#x2F;abc in 1.6176ms</code></pre>
<p>这里的测试v2中间件，一开始，测试了很多次，返回的都是500错误码，比对了源码很久，没发现问题，再次运行curl测试，还是返回500错误码。后面查阅了第五天的评论区，发现，day5的中间件仅仅用来演示，发送500错误码表示中间件起作用了。</p>
<h3 id="day6.-模板-html-template">day6. 模板 (HTML Template)</h3>
<ul>
<li>实现静态资源服务 (Static Resource)</li>
<li>支持HTML模板渲染</li>
</ul>
<h4 id="服务器渲染">服务器渲染</h4>
<p>现在越来越流行前后端分离的开发模式，即 Web 后端提供RESTful接口，返回结构化的数据 (通常为JSON或XML)。前端使用AJAX 技术请求到所需的数据，利用 JavaScript 进行渲染。Vue/React 等前端框架持续火热，这种开发模式前后端解耦，优势很突出。后端打工人专心解决资源利用，并发，数据库等问题，只需要考虑数据如何生成；前端打工人专注于界面设计实现，只需要考虑拿到数据后如何渲染即可。后端只关注于数据，接口返回值是结构化的，于前端解耦。同一套后端服务能够同时支撑小程序，移动app，pc端 Web界面，以及对外提供的接口。随着前端工程化的不断发展，Webpack，gulp等工具层出不穷，前端技术越来越自成体系了。</p>
<p>但是前后端分离的一大问题在于，页面是在客户端渲染的，比如浏览器，这对爬虫并不友好。</p>
<p>今天的内容便是介绍 Web框架如何支持服务端渲染的场景。</p>
<h4 id="静态文件-serve-static-files">静态文件 (Serve Static Files)</h4>
<p>网页三剑客，js，css，html。要做到服务端渲染，第一步便是要支持js，css等静态文件。之前设计动态路由的时候，支持通配符<code>*</code>匹配多级子路径。比如路由规则<code>/assets/*filepath</code>，可以匹配<code>/assets/</code>开头的所有地址。例如<code>/assets/js/geek.js</code>，匹配后，参数<code>filepath</code>旧赋值为<code>js/geek.js</code>。</p>
<p>那么如果我们将所有静态文件放在<code>/usr/web</code>目录下，那么<code>filepath</code>的值既是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p>
<p>找到文件后，如何返回这一文件，<code>net/http</code>库已经实现了。因此，gee框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给<code>http.FileServer</code>处理就好了。</p>
<blockquote>
<p>day6/gee/gee.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; create static handler
func (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc &#123;
    absolutePath :&#x3D; path.Join(group.prefix, relativePath)
    fileServer :&#x3D; http.StripPrefix(absolutePath, http.FileServer(fs))
    return func(c *Context) &#123;
        file :&#x3D; c.Param(&quot;filepath&quot;)
        &#x2F;&#x2F; check if file exists and&#x2F;or if we have permission to access it
        if _, err :&#x3D; fs.Open(file); err !&#x3D; nil &#123;
            c.Status(http.StatusNotFound)
            return
        &#125;
        
        fileServer.ServeHTTP(c.Writer, c.Req)
    &#125;
&#125;

&#x2F;&#x2F; serve static files
func (group *RouterGroup) Static(relativePath string, root string) &#123;
    handler :&#x3D; group.createStaticHandler(relativePath, http.Dir(root))
    urlPattern :&#x3D; path.Join(relativePath, &quot;&#x2F;*filepath&quot;)
    &#x2F;&#x2F; Register GET handlers
    group.GET(urlPattern, handler)
&#125;</code></pre>
<p>我们给<code>RouterGroup</code>添加了两个方法，<code>Static</code>这个方法是暴露给用户的。用户可以将磁盘上的某个文件夹<code>root</code>映射到路由<code>relativePath</code>。例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">r :&#x3D; gee.New()
r.Static(&quot;&#x2F;assets&quot;, &quot;&#x2F;usr&#x2F;Jayden&#x2F;blog&#x2F;static&quot;)
&#x2F;&#x2F; 或者相对路径 r.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;static&quot;)
r.Run(&quot;:9999&quot;)</code></pre>
<p>用户访问<code>localhost:9999/assets/js/geek.js</code></p>
<p>最终返回<code>/usr/geek/blog/static/js/geek.js</code>。</p>
<h4 id="html-模板渲染">HTML 模板渲染</h4>
<p>golang内置了<code>text/template</code>和<code>html/template</code>2个模板标准库，其中 <a target="_blank" rel="noopener" href='https://golang.org/pkg/html/template'>html/template</a> 为 HTML提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。gee框架的模板渲染直接使用了<code>html/template</code>提供的能力。</p>
<blockquote>
<p>day6/gee/gee.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">Engine struct &#123;
    *RouterGroup
    router *router
    groups []*RouterGroup &#x2F;&#x2F; store all groups
    htmlTemplate *template.Template &#x2F;&#x2F; for html render
    funcMap template.FuncMap &#x2F;&#x2F; for html render
&#125;

func (engine *Engine) SetFuncMap(funcMap template.FuncMap) &#123;
    engine.funcMap &#x3D; funcMap
&#125;

func (engine *Engine) LoadHTMLGlob(pattern string) &#123;
    engine.htmlTemplates &#x3D; template.Must(template.New(&quot;&quot;).Funcs(engine.funcMap).ParseGlob(pattern))
&#125;</code></pre>
<p>首先为 Engine 实例添加了<code>*template.Template</code>和<code>template.FuncMap</code>对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p>
<p>另外，给用户分别提供了设置自定义渲染函数<code>funcMap</code>和加载模板的方法。</p>
<p>接下来，对原来的<code>(*Context).HTML()</code>方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p>
<blockquote>
<p>day6/gee/context.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Context struct &#123;
    &#x2F;&#x2F; ..
    &#x2F;&#x2F; engine pointer
    engine *Engine
&#125;

func (c *Context) HTML(code int, name string, data interface&#123;&#125;) &#123;
    c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)
    c.Status(code)
    if err :&#x3D; c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err !&#x3D; nil &#123;
        c.Fail(500, err.Error())
    &#125;
&#125;</code></pre>
<p>我们在<code>Context</code>中添加了成员变量<code>engine *Engine</code>，这样就能够通过Context访问 Engine 中的HTML模板。实例化Context时，还需要给<code>c.engine</code>赋值。</p>
<blockquote>
<p>day6/gee/gee.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;
    &#x2F;&#x2F; ...
    c :&#x3D; newContext(w, req)
    c.handlers &#x3D; middlewares
    c.engine &#x3D; engine
    engine.router.handle(c)
&#125;</code></pre>
<h4 id="使用demo-3">使用Demo</h4>
<p>最终目录结构</p>
<pre class="line-numbers language-none"><code class="language-none">---gee&#x2F;
---static&#x2F;
   |---css&#x2F;
       |---geek.css
   |---file1.txt
---template
   |---arr.tmpl
   |---css.tmpl
   |---custom_func.tmpl
---main.go</code></pre>
<blockquote>
<p>day6/templates/arr.tmpl</p>
</blockquote>
<pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;html&gt;
    &lt;body&gt;
        &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;&#x2F;p&gt;
        &#123;&#123;range $index, $ele :&#x3D;.stuArr&#125;&#125;
        &lt;p&gt;&#123;&#123; $index&#125;&#125;: &#123;&#123;$ele.Name&#125;&#125; is &#123;&#123; $ele.Age&#125;&#125; years old&lt;&#x2F;p&gt;
        &#123;&#123;end&#125;&#125;
    &lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>
<blockquote>
<p>day6/template/css.tmpl</p>
</blockquote>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;
    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;assets&#x2F;css&#x2F;geek.css&quot;&gt;
    &lt;p&gt;geek.css is loaded&lt;&#x2F;p&gt;
&lt;&#x2F;html&gt;</code></pre>
<blockquote>
<p>day6/template/custom_func.tmpl</p>
</blockquote>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;
    &lt;body&gt;
        &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;&#x2F;p&gt;
        &lt;p&gt;Date: &#123;&#123;.now | FormatDate&#125;&#125;&lt;&#x2F;p&gt;
    &lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>
<blockquote>
<p>day6/main.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type student struct &#123;
    Name string
    Age int8
&#125;

func FormatAsDate(t time.Time) string &#123;
    year, month, day :&#x3D; t.Date()
    return fmt.Sprintf(&quot;%d-%02d-%02d&quot;, year, month, day)
&#125;

func main() &#123;
    r :&#x3D; gee.New()
    r.Use(gee.Logger())
    r.SetFuncMap(template.FuncMap&#123;
        &quot;FormatAsDate&quot;: FormatAsDate,
    &#125;)
    r.LoadHTMLGlob(&quot;templates&#x2F;*&quot;)
    r.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;static&quot;)
    
    stu1 :&#x3D; &amp;student&#123;Name: &quot;gee&quot;, Age: 20&#125;
    stu2 :&#x3D; &amp;student&#123;Name: &quot;Jay&quot;, Age: 22&#125;
    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;
        c.HTML(http.StatusOK, &quot;css.tmpl&quot;, nil)
    &#125;)
    r.GET(&quot;&#x2F;students&quot;, func(c *gee.Context) &#123;
        c.HTML(http.StatusOK), &quot;arr.tmpl&quot;, gee.H&#123;
            &quot;title&quot;: &quot;gee&quot;,
            &quot;stuArr&quot;: [2]*student&#123;stu1, stu2&#125;,
        &#125;)
    &#125;)
    
    r.GET(&quot;&#x2F;students&quot;, func(c *gee.Context) &#123;
        c.HTML(http.StatusOK, &quot;custom_func.tmpl&quot;, gee.H&#123;
            &quot;title&quot;: &quot;gee&quot;,
            &quot;now&quot;: time.Date(2019,8,17,0,0,0,0,time.UTC)
        &#125;)
    &#125;)
    
    r.Run(&quot;:9999&quot;)
&#125;</code></pre>
<p>在浏览器访问主页，模板正常渲染，css静态文件加载成功</p>
<p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day6.png'></p>
<h3 id="day7.-错误恢复-panic-recover">day7. 错误恢复 (Panic Recover)</h3>
<blockquote>
<p>实现错误处理机制</p>
</blockquote>
<h4 id="panic">panic</h4>
<p>golang中，比较常见的错误处理方法是返回error，由调用者决定后续如何处理。但是如果是无法恢复的错误，可以手动触发panic，当然如果在程序运行过程中出现了类似于数组越界的错误，panic也会被触发。panic会中止当前执行的程序，退出。</p>
<p>下面是主动触发的例子：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main
&#x2F;&#x2F; hello.go
func main() &#123;
    fmt.Println(&quot;before panic&quot;)
    panic(&quot;crash&quot;)
    fmt.Println(&quot;after panic&quot;)
&#125;</code></pre>
<pre class="line-numbers language-none"><code class="language-none">$ go run hello.go

before panic 
panic: crash

goroutine 1 [running]:
main.main()
        ~&#x2F;*your path*&#x2F;hello.go:5 +0x95
exit status 2</code></pre>
<p>下面是数组越界触发的panic</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main
&#x2F;&#x2F; hello.go
func main() &#123;
    arr :&#x3D; []int&#123;1, 2, 3&#125;
    fmt.Println(arr[4])
&#125;</code></pre>
<pre class="line-numbers language-none"><code class="language-none">$ go run hello.go
panic: runtime error: index out of range [4] with legnth 3</code></pre>
<h4 id="defer">defer</h4>
<p>panic会导致程序被中止，但是在退出前，会先处理完当前携程上已经defer的任务，执行完成后再退出。效果类似于Java语言的<code>try...catch</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main
&#x2F;&#x2F; hello.go
func main() &#123;
    defer func() &#123;
        fmt.Println(&quot;defer func&quot;)
    &#125;()
    
    arr :&#x3D; []int &#123;1, 2, 3&#125;
    fmt.Println(arr[4])
&#125;</code></pre>
<pre class="line-numbers language-none"><code class="language-none">$ go run hello.go
defer func
panic: runtime error: index out of range [4] with length 3</code></pre>
<p>可以defer多个任务，在同一个函数中defer多个任务，会逆序执行。即先执行最后的defer的任务 (类似于栈)。</p>
<p>在这里，defer的任务执行完成之后，panic还会继续被抛出，导致程序非正常结束。</p>
<h4 id="recover">recover</h4>
<p>golang还提供了recover函数，可以避免因为panic发生而导致整个程序终止，recover函数只在defer中生效</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; recover.go
func test_recover() &#123;
    defer func() &#123;
        fmt.Println(&quot;defer func&quot;)
        if err :&#x3D; recover(); err !&#x3D; nil &#123;
            fmt.Println(&quot;recover success&quot;)
        &#125;
    &#125;()
    
    arr :&#x3D; []int&#123;1, 2, 3&#125;
    fmt.Println(arr[4])
    fmt.Println(&quot;after panic&quot;)
&#125;</code></pre>
<pre class="line-numbers language-none"><code class="language-none">$ go run recover.go
defer func
recover success
after recover</code></pre>
<p>我们可以看到，recover捕获了panic，程序正常结束。<code>test_recover()</code>中的after panic没有打印，这是正确的，当panic被触发时，控制权就被交给了defer。就像在Java中，<code>try</code>代码块中发生了异常，控制权交给了<code>catch</code>，接下来执行catch代码块中的代码。而在<code>main()</code>中打印了after recover，说明程序已经恢复正常，继续往下执行到结束。</p>
<h4 id="gee的错误处理机制">Gee的错误处理机制</h4>
<p>对一个Web框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p>
<p>我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发panic的bug，就很容易宕机。</p>
<p>看下面示例代码</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; hello.go
func main() &#123;
    r :&#x3D; gee.New()
    r.GET(&quot;&#x2F;panic&quot;, func(c *gee.Context) &#123;
        names :&#x3D; []string&#123;&quot;gee&quot;&#125;
        c.String(http.StatusOK, names[100])
    &#125;)
    r.Run(&quot;:9999&quot;)
&#125;</code></pre>
<p>在上面的代码中，我们为gee注册了路由<code>/panic</code>，而这个路由的处理函数内部存在数组越界<code>names[100]</code>，如果访问<code>localhost:9999/panic</code>，web服务器就会宕掉。</p>
<p>今天，我们将在gee中添加一个添加一个非常简单的错误处理机制，即在此类错误发生时，向用户返回 Internal Server Error，并且在日志中打印必要的错误信息，方便进行错误定位。</p>
<p>我们之前实现了中间件机制，错误处理也可以作为一个中间件，增强gee框架的能力。</p>
<blockquote>
<p>day7/gee/recovery.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package gee

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&#x2F;http&quot;
    &quot;runtime&quot;
    &quot;strings&quot;
)

&#x2F;&#x2F; print stack trace for debug
func trace(message string) string &#123;
    var pcs [32]uintptr
    n :&#x3D; runtime.Callers(3, pcs[:]) &#x2F;&#x2F; skip first 3 caller
    
    var str strings.Builder
    str.WriteString(message + &quot;\nTraceback: &quot;)
    for _, pc :&#x3D; range pcs[:n] &#123;
        fn :&#x3D; runtime.FuncForPC(pc)
        file, line :&#x3D; fn.FileLine(pc)
        str.WriteString(fmt.Sprintf(&quot;\n\t%s:%d&quot;, file, line))
    &#125;
    return str.String()
&#125;

func Recovery() HandlerFunc &#123;
    return func(c *Context) &#123;
        defer func() &#123;
            if err :&#x3D; recover(); err !&#x3D; nil &#123;
                message :&#x3D; fmt.Sprintf(&quot;%s&quot;, err)
                log.Printf(&quot;%s\n\n&quot;, trace(message))
                c.Fail(http.StatusInternalServerError, &quot;Internal Server Error&quot;)
            &#125;
        &#125;()
        c.Next()
    &#125;
&#125;</code></pre>
<p><code>Recovery()</code>的实现很简单，使用defer挂载上错误恢复的函数，在这个函数中调用<code>recover()</code>，捕获panic，并且将堆栈信息打印在日志里，向用户返回Internal Server Error。</p>
<p>在<code>trace()</code>中，调用了<code>runtime.Callers(3, pcs[:])</code>，Callers用来返回调用栈的程序计数器，第0个Caller是Callers本身，第一个是上一层trace，第二个是再上一层的<code>defer func</code>。因此，为了日志简洁一点，我们跳过前三个Caller。</p>
<p>接下来，通过<code>runtime.FuncForPC(pc)</code>获取对应的函数，再通过<code>fn.FileLine(pc)</code>获取到调用该函数的文件名和行号，打印在日志里。</p>
<p>至此，gee框架的错误处理机制就完成了。</p>
<blockquote>
<p>day7/gee/gee.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Default() *Engine &#123;
    engine :&#x3D; New()
    engine.Use(Logger(), Recovery())
    return engine
&#125;</code></pre>
<h4 id="使用demo-4">使用Demo</h4>
<blockquote>
<p>day7/main.go</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
    &quot;net&#x2F;http&quot;
    &quot;gee&quot;
)

func main() &#123;
    r :&#x3D; gee.Default()
    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;
        c.String(http.StatusOK, &quot;hello gee\n&quot;)
    &#125;)
    &#x2F;&#x2F; index out of range for testing Recovery()
    r.GET(&quot;&#x2F;panic&quot;, func(c *gee.Context) &#123;
        names :&#x3D; []string&#123;&quot;gee&quot;&#125;\
        c.String(http.StatusOK, names[100])
    &#125;)
    r.Run(&quot;:9999&quot;)
&#125;</code></pre>
<p>下面来进行测试，先访问一个主页，访问一个有bug的<code>/panic</code>，服务正常返回。接下来我们再一次成功访问了主页，说明服务完全运转正常。</p>
<blockquote>
<p>Client</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">$ curl http:&#x2F;&#x2F;localhost:9999
hello gee

$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;panic
&#123;&quot;message&quot;:&quot;Internal Server Error&quot;&#125;

$ curl http:&#x2F;&#x2F;localhost:9999
hello gee</code></pre>
<blockquote>
<p>Server</p>
</blockquote>
<p>我们可以在后台日志中看到如下内容，引发错误的原因和堆栈信息都被打印了出来，通过日志，我们可以很容易知道，在day7/main.go:47的地方出现了<code>index out of range</code>的错误。</p>
<pre class="line-numbers language-none"><code class="language-none">2022&#x2F;07&#x2F;29 22:15:43 Route  GET - &#x2F;
2022&#x2F;07&#x2F;29 22:15:43 Route  GET - &#x2F;panic
2022&#x2F;07&#x2F;29 22:15:45 runtime error: index out of range [100] with length 1
Traceback:
    &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;panic.go:838
        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;panic.go:89
        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;main.go:17
        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;context.go:41
        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;recovery.go:56
        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;context.go:41
        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;logger.go:15
        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;context.go:41
        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;router.go:101
        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;gee.go:121
        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;http&#x2F;server.go:2917
        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;http&#x2F;server.go:1967
        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;asm_amd64.s:1572
2022&#x2F;07&#x2F;29 22:15:45 [500] &#x2F;panic in 103.5μs</code></pre>
<h3 id="一些想法">一些想法</h3>
<p>其实整篇做下来吧，其实到现在对整个框架只能够说是大概了解，自己也跟着博客敲了一遍，也大概能看懂作者的设计思路，先做一个简单的http相应，后面再添加Context、前缀树等等。</p>
<p>在做的过程中，也会遇到很多bug，不同于c，Java，golang这门语言，个人感觉抽象程度比Java这些高，有时候出现panic，找到了出错的行数，还得去翻阅源码，不过吧，这个也算是在锻炼自己的动手能力和解决问题的能力，也算是有些收获吧。</p>
<h3 id="参考链接">参考链接</h3>
<p><a target="_blank" rel="noopener" href="https://geektutu.com/post/gee.html">7天用Go从零实现Web框架Gee教程 | 极客兔兔 (geektutu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52649917/article/details/121640535">(79条消息) 解决vscode和go mod 导包冲突的问题_sora!的博客-CSDN博客_gomod vscode</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiu_huouho/article/details/120733522">(80条消息) vscode使用go get 之后无法import_Restart丶的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://vimsky.com/examples/usage/fmt-fprintf-function-in-golang-with-examples.html">Golang fmt.Fprintf()用法及代码示例 - 纯净天空 (vimsky.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/maji233/p/11178413.html">理解Golang中的interface和interface{} - maji233 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://laravelacademy.org/post/21639">Go 语言通过 Request 对象读取 HTTP 请求报文 | 请求处理 | Go Web 编程 (laravelacademy.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.imooc.com/wenda/detail/664445#:~:text=http.ResponseWriter用来配置HTTP响应和发送数据给客户端的也是这样一个，io.Writer你要发送的数据（响应体）是通过调用组装的（不一定只有一次）ResponseWriter.Write,()（这是实现通用的io.Writer）.">ResponseWriter.Write 和 io.WriteString 有什么区别？_慕课猿问 (imooc.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qwe1765667234/article/details/124299251?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-124299251-blog-109959201.pc_relevant_multi_platform_whitelistv1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-124299251-blog-109959201.pc_relevant_multi_platform_whitelistv1&amp;utm_relevant_index=10">(79条消息) Go net.http包下的ListenAndServe函数的参数问题_qwe1765667234的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34021712/article/details/109959201">(79条消息) Go使用net/http标准库(二)源码学习之- http.ListenAndServe()_这个名字想了很久的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/ask/sof/206511">ServeHTTP是如何工作的？ - 问答 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Golang/" rel="tag"># Golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/0x002E.html" rel="prev" title="摄影的哲与思">
                  <i class="fa fa-chevron-left"></i> 摄影的哲与思
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/0x0030.html" rel="next" title="Java swing实现应用程序对数据库的访问">
                  Java swing实现应用程序对数据库的访问 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jayden Chang</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">467k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">7:04</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/code-unfold.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"enable","tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"jayden-valine-vercel.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"填写邮箱可以及时收到回复哦ヾ(≧▽≦*)o","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","recordIP":true,"el":"#waline","comment":true,"path":"/post/0x002F.html"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>




</body>
</html>
