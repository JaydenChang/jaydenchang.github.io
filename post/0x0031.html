<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="https://avatars.githubusercontent.com/u/72348653?v=4">
  <link rel="icon" type="image/png" sizes="32x32" href="https://avatars.githubusercontent.com/u/72348653?v=4">
  <link rel="icon" type="image/png" sizes="16x16" href="https://avatars.githubusercontent.com/u/72348653?v=4">
  <link rel="mask-icon" href="https://avatars.githubusercontent.com/u/72348653?v=4" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jaydenchang.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="用七天时间实现用Golang一个RPC框架">
<meta property="og:type" content="article">
<meta property="og:title" content="动手写RPC框架">
<meta property="og:url" content="https://jaydenchang.top/post/0x0031.html">
<meta property="og:site_name" content="Jayden&#39;s Blog">
<meta property="og:description" content="用七天时间实现用Golang一个RPC框架">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jaydenchang.top/post/0x0031/0x0031-5.png">
<meta property="og:image" content="https://jaydenchang.top/post/0x0031/0x0031-7.jpg">
<meta property="article:published_time" content="2022-10-15T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-27T08:40:39.365Z">
<meta property="article:author" content="Jayden Chang">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jaydenchang.top/post/0x0031/0x0031-5.png">


<link rel="canonical" href="https://jaydenchang.top/post/0x0031.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://jaydenchang.top/post/0x0031.html","path":"/post/0x0031.html","title":"动手写RPC框架"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>动手写RPC框架 | Jayden's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Jayden's Blog" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Jayden's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">15</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">8</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">55</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#day0.-%E6%B5%85%E8%B0%88rpc%E6%A1%86%E6%9E%B6"><span class="nav-text">day0. 浅谈RPC框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%88%E8%B0%88rpc%E6%A1%86%E6%9E%B6"><span class="nav-text">1. 谈谈RPC框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rpc%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-text">2. RPC框架需要解决什么问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day1.-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E6%B6%88%E6%81%AF%E7%BC%96%E7%A0%81"><span class="nav-text">day1. 服务端与消息编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">消息的序列化与反序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-text">通信过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">服务端的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#main-%E5%87%BD%E6%95%B0-%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">main 函数 (一个简易的客户端)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day2.-%E6%94%AF%E6%8C%81%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">day2. 支持并发和异步的客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#call-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">Call 的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-client"><span class="nav-text">实现 Client</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#demo"><span class="nav-text">Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day3.-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="nav-text">day3. 服务注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%A0%E5%B0%84%E4%B8%BA%E6%9C%8D%E5%8A%A1"><span class="nav-text">结构体映射为服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0-service"><span class="nav-text">通过反射实现 service</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#service-%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-text">service 的测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-text">集成到服务端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#demo-1"><span class="nav-text">Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day4.-%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86"><span class="nav-text">day4. 超时处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">为什么要超时处理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6"><span class="nav-text">创建连接超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#client.call-%E8%B6%85%E6%97%B6"><span class="nav-text">Client.Call 超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E8%B6%85%E6%97%B6"><span class="nav-text">服务端处理超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-text">测试用例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day5.-%E6%94%AF%E6%8C%81http%E5%8D%8F%E8%AE%AE"><span class="nav-text">day5. 支持HTTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81-http-%E5%8D%8F%E8%AE%AE%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-text">支持 HTTP 协议需要做什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%AF%E6%8C%81-http-%E5%8D%8F%E8%AE%AE"><span class="nav-text">服务端支持 HTTP 协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%AF%E6%8C%81-http-%E5%8D%8F%E8%AE%AE"><span class="nav-text">客户端支持 HTTP 协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84-debug-%E9%A1%B5%E9%9D%A2"><span class="nav-text">实现简单的 DEBUG 页面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#demo-2"><span class="nav-text">Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day6.-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">day6. 负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="nav-text">负载均衡策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-text">服务发现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">支持负载均衡的客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#demo-3"><span class="nav-text">Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day7.-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-text">day7. 服务发现与注册中心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">注册中心的位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gee-registry"><span class="nav-text">Gee Registry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#geeregistrydiscovery"><span class="nav-text">GeeRegistryDiscovery</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#demo-4"><span class="nav-text">Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95"><span class="nav-text">一些想法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84-rpc-%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">典型的 RPC 调用过程</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jayden Chang"
      src="https://avatars.githubusercontent.com/u/72348653?v=4">
  <p class="site-author-name" itemprop="name">Jayden Chang</p>
  <div class="site-description" itemprop="description">身在井隅，心向星光。眼中有诗，自在远方。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/JaydenChang" title="Github → https:&#x2F;&#x2F;github.com&#x2F;JaydenChang" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jaydenc1830@gmail.com" title="E-Mail → mailto:jaydenc1830@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/JaydenChang7" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;JaydenChang7" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/@jaydenchang7" title="YouTuBe → https:&#x2F;&#x2F;www.youtube.com&#x2F;@jaydenchang7" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTuBe</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/jaydenchang7" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;jaydenchang7" rel="noopener me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://500px.com.cn/jaydenchang" title="500px → https:&#x2F;&#x2F;500px.com.cn&#x2F;jaydenchang" rel="noopener me" target="_blank"><i class="fa-brands fa-500px fa-fw"></i>500px</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jaydenchang.top/post/0x0031.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/72348653?v=4">
      <meta itemprop="name" content="Jayden Chang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jayden's Blog">
      <meta itemprop="description" content="身在井隅，心向星光。眼中有诗，自在远方。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="动手写RPC框架 | Jayden's Blog">
      <meta itemprop="description" content="用七天时间实现用Golang一个RPC框架">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动手写RPC框架
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-16 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-16T00:00:00+08:00">2022-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BackEnd/" itemprop="url" rel="index"><span itemprop="name">BackEnd</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>65k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:01</span>
    </span>
</div>

            <div class="post-description">用七天时间实现用Golang一个RPC框架</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><hr/>
<p>本文学习自<a target="_blank" rel="noopener" href="https://geetktutu.com">geektutu</a> ,
大部分内容摘自 <a
target="_blank" rel="noopener" href="https://geektutu.com/post/geerpc.html">7天用Go从零实现RPC框架GeeRPC
| 极客兔兔 (geektutu.com)</a>，并在此基础上稍加个人的学习经历和理解</p>
<p>作者仓库地址：<a
target="_blank" rel="noopener" href="https://github.com/geektutu/7days-golang">geektutu/7days-golang: 7
days golang programs from scratch (web framework Gee, distributed cache
GeeCache, object relational mapping ORM framework GeeORM, rpc framework
GeeRPC etc) 7天用Go动手写/从零实现系列 (github.com)</a></p>
<h3 id="day0.-浅谈rpc框架">day0. 浅谈RPC框架</h3>
<p>前几天在学 6.824 时，发现有太多内容是我完全没接触过的，然后其中涉及到
RPC 的内容又比较多，忽然想起 geektutu 出过 "七天实现 RPC 框架"
的文章，马上转坑来学习。</p>
<h4 id="谈谈rpc框架">1. 谈谈RPC框架</h4>
<p>RPC (Remote Procedure Call，远程过程调用)
是一种计算机通信协议，允许调用不同进程空间的程序。RPC
的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部实现的细节。</p>
<p>不同应用程序间的通信方式有很多，例如浏览器和服务器间广泛用基于
HTTP协议的 Restful API。与 RPC相比，Restful API
有相对统一的标准，因而更通用，兼容性更好，支持不同的语言。HTTP
协议是基于文本的，一般具备更好的可读性。但是缺点也很明显：</p>
<ul>
<li>Restful
接口要额外的定义，无论是客户端还是服务端，都需要额外的代码来处理，而 RPC
调用则更接近于直接调用。</li>
<li>基于 HTTP 协议的 Restful 报文冗余，承载了过多无效信息，而RPC
通常使用自定义的协议格式，减少冗余报文。</li>
<li>RPC
可以采用更高效的序列化协议，将文本转为二进制传输，获得更高的性能。</li>
<li>因为 RPC
的灵活性，所以更容易扩展和集成诸如注册中心，负载均衡等功能。</li>
</ul>
<h4 id="rpc框架需要解决什么问题">2. RPC框架需要解决什么问题</h4>
<p>RPC 需要解决什么问题？或者换个说法，为什么要RPC 框架？</p>
<p>我们可以想象下两台机器上，两个程序之间要通信，那么首先，需要确定采用的传输协议是什么？如果这两个程序位于不同的机器，那么一般会选择
TCP 协议活 HTTP 协议；那如果两个程序位于相同的机器，也可以选择 Unix
Socket
协议。传输协议确定后，还需要确定报文的编码格式，比如采用最常用的json
或xml，那如果报文比较大，还可能会选择 protobuf
等其他的编码方式，甚至编码之后，再进行压缩。接收端获取报文则需要相反的过程，先解压再解码。</p>
<p>解决了传输协议和保温编码的问题，接下来还需要解决一系列的可用性问题，例如，连接超时了怎么办？是否支持异步请求和并发？</p>
<p>如果服务端的实例很多，客户端并不关心这些实例的地址和部署位置，只关心自己能否获取到期待的结果，那就引出了注册中心
(registry) 和负载均衡 (load balance)
的问题。简单地说，即客户端和服务端相互不感知对方的存在，服务端启动时将自己注册到注册中心，客户端调用时，从注册中心获取到所有可用的实例，选择一个来调用。这样服务端和客户端只需要感知注册中心的存在就够了。注册中心还需要实现服务动态添加，删除，使用
"心跳机制" 确保服务处于可用状态等功能。</p>
<p>再进一步，假设服务端是不同的团队提供的，如果没有统一的RPC
框架，各个团队的服务提供方就需要各自实现一套消息编解码，连接池，收发线程，超时处理等
"业务之外" 的重复技术劳动，造成整体的低效。因此，"业务之外"
的这部分公共的能力，即是RPC 框架所需要具备的能力。</p>
<h3 id="day1.-服务端与消息编码">day1. 服务端与消息编码</h3>
<ul>
<li>使用<code>encoding/gob</code>实现消息的编解码
(序列化与反序列化)。</li>
<li>实现一个简易的服务端，仅接受消息，不处理，代码约200行。</li>
</ul>
<h4 id="消息的序列化与反序列化">消息的序列化与反序列化</h4>
<p>一个典型的RPC 调用如下</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">err &#x3D; client.call(&quot;Arith.Multiply&quot;, args, &amp;reply)</code></pre>
<p>客户端发送的请求包括服务名<code>Arith</code>，方法名<code>Multiply</code>，参数<code>args</code>三个，服务端的响应包括错误<code>error</code>，返回值<code>reply</code>
2个。我们将请求和响应中的参数和返回值抽象为 body，剩余的信息放在 header
中，那么就可以抽象出数据结构 Header：</p>
<p><strong>day1/codec/codec.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package codec

import &quot;io&quot;

type Header struct &#123;
    ServiceMethod string &#x2F;&#x2F; format &quot;Service.Method&quot;
    Seq           string &#x2F;&#x2F; sequence number chosen by client
    Error         string
&#125;</code></pre>
<ul>
<li>ServiceMethod 是服务名和方法名，通常与 Golang
中的结构体和方法相映射。</li>
<li>Seq 是请求的序号，也可以认为是某个请求的
ID，用来区分不同的请求。</li>
<li>Error 是错误信息，客户端设置为空，</li>
</ul>
<p>我们将和消息编解码相关的代码都放到 codec
子目录中，在此之前，还需要在geerpc项目根目录下使用
<code>go mod init geerpc</code> 初始化项目，方便后续子 package
之间的引用。</p>
<p>进一步，抽象出对消息体进行编解码的接口
Codec，抽象出接口是为了实现不同的 Codec 实例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Codec interface &#123;
    io.Closer
    ReadHeader(*Header) error
    ReadBody(interface&#123;&#125;) error
    Write(*Header, interface&#123;&#125;) error
&#125;</code></pre>
<p>紧接着，抽象出 Codec 的构造函数，客户端和服务端可以通过 Codec
的<code>Type</code>得到构造函数，从而创建 Codec
实例。这部分代码和工厂模式类似，与工厂模式不同的是，返回的是构造函数，而非实例。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type NewCodecFunc func(io.ReadWriteCloser) Codec 
type Type string

const (
	GobType  Type &#x3D; &quot;application&#x2F;gob&quot;
    JsonType Type &#x3D; &quot;application&#x2F;json&quot;
)

var NewCodecFuncMap map[Type]NewCodecFunc

func init() &#123;
    NewCodecFuncMap &#x3D; make(map[Type]NewCodecFunc)
    NewCodecFuncMap[GobType] &#x3D; NewGobCodec &#x2F;&#x2F; 初始化map，实例化一个GobCodec对象
&#125;</code></pre>
<p>我们定义了两种
Codec，<code>Gob</code>和<code>Json</code>，但是实际代码只实现了<code>Gob</code>一种，事实上，2者的实现非常接近，甚至只需把<code>gob</code>换成<code>json</code>即可。</p>
<p>首先定义<code>GobCodec</code>结构体，这个结构体由四部分构成，<code>conn</code>是由构建函数传入，通常是通过
TCP 或者 Unix 建立 socket 时得到的链接实例，dec 和 enc 对应 gob的
Decoder 和 Encoder，buf
是为了防止阻塞而创建的带缓冲的<code>Writer</code>，一般这么做都能提升性能。</p>
<p><strong>day1/codec/gob.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package codec

import (
    &quot;bufio&quot;
    &quot;encoding&#x2F;gob&quot;
    &quot;io&quot;
    &quot;log&quot;
)

type GobCodec struct &#123;
    conn io.ReadWriteCloser
    buf  *bufio.Writer
    dec  *gob.Decoder
    enc  *gob.Encoder
&#125;

var _ Codec &#x3D; (*GobCodec)(nil)
&#x2F;&#x2F; 这里的写法的含义是，用来检测GobCodec是否实现了Codec接口，如果没有实现该接口则编译报错

func NewGobCodec(conn io.ReadWriteCloser) Codec &#123;
    buf :&#x3D; bufio.NewWriter(conn)
    return &amp;GobCodec &#123;
        conn: conn,
        buf:  buf,
        dec:  gob.NewDecoder(conn),
        enc:  gob.NewEncoder(buf),
    &#125;
&#125;</code></pre>
<p>接着实现<code>ReadHeader</code>，<code>ReadBody</code>，<code>Write</code>和<code>Close</code>方法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (c *GobCodec) ReadHeader(h *Header) error &#123;
    return c.dec.Decode(h)
&#125;

func (c *GobCodec) ReadBody(body interface&#123;&#125;) error &#123;
    return c.dec.Decode(body)
&#125;

func (c *GobCodec) Write(h *Header, body interface&#123;&#125;) (err error) &#123;
    defer func() &#123;
        _ &#x3D; c.buf.Flush() &#x2F;&#x2F; 将缓存区内容写入文件，返回类型为error 
        if err !&#x3D; nil &#123;
            _ &#x3D; c.Close()
        &#125;
    &#125;()
    if err !&#x3D; c.enc.Encode(h); err !&#x3D; nil &#123;
        log.Println(&quot;rpc codec: gob error encoding header:&quot;, err)
        return err
    &#125;
    if err :&#x3D; c.enc.Encode(body); err !&#x3D; nil &#123;
        log.Println(&quot;rpc codec: gob error encoding body:&quot;, err)
        return err
    &#125;
    return nil
&#125;

func (c *GobCodec) Close() error &#123;
    return c.conn.Close() &#x2F;&#x2F; 返回一个err，具体的Close()在io.go中有重写
&#125;</code></pre>
<h4 id="通信过程">通信过程</h4>
<p>客户端与服务端的通信需要协商一些内容，例如 HTTP 报文，分为 header 和
body 两部分，body 的格式和长度通过 header
中的<code>Content-Type</code>和<code>Content-Length</code>指定，服务端通过解析
header 就能够知道如何从 body 中读取需要的信息。对于RPC
协议来说，这部分协商是需要自主设计的。为了提升性能，一般在报文的最开始会规划固定的字节，来协商相关的信息。比如第1个字节用来表示序列化方式，第2个字节表示压缩方式，第3-6字节表示
header 的长度，7-10字节表示body 长度。</p>
<p>对于 GeeRPC
来说，目前需要协商的唯一一项内容时消息的编解码方式。我们将这部分信息，放到结构体<code>Option</code>中承载。目前，已经进入到服务端的实现阶段了。</p>
<p><strong>day1/server.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package geerpc

const MagicNumber &#x3D; 0x23bef5c

type Option struct &#123;
    MagicNumber int        &#x2F;&#x2F; MagicNumber marks this&#39;s a geerpc request
    CodecType   codec.Type &#x2F;&#x2F; client may choose different Codec to encode body
&#125;

var DefaultOption &#x3D; &amp;Option &#123;
    MagicNumber: MagicNumber,
    CodecType:   codec.GobType,
&#125;</code></pre>
<p>一般来说，设计协商协议的这部分信息，需要设计固定的字节来传输。但是为了实现上更简单，
GeeRPC 客户端固定采用 JSON 编码 Option，后续的 header 和 body
的编码方式由 Option 中的 CodeType指定，服务端首先使用 JSON 解码
Option，然后通过 Option 的 CodeType
解码剩余内容。即报文将以这样的形式发送：</p>
<pre class="line-numbers language-none"><code class="language-none">| Option&#123;MagicNumber: xxx, CodecType: xxx&#125; | Header&#123;ServiceMethod ...&#125; | Body interface&#123;&#125; |
| &lt;-------    固定 JSON 编码       -------&gt; | &lt;--------  编码方式由 CodeType决定   -------&gt; |</code></pre>
<p>在一次连接中，Option 固定在报文的最开始，Header 和 Body
可以有很多个，即报文可能是这样的。</p>
<pre class="line-numbers language-none"><code class="language-none">| Option | Header1 | Body1 | Header2 | Body2 | ...</code></pre>
<h4 id="服务端的实现">服务端的实现</h4>
<p>通信过程已经定义清楚了，那么服务端的实现就比较直接了。</p>
<p><strong>day1/server.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Server represents an RPC Server.
type Server struct&#123;&#125;

&#x2F;&#x2F; NewServer returns a new Server.
func NewServer() *Server &#123;
    return &amp;Server&#123;&#125;
&#125;

&#x2F;&#x2F; DefaultServer is the default instance of *Server
var DefaultServer &#x3D; NewServer()

&#x2F;&#x2F; Acccept accepts connections on the listener and serves requests
&#x2F;&#x2F; for each incoming connection
func (server *Server) Accept(lis net.Listener) &#123;
    &#x2F;&#x2F; for循环等待socket连接建立
    for &#123;
        conn, err :&#x3D; lis.Accept()
        if err !&#x3D; nil &#123;
            log.Println(&quot;rpc server: accept error:&quot;, err)
            return 
        &#125;
        go server.ServeConn(conn)
    &#125;
&#125;

&#x2F;&#x2F; Accept accepts connections on the listener and serves requests
&#x2F;&#x2F; for each incoming connection
func Accept(lis net.Listener) &#123;
    DefaultServer.Accept(lis)
&#125;</code></pre>
<ul>
<li>首先定义了结构体<code>Server</code>，没有任何的成员字段。</li>
<li>实现了<code>Accept</code>方式，<code>net.Listener</code>作为参数，for
循环等待 socket
连接建立，并开启子协程处理，处理过程交给了<code>ServerConn</code>方法。</li>
<li>DefaultServer
是一个默认的<code>Server</code>实例，主要为了用户使用方便。</li>
</ul>
<p>如果想启动服务，过程是很简单的，传入 listener 即可，tcp 协议和 unix
协议都支持。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">lis, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:9999&quot;)
geerpc.Accept(lis)</code></pre>
<p><code>ServeConn</code>的实现就和之前讨论的通信过程紧密相关了，首先使用<code>json.NewDecoder</code>反序列化得到
Option 实例，检查 MagicNumber 和 CodeType的值是否正确。然后根据 CodeType
得到对应的消息编解码器，接下来的处理就交给<code>serverCodec</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; ServeConn runs the serer on a single connection
&#x2F;&#x2F; ServeConn blocks, serving the connection until the client hangs up
func (server *Server) ServeConn(conn io.ReadWriteCloser) &#123;
    defer func() &#123;
        _ &#x3D; conn.Close()
    &#125;()
    if err :&#x3D; json.NewDecoder(conn).Decode(&amp;opt); err !&#x3D; nil &#123;
        log.Println(&quot;rpc server: options error:&quot;, err)
        return
    &#125;
    &#x2F;&#x2F; 检查Option的参数是否正确
    if opt.MagicNumber !&#x3D; MagicNumber &#123;
        log.Printf(&quot;rpc server: invalid magic number %x&quot;, opt.MagicNumber)
        return
    &#125;
    f :&#x3D; codec.NewCodecFuncMap[opt.CodecType]
    if f &#x3D;&#x3D; nil &#123;
        log.Printf(&quot;rpc server: invalid codec type %s&quot;, opt.CdoecType)
        return
    &#125;
    server.serveCodec(f(conn))
&#125;

&#x2F;&#x2F; invalidRequest is a placeholder for response argv when error occurs
var invalidRequest &#x3D; struct&#123;&#125;&#123;&#125;

&#x2F;&#x2F; 注意这里要改serveCodec的入参
func (server *Server) serveCodec(cc codec.Codec, opt *Option) &#123;
    sending :&#x3D; new(sync.Mutex) &#x2F;&#x2F; make sure to send a complete response
    &#x2F;&#x2F; 加入一个互斥锁避免多个回复报文交织在一起
    wg :&#x3D; new(sync.WaitGroup) &#x2F;&#x2F; wait until all request are handled
    for &#123;
        req, err :&#x3D; server.readRequest(cc) &#x2F;&#x2F; 读取请求
        if err !&#x3D; nil &#123;
            if req &#x3D;&#x3D; nil &#123;
                break &#x2F;&#x2F; it&#39;s not possible to recover, so close the connection
            &#125;
            req.h.Error &#x3D; err.Error()
            server.sendResponse(cc, req.h, invalidRequest, sending)
            &#x2F;&#x2F; 回复请求
            continue
        &#125;
        wg.Add(1)
        go server.handleRequest(cc, req, sending, wg, opt.HandleTimeout)
        &#x2F;&#x2F; 加入一个处理请求协程
        &#x2F;&#x2F; 这里注意要新增一个超时时间
    &#125;
    wg.Wait()
    _ &#x3D; cc.Close()
&#125;</code></pre>
<p><code>serveCodec</code>的过程很简单，主要包含三阶段：</p>
<ul>
<li>读取请求 readRequest</li>
<li>处理请求 handleRequest</li>
<li>回复请求 sendRequest</li>
</ul>
<p>之前提到过，再一次连接中，允许收到多个请求，即多个 request header 和
request body，因此这里使用了 for 无限制地等待请求的到来，直到发生错误
(例如连接被关闭，接收到的报文有问题等)，这里需要注意的点有三个：</p>
<ul>
<li>handleRequest 使用了协程并发执行请求。</li>
<li>处理请求是并发的，但是回复请求的报文必须是逐个发送的，并发容易导致多个回复报文交织在一起，客户端无法解析。在这里使用锁
(sending) 保证。</li>
<li>尽力而为，只有在 header 解析失败时，才终止循环。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; request stores all infomation of a call
type request struct &#123;
    h            *codec.Header &#x2F;&#x2F; header of request
    argv, replyv reflect.Value &#x2F;&#x2F; argv and replyv of request
    &#x2F;&#x2F; Value also is a struct
&#125;

func (server *Server) readRequestHeader(cc codec.Codec) (*codec.Header, error) &#123;
    var h codec.Header
    if err :&#x3D; cc.ReadHeader(&amp;h); err !&#x3D; nil &#123;
        if err !&#x3D; io.EOF &amp;&amp; err !&#x3D; io.ErrUnexpectedEOF &#123;
            log.Println(&quot;rpc server: read header error:&quot;, err)
        &#125;
        return nil, err
    &#125;
    return &amp;h, nil
&#125;

func (server *Server) readRequest(cc codec.Codec) (*request, error) &#123;
    h, err :&#x3D; server.readRequestHeader(cc)
    if err !&#x3D; nil &#123;
        return nil, err
    &#125;
    req :&#x3D; &amp;reqeust&#123;h: h&#125;
    &#x2F;&#x2F; TODO: now we don&#39;t know the type of request argv
    &#x2F;&#x2F; day1, just suppose it&#39;s string
    req.argv &#x3D; reflect.New(reflect.TypeOf(&quot;&quot;))
    if err &#x3D; cc.ReadBody(req.argv.Interface()); err !&#x3D; nil &#123;
        log.Println(&quot;rpc server: read argv err:&quot;, err)
    &#125;
    return req, nil
&#125;

func (server *Server) sendResponse(cc codec.Cdoec, h *codec.Header, body interface&#123;&#125;, sneding *sync.Mutex) &#123;
    sending.Lock()
    defer sending.Unlock()
    if err :&#x3D; cc.Write(h, body); err !&#x3D; nil &#123;
        log.Println(&quot;rpc server: write response error:&quot;, err)
    &#125;
&#125;

func (server *Server) handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;
    &#x2F;&#x2F; TODO, should call registered rpc methods to get the right replyv
    &#x2F;&#x2F; day1, just print argv and send a hello message
    defer wg.Done()
    log.Println(req.h, req.argv.Elem())
    req.replyv &#x3D; reflect.ValueOf(fmt.Sprintf(&quot;geerpc resp %d&quot;, req.h.Seq))
    server.sendResponse(cc, req.h, req.replyv.Interface(), sending)
&#125;</code></pre>
<p>目前还不能判断 body 的类型，因此在 readRequest 和 handleRequest
中，day1 将在 body作为字符串处理。接收到请求，打印
header，并回复<code>geerpc resp $&#123;req.h.Seq&#125;</code>。这一部分后续再实现。</p>
<h4 id="main-函数-一个简易的客户端">main 函数 (一个简易的客户端)</h4>
<p>day1
的内容就到此为止了，在这里我们已经实现了一个消息的编解码器<code>GobCodec</code>，并且客户端与服务端实现了简单的协议交换
(protocol
exchange)，即允许客户端使用不同的编码方式。实现了服务端的雏形，建立连接，读取、处理并回复客户端的请求。</p>
<p>接下来，我们在 main 函数中看看如何使用刚实现的 GeeRPC。</p>
<p><strong>day1/main/main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
    &quot;encoding&#x2F;json&quot;
    &quot;geerpc&quot;
    &quot;geerpc&#x2F;codec&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;time&quot;
)

func startServer(addr chan string) &#123;
    &#x2F;&#x2F; pick a free port
    l, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)
    if err !&#x3D; nil &#123;
        log.Fatal(&quot;network error: &quot;, err)
    &#125;
    log.Println(&quot;start rpc server on&quot;, l.Addr())
    addr &lt;- l.Addr().String()
    geerpc.Accept(l) &#x2F;&#x2F; 注意这里是不是数字1，是字母l
&#125;

func main() &#123;
    addr :&#x3D; make(chan string)
    go startServer(addr)
    
    &#x2F;&#x2F; in fact, following code is like a simple geerpc client
    conn, _ :&#x3D; net.Dial(&quot;tcp&quot;, &lt;- addr)
    defer func() &#123;
        _ &#x3D; conn.Close()
    &#125;()
    
    time.Sleep(time.Second)
    &#x2F;&#x2F; send options
    _ &#x3D; json.NewEncoder(conn).Encode(geerpc.DefaultOption)
    cc :&#x3D; codec.NewGobCodec(conn)
    &#x2F;&#x2F; send request &amp; receive response
    for i :&#x3D; 0; i &lt; 5; i++ &#123;
        h :&#x3D; $codec.Header &#123;
            ServiceMethod: &quot;Foo.Sum&quot;,
            Seq:           uint64(i),
        &#125;
        _ &#x3D; cc.Write(h, fmt.Sprintf(&quot;geerpc req %d&quot;, h.Seq))
        _ &#x3D; cc.ReadHeader(h)
        var reply string
        _ &#x3D; cc.ReadBody(&amp;reply)
        log.Println(&quot;reply:&quot;, reply)
    &#125;
&#125;</code></pre>
<ul>
<li>在<code>startServer</code>中使用了信道<code>addr</code>，确保服务端端口监听成功，客户端再发起请求。</li>
<li>客户端首先发送<code>Option</code>进行协议交换，接下来发送消息头<code>h := &amp;codec.Header&#123;&#125;</code>，和消息体<code>geerpc req $&#123;h.Seq&#125;</code>。</li>
<li>最后解析服务端的相应<code>reply</code>，并打印出来。</li>
</ul>
<p>执行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">start rpc server on [::]63662
&amp;&#123;Foo.Sum 0 &#125; geerpc req 0
reply: geerpc resp 0
&amp;&#123;Foo.Sum 1 &#125; geerpc req 1
reply: geerpc resp 1
&amp;&#123;Foo.Sum 2 &#125; geerpc req 2
reply: geerpc resp 2
&amp;&#123;Foo.Sum 3 &#125; geerpc req 3
reply: geerpc resp 3
&amp;&#123;Foo.Sum 4 &#125; geerpc req 4
reply: geerpc resp 4</code></pre>
<h3 id="day2.-支持并发和异步的客户端">day2. 支持并发和异步的客户端</h3>
<h4 id="call-的设计">Call 的设计</h4>
<p>对<code>net/rpc</code>而言，一个函数需要能够被远程调用，需要满足如下五个条件：</p>
<ul>
<li>the method's type is exported</li>
<li>the method is exported</li>
<li>the method has two arguments, both exported (or builtin) types</li>
<li>the method's second arguments is a pointer</li>
<li>the method has return type error</li>
</ul>
<p>更直观一点：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (t *T) MethodName(argType T1, replyType *T2) error</code></pre>
<p>根据上述需求，首先我们封装了结构体 Call 来承载一次 RPC
调用所需要的信息。</p>
<p><strong>day2/client.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Call represents an active RPC 
type Call struct &#123;
    Seq           uint64
    ServiceMethod string      &#x2F;&#x2F; format &quot;&lt;service&gt;.&lt;method&gt;&quot;
    Args          interface&#123;&#125; &#x2F;&#x2F; arguments to the function
    Reply         interface&#123;&#125; &#x2F;&#x2F; reply from the fucntion
    Error         error       &#x2F;&#x2F; if error occurs, it will be set
    Done          chan *Call  &#x2F;&#x2F; Strobes when call is complete
&#125; 

func (call *Call) done() &#123;
    call.Done &lt;- call
&#125;</code></pre>
<p>为了支持异步调用，Call 结构体中添加了一个字段 Done，Done
的类型是<code>chan *Call</code>，当调用结束时，会调用<code>call.done()</code>通知调用方。</p>
<h4 id="实现-client">实现 Client</h4>
<p>接下来，我们将实现 GeeRPC 客户端最核心的部分 Client。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Client represents an RPC Client
&#x2F;&#x2F; There may be multipie outstanding Calls associated
&#x2F;&#x2F; with a single Client, and a Client may be used by
&#x2F;&#x2F; multipie goroutines simultaneously
type Client struct &#123;
    cc       codec.Codec
    opt      *Option
    sending  sync.Mutex &#x2F;&#x2F; protect following
    header   codec.Header
    mu       sync.Mutex &#x2F;&#x2F; protect following
    seq      uint64
    pending  map[uint64]*Call
    closing  bool &#x2F;&#x2F; user has called Close
    shutdown bool &#x2F;&#x2F; server has told us to stop
&#125;

var _ io.Closer &#x3D; (*Client)(nil)

var ErrShutdown &#x3D; errors.New(&quot;connection is shut down&quot;)

&#x2F;&#x2F; Close the connection 
func (client *Client) Close() error &#123;
    client.mu.Lock()
    defer client.mu.Unlock()
    if client.closing &#123;
        return ErrShutdown
    &#125;
    client.closing &#x3D; true
    return client.cc.Close()
&#125;

&#x2F;&#x2F; IsAvaliable return true if the client does work
func (client *Client) IsAvaliable() bool &#123;
    client.mu.Lock()
    defer client.mu.Unlock()
    return !client.shutdown &amp;&amp; !client.closing
&#125;</code></pre>
<p>client 的字段解析如下：</p>
<ul>
<li>cc
是消息的编解码器，和服务端类似，用来序列化将要发送出去的请求，以及反序列化接收到的响应。</li>
<li>sending
是一个互斥锁，和服务端类似，为了保证请求的有序发送，即防止出现多个请求报文混淆。</li>
<li>header 是每个请求的消息头，header
只有在请求发送时才需要，而请求发送是互斥的，因此每个客户端只需要一个，声明在
Client 结构体中可以复用。</li>
<li>seq 用于给发送的请求编号，每个请求有唯一编号。</li>
<li>pending 存储未处理完的请求，键是编号，值是 Call 实例。</li>
<li>closing 和 shutdown 任意一个值置为 true，则表示 Client
处于不可用的状态，但有些许的差别，closing
是用户主动关闭的，即调用<code>Close</code>方法，而 shutdown 置为 true
一般是有错误发生。</li>
</ul>
<p>紧接着，实现和 Call 相关的方法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (client *Client) registerCall(call *Call) (uint64, error) &#123;
    client.mu.Lock()
    defer client.mu.Unlock()
    if client.closing || client.shutdown &#123;
        return 0, ErrShutdown
    &#125;
    call.Seq &#x3D; client.seq
    client.pending[call.Seq] &#x3D; call
    client.seq++
    return call.Seq, nil
&#125;

func (client *Client) removeCall(seq uint64) *Call &#123;
    client.mu.Lock()
    defer client.mu.Unlock()
    call :&#x3D; client.pending[seq]
    delete(client.pending, seq)
    return all
&#125;

func (client *Client) terminateCalls(err error) &#123;
    client.sending.Lock()
    defer client.sending.Unlock()
    client.mu.Lock()
    defer client.mu.Unlock()
    client.shutdown &#x3D; true
    for _, call :&#x3D; range client.pending &#123;
        call.Error &#x3D; err
        call.done()
    &#125;
&#125;</code></pre>
<ul>
<li>registerCall ：将参数 call 添加到 client.pending 中，并更新
client.seq。</li>
<li>removeCall：根据seq，从 client.pending 中移除对应的
call，并返回。</li>
<li>terminateCalls：服务端或客户端发生错误时调用，将 shutdown 设置为
true，且将错误信息通知所有 pending 状态的 call。</li>
</ul>
<p>对一个客户端来说，接收响应、发送请求是最重要的2个功能。那么首先实现接收功能，接收到的响应有三种情况：</p>
<ul>
<li>call
不存在，可能是请求没有发送完整，或者因为其他原因被取消，但是服务端仍旧处理了。</li>
<li>call 存在，但服务端处理出错，即 <code>h.Error</code>不为空。</li>
<li>call 存在，服务端处理正常，那么需要从 body 中读取 Reply 的值。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (client *Client) receive() &#123;
    var err error
    for err &#x3D;&#x3D; nil &#123;
        var h codec.Header
        if err &#x3D; client.cc.ReadHeader(&amp;h); err !&#x3D; nil &#123;
            break
        &#125;
        call :&#x3D; client.removeCall(h.Seq)
        switch &#123;
        case call &#x3D;&#x3D; nil:
            &#x2F;&#x2F; it usually means that Write partially failed
            &#x2F;&#x2F; and call was already removed
            arr :&#x3D; client.cc.ReadBody(nil)
        case h.Error !&#x3D; &quot;&quot;:
            call.Error &#x3D; fmt.Errorf(h.Error)
            err &#x3D; client.cc.ReadBody(nil)
            call.done()
        default:
            err &#x3D; client.cc.ReadBody(call.Reply)
            if err !&#x3D; nil &#123;
                call.Error &#x3D; errors.New(&quot;reading body &quot; + err.Error())
            &#125;
            call.done()
        &#125;
    &#125;
    &#x2F;&#x2F; error occurs, so terminateCalls pending calls
    client.terminateCalls(err)
&#125;</code></pre>
<p>创建 Client
实例时，首先需要完成一开始的协议交换，即发送<code>Option</code>信息给服务端。协商好消息的编解码方式之后，再创建一个子协程<code>receive()</code>接收响应。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func NewClient(conn net.conn, opt *Option) (*Client, error) &#123;
    f :&#x3D; codec.NewCodecFuncMap[opt.CodecType]
    if f &#x3D;&#x3D; nil &#123;
        err :&#x3D; fmt.Errorf(&quot;invalid codec type %s&quot;, opt.CodecType)
        log.Println(&quot;rpc client: options error: &quot;, err)
        return nil, err
    &#125;
    &#x2F;&#x2F; send options with server
    if err :&#x3D; json.NewEncoder(conn).Encode(opt); err !&#x3D; nil &#123;
        log.Println(&quot;rpc client: options error: &quot;, err)
        _ &#x3D; conn.Close()
        return nil, err
    &#125;
    return newClientCodec(f(conn), opt), nil
&#125;

func newClientCodec(cc codec.Codec, opt *Option) *Client &#123;
    client :&#x3D; &amp;Client &#123;
        seq:     1, &#x2F;&#x2F; seq starts with 1, 0 means invalid call
        cc:      cc,
        opt:     opt,
        pending: make(map[uint64]*Call)
    &#125;
    go client.receive()
    return client
&#125;</code></pre>
<p>还需要实现<code>Dial</code>函数，便于用户传入服务端地址，创建 Client
实例。为了简化用户调用，通过<code>...*Option</code>将 Option
实现为可选参数。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func parseOptions(opts ...*Option) (*Option, error) &#123;
    &#x2F;&#x2F; if opts is nil or pass nil as parameter
    if len(opts) &#x3D;&#x3D; 0 || opts[0] &#x3D;&#x3D; nil &#123;
        return DefaultOption, nil
    &#125;
    if len(opts) !&#x3D; 1 &#123;
        return nil, errors.New(&quot;number of options is more than 1&quot;)
    &#125;
    opt :&#x3D; opts[0]
    opt.MagicNumber &#x3D; DefaultOption.MagicNumber
    if opt.CodecType &#x3D;&#x3D; &quot;&quot; &#123;
        opt.CodecType &#x3D; DefaultOption.CodecType
    &#125;
    return opt, nil
&#125;

&#x2F;&#x2F; Dial connects to an RPC server at the specified network address
func Dial(network, address string, opts ...*Option) (client *Client, err error) &#123;
    opt, err :&#x3D; parseOptions(opts...)
    if err !&#x3D; nil &#123;
        return nil, err
    &#125;
    conn, err :&#x3D; net.Dial(network, address)
    if err !&#x3D; nil &#123;
        return nil, err
    &#125;
    &#x2F;&#x2F; close the connection if client is nil
    defer func() &#123;
        if client &#x3D;&#x3D; nil &#123;
            _ &#x3D; conn.Close()
        &#125;
    &#125;()
    return NewClient(conn, opt)
&#125;</code></pre>
<p>此时，GeeRPC
客户端已经具备了完整的创建连接和接受响应的能力了，最后还需要实现发送请求的能力。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (client *Client) send(call *Call) &#123;
    &#x2F;&#x2F; make sure that the client will send a complete request
    client.sending.Lock()
    defer client.sending.Unlock()
    
    &#x2F;&#x2F; register this call
    seq, err :&#x3D; client.registerCall(call)
    if err !&#x3D; nil &#123;
        call.Error() &#x3D; err
        call.done()
        return
    &#125;
    
    &#x2F;&#x2F; prepare request header
    client.header.ServiceMethod &#x3D; call.ServiceMethod
    client.header.Seq &#x3D; seq
    client.header.Error &#x3D; &quot;&quot;
    
    &#x2F;&#x2F; encode and send the request
    if err :&#x3D; client.cc.Write(&amp;client.header, call.Args); err !&#x3D; nil &#123;
        call :&#x3D; client.removeCall(seq)
        &#x2F;&#x2F; call may be nil, it usually means that Write partially failed,
        &#x2F;&#x2F; client has receive the response and handled
        if call !&#x3D; nil &#123;
            call.Error &#x3D; err
            call.done()
        &#125;
    &#125;
&#125;

&#x2F;&#x2F; Go invokes the function asynchronously
&#x2F;&#x2F; It returns the Call structure representing the invocation
func (client *Client) Go(serviceMethod string, args, reply interface&#123;&#125;, done chan *Call) *Call &#123;
    if done &#x3D;&#x3D; nil &#123;
        done &#x3D; make(chan *Call, 10)
    &#125; else if cap(done) &#x3D;&#x3D; 0 &#123;
        log.Panic(&quot;rpc client: done channel is unbuffered&quot;)
    &#125;
    call :&#x3D; &amp;Call &#123;
        ServiceMethod: serviceMethod,
        Args:          args,
        Reply:         reply,
        Done:          done,
    &#125;
    client.send(call)
    return call
&#125;

&#x2F;&#x2F; Call invokes the named function, waits for it to complete,
&#x2F;&#x2F; and returns its error status
func (client *Client) Call(serviceMethod string, args, reply interface&#123;&#125;) error &#123;
    call :&#x3D; &lt;- client.Go(serviceMethod, args, reply, make(chan *Call, 1)).Done
    return call.Error
&#125;</code></pre>
<ul>
<li><code>Go</code>和<code>Call</code>是客户端暴露给用户的两个 RPC
服务调用接口，<code>Go</code>是一个异步接口，返回 call 实例。</li>
<li><code>Call</code>是对<code>Go</code>的封装，阻塞
call.Done，等待响应返回，是一个同步接口。</li>
</ul>
<p>至此，一个支持异步和并发的 GeeRPC 客户端已经完成。</p>
<p><strong>补充</strong></p>
<p>defer的运行机制为，在return之后，在函数退出之前执行。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func test() (ans int) &#123;
    defer func() &#123;
        fmt.Println(ans)
    &#125;()
    return 10
&#125;

func main() &#123;
    test()
&#125;</code></pre>
<p>运行结果为：10。</p>
<h4 id="demo">Demo</h4>
<p>第一天 GeeRPC 只实现了服务端，因此我们在 main
函数中手动模拟了整个通信过程，第二天中我们将 main
函数中的通信部分替换为客户端。</p>
<p><strong>day2/main/main.go</strong></p>
<p>startServer 没有发生变化。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func startServer(addr chan string) &#123;
    &#x2F;&#x2F; pick a free port
    l, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)
    if err !&#x3D; nil &#123;
        log.Fatal(&quot;network error: &quot;, err)
    &#125;
    log.Println(&quot;start rpc server on&quot;, l.Addr())
    addr &lt;- l.Addr().String()
    geerpc.Accept(l)
&#125;</code></pre>
<p>在 main 函数中使用了<code>client.Call</code>并发了5个 RPC
同步调用，参数和返回值类型均为 string。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
    log.SetFalgs(0)
    addr :&#x3D; make(chan string)
    go startServer(addr)
    client, _ &#x3D; geerpc.Dial(&quot;tcp&quot;, &lt;-addr)
    defer func() &#123;
        _ &#x3D; client.Close()
    &#125;()
    
    time.Sleep(time.Second)
    &#x2F;&#x2F; send request &amp; receive response
    var wg sync.WaitGroup
    for i :&#x3D; 0; i &lt; 5; i++ &#123;
        wg.Add(1) &#x2F;&#x2F; 每一个任务开始时，将等待组增加1
        &#x2F;&#x2F; 开启一个并发
        go func(i int) &#123;
            defer wg.Done()
            args :&#x3D; fmt.Sprintf(&quot;geerpc req %d&quot;, i)
            var reply string
            if err :&#x3D; client.Call(&quot;Foo.Sum&quot;, args, &amp;reply); err !&#x3D; nil &#123;
                log.Fatal(&quot;call Foo.Sum error: &quot;, err)
            &#125;
            log.Println(&quot;reply&quot;, reply)
        &#125;(i)
    &#125;
    wg.Wait() &#x2F;&#x2F; 等待所有任务完成
&#125;</code></pre>
<p>运行结果如下 (不唯一)：</p>
<pre class="line-numbers language-none"><code class="language-none">start rpc server on [::]:36013
&amp;&#123;Foo.Sum 5&#125; geerpc req 3
&amp;&#123;Foo.Sum 1&#125; geerpc req 4
&amp;&#123;Foo.Sum 2&#125; geerpc req 1
&amp;&#123;Foo.Sum 3&#125; geerpc req 0
&amp;&#123;Foo.Sum 4&#125; geerpc req 2
reply: geerpc resp 4
reply: geerpc resp 5
reply: geerpc resp 1
reply: geerpc resp 2
reply: geerpc resp 3</code></pre>
<p>当然也有这种情况</p>
<pre class="line-numbers language-none"><code class="language-none">&amp;&#123;Foo.Sum 1 &#125; geerpc req 4
&amp;&#123;Foo.Sum 3 &#125; geerpc req 0
&amp;&#123;Foo.Sum 2 &#125; geerpc req 1
reply: geerpc resp 3
reply: geerpc resp 1
reply: geerpc resp 2
&amp;&#123;Foo.Sum 5 &#125; geerpc req 3
&amp;&#123;Foo.Sum 4 &#125; geerpc req 2
reply: geerpc resp 5
reply: geerpc resp 4</code></pre>
<p>对于以上执行结果，加以个人的理解，添加了若干个协程，并同步调用，其中会出现延迟开启并发的现象。</p>
<h3 id="day3.-服务注册">day3. 服务注册</h3>
<ul>
<li>通过反射实现服务注册功能。</li>
</ul>
<h4 id="结构体映射为服务">结构体映射为服务</h4>
<p>RPC
框架的一个基本能力是：像调用本地程序一样调用远程服务。关于如何将程序映射为服务，对于
Go 来说，这个问题就变成了如何将结构体的方法映射为服务。</p>
<p>对<code>net/rpc</code>而言，一个函数需要能够被远程调用，需要满足以下五个条件：</p>
<ul>
<li>the method's type is exported. - 方法所属的类型是导出的。</li>
<li>the method is exported. - 方式是导出的。</li>
<li>the method has two arguments, both expoerted (or builtin) types. -
两个入参，均为导出 or 内置类型。</li>
<li>the method's second argument is a pointer. -
第二个入参必须是一个指针。</li>
<li>the method has return type error. - 返回值为 error 类型。</li>
</ul>
<p>更直观一些：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (t *T)  MethodName(argType T1, replyType *T2) error</code></pre>
<p>假如客户端发来一个请求，包含 ServiceMethod 和 Argv。</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
    &quot;ServiceMethod&quot;: &quot;T.MethodName&quot;
 	&quot;Argv&quot;: &quot;001010010100...&quot; &#x2F;&#x2F; 序列化之后的字节流
&#125;</code></pre>
<p>通过 <code>T.MethodName</code>可以确定调用的是类型 T
的<code>MethodName</code>，如果硬编码实现这个功能，很可能是这样：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">switch req.ServiceMethod &#123;
    case &quot;T.MethodName&quot;:
        t :&#x3D; new(t)
        reply :&#x3D; new(T2)
        var argv T1
        gob.NewDecoder(conn).Decode(&amp;argv)
        err :&#x3D; t.MethodName(argv, reply)
        server.sendMessage(reply, err)
    case &quot;Foo.Sum&quot;:
        f :&#x3D; new(Foo)
    	...
&#125;</code></pre>
<p>也就是说，如果使用硬编码的方式来实现结构体与服务的映射，那么每暴露一个方法，就需要编写等量的代码。那么有没有什么方法，能够将这个映射过程自动化呢？可以借助反射。</p>
<p>通过反射，我们能够很容易获取某个结构体的所有方法，并且能通过所有方法，获取到该方法的所有参数类型与返回值。例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
    var wg sync.WaitGroup
    typ :&#x3D; reflect.TypeOf(&amp;wg)
    for i :&#x3D; 0; i &lt; typ.NumMethod(); i++ &#123;
        method :&#x3D; typ.Method(i)
        argv :&#x3D; make([]string, 0, method.Type.NumIn())
        returns :&#x3D; make([]string, 0, method.Type.NumOut())
        &#x2F;&#x2F; j从1开始，第0个入参是wg自己
        for j :&#x3D; 1; j &lt; method.Type.In(j); j++ &#123;
            argv &#x3D; append(argv, method.Type.In(j).Name())
        &#125;
        for j :&#x3D; 0; j &lt; method.Type.NumOut(); j++ &#123;
            returns &#x3D; append(returns, method.Type.Out(j).Name())
        &#125;
        log.Printf(&quot;func (w *%s) %s(%s) %s&quot;,
           typ.Elem().Name(),
           method.Name,
           strings.Join(argv, &quot;,&quot;),
           strings.Join(returns, &quot;,&quot;))
    &#125;
&#125;</code></pre>
<p>运行结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">func (w *WaitGroup) Add(int)
func (w *WaitGroup) Done()
func (w *WaitGroup) Wait()</code></pre>
<h4 id="通过反射实现-service">通过反射实现 service</h4>
<p>前两天我们完成了客户端和服务端，客户端相对来说功能是比较完整的，但是服务端的功能并不完整，仅仅将请求的
header
打印了出来，并没有真正地处理。那今天的主要目的是补全这部分功能。首先通过反射实现结构体与服务的映射关系，代码独立放置在<code>service.go</code>中。</p>
<p><strong>day3/service.go</strong></p>
<p>第一步，定义结构体 methodType：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type methodType struct &#123;
    method    reflect.Method
    ArgType   reflect.Type
    ReplyType reflect.Type
    numCalls  uint64
&#125;

func (m *methodType) NumCalls() uint64 &#123;
    return atomic.LoadUint64(&amp;m.numCalls)
&#125;

func (m *methodType) newArgv() reflect.Value &#123;
    var argv reflect.Value
    &#x2F;&#x2F; arg may be a pointer type, or a value type
    if m.ArgType.Kind() &#x3D;&#x3D; reflect.Ptr &#123;
        argv &#x3D; reflect.New(m.ArgType.Elem())
    &#125; else &#123;
        argv &#x3D; reflect.New(m.ArgType).Elem()
    &#125;
    return argv
&#125;

func (m *methodType) newReplyv() reflect.Value &#123;
    &#x2F;&#x2F; reply must be a pointer type
    replyv :&#x3D; reflect.New(m.ReplyType.Elem())
    switch m.ReplyType.Elem().Kind() &#123;
    case reflect.Map:
        replyv.Elem().Set(reflect.MakeMap(m.ReplyType.Elem()))
    case refelct.Slice:
        replyv.Elem().Set(reflect.MakeSlice(m.ReplyType.Elem(), 0, 0))
    &#125;
    return replyv
&#125;</code></pre>
<p>每一个 methodType 实例包含了一个方法的完整信息。包括：</p>
<ul>
<li>method：方法本身</li>
<li>ArgType：第一个参数的类型</li>
<li>ReplyType：第二个参数的类型</li>
<li>numCalls：后续统计方法调用次数时会用到</li>
</ul>
<p>另外，我们还实现了2个方法<code>newArgv</code>和<code>newReplyv</code>，用于创建对应类型的实例。<code>newArgv</code>方法有一个小细节，指针类型和值类型创建实例的方法有细微区别。</p>
<p>第二部，定义结构体 service：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type service struct &#123;
    name   string
    typ    reflect.Type
    rcvr   reflect.Value
    method map[string]*methodType
&#125;</code></pre>
<p>service 的定义也是非常简洁的，name
即映射的结构体的名称，比如<code>T</code>，比如<code>WaitGroup</code>；typ是结构体的类型；rcvr
即结构体的实例本身，保留 rcvr 是因为在调用时需要 rcvr
作为第0个参数；method 是 map
类型，储存映射的结构体的所有符合条件的方法。</p>
<p>接下来，完成构造函数<code>newService</code>，入参是任意需要映射为服务的结构体实例。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func newService(rcvr interface&#123;&#125;) *service &#123;
    s :&#x3D; new(service)
    s.rcvr &#x3D; reflect.ValueOf(rcvr)
    s.name &#x3D; reflect.Indirect(s.rcvr).Type().Name()
    s.typ &#x3D; reflect.TypeOf(rcvr)
    if !ast.IsExported(s.name) &#123;
        log.Fatalf(&quot;rpc server: %s is not a valid service name&quot;, s.name)
    &#125;
    s.registerMethods()
    return s
&#125;

func (s *service) registerMethods() &#123;
    s.method &#x3D; make(map[string]*methodType)
    for i :&#x3D; 0; i &lt; s.typ.NumMethod(); i++ &#123;
        method :&#x3D; s.typ.Method(i)
        mType :&#x3D; method.Type
        if mType.NumIn() !&#x3D; 3 || mType.NumOut() !&#x3D; 1 &#123;
            continue
        &#125;
        if mType.Out(0) !&#x3D; reflect.TypeOf((*error)(nil)).Elem() &#123;
            continue
        &#125;
        argType, replyType :&#x3D; mType.In(1), mType.In(2)
        if !isExportedOrBuiltinType(argType) || !isExportedOrBuiltinType(replyType) &#123;
            continue
        &#125;
        s.method[method.Name] &#x3D; &amp;methodType &#123;
            method:    method,
            ArgType:   argType,
            ReplyType: replyType,
        &#125;
        log.Printf(&quot;rpc server: register %s.%s\n&quot;, s.name, method.Name)
    &#125;
&#125;

func isExportOrBuiltinType(t reflect.Type) bool &#123;
    return ast.IsExported(t.Name()) || t.PkgPath() &#x3D;&#x3D; &quot;&quot;
&#125;</code></pre>
<p><code>registerMethods</code>过滤出了符合条件的方法：</p>
<ul>
<li>两个导出或内置类型的入参 (反射时为3个，第0个是自身，类似于 python 的
self，Java 中的this )</li>
<li>返回值有且只有一个，类型为 error</li>
</ul>
<p>最后，我们还需要实现<code>call</code>方法，即能够通过反射值调用方法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (s *service) call(m *methodType, argv, replyv reflect.Value) error &#123;
    atomic.AddUint64(&amp;m.numCalls, 1)
    f :&#x3D; m.method.Func
    returnValues :&#x3D; f.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)
    if errInter :&#x3D; returnValues[0].Interface(); errInter !&#x3D; nil &#123;
        return errInter.(error)
    &#125;
    return nil
&#125;</code></pre>
<h4 id="service-的测试用例">service 的测试用例</h4>
<p>为了保证 service 实现的正确性，我们为 service.go
写了几个测试用例。</p>
<p><strong>day3/service_test.go</strong></p>
<p>定义结构体 Foo，实现2个方法，导出方法 Sum 和非导出方法 sum。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Foo int

type Args struct &#123; Num1, Num2 int&#125;

func (f Foo) Sum(args Args, reply *int) error &#123;
    *reply &#x3D; args.Num1 + args.Num2
    return nil
&#125;

&#x2F;&#x2F; it&#39;s not a exported Method
func (f Foo) sum(args Args, reply *int) error &#123;
    *reply &#x3D; args.Num1 + args.Num2
    return nil
&#125;
&#x2F;&#x2F; 这里要注意，是两个不一样的函数，后面的测试中要注意写的函数名，会影响测试结果

func _assert(condition bool, msg string, v ...interface&#123;&#125;) &#123;
    if !condition &#123;
        panic(fmt.Sprintf(&quot;assertion failed: &quot; + msg, v...))
    &#125;
&#125;</code></pre>
<p>测试 newService 和 call 方法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func TestNewService(t *testing.T) &#123;
    var foo Foo
    s :&#x3D; newService(&amp;foo)
    _assert(len(s.method) &#x3D;&#x3D; 1, &quot;wrong service Method, expect 1, but got %d&quot;, len(s.method))
    mType :&#x3D; s.method[&quot;Sum&quot;]
    _assert(mType !&#x3D; nil, &quot;wrong Method, Sum should&#39;t nil&quot;)
&#125;

func TestMethodType_Call(t *testing.T) &#123;
    var foo Foo
    s :&#x3D; newService(&amp;foo)
    mType :&#x3D; s.method(&quot;Sum&quot;)
    
    argv :&#x3D; mType.newArgv()
    replyv :&#x3D; mType.newReplyv()
    argv.Set(reflect.ValueOf(Args&#123;Num1: 1, Num2: 3&#125;))
    err :&#x3D; s.call(mType, argv, replyv)
    _assert(err &#x3D;&#x3D; nil &amp;&amp; *replyv.Interface().(*int) &#x3D;&#x3D; 4 &amp;&amp; mType.NumCalls() &#x3D;&#x3D; 1, &quot;failed to call Foo.Sum&quot;)
&#125;</code></pre>
<p>这里的测试，卡了我大约2天了，开始一直没搞明白为什么注册的方法一直是
"Sum"，而不是
"sum"，然而，我一直在<code>service.go</code>里找，各种print打印相关信息，也还是找不出个所以然，其实我犯了个很低级的错误，<code>service.go</code>这一类是高度抽象的，一般不会有很具体的内容，问题只能出在<code>service_test.go</code>中，在无头绪找bug的第三天，我尝试改<code>Sum</code>函数，发现输出的内容变了，后面注意到导出和非导出函数，好吧，原来问题出在这，<code>Sum</code>和<code>sum</code>都是
Foo
有的函数，在golang中，小写字段不可从包外访问，所以注册的是大写的<code>Sum</code>。</p>
<h4 id="集成到服务端">集成到服务端</h4>
<p>通过反射结构体已经映射为服务，但请求的处理还没有完成。从接收到请求到回复还差以下几个步骤：</p>
<ul>
<li>根据入参类型，将请求的 body 反序列化。</li>
<li>调用<code>service.call</code>，完成方法调用。</li>
<li>将 reply 序列化为字节流，构造响应报文，返回。</li>
</ul>
<p>回到代码本身，补全之前在<code>server.go</code>中遗留的2个 TODO
任务<code>readRequest</code>和<code>handleRequest</code>即可。</p>
<p>在这之前，我们还需要为 Server 实现一个方法<code>Register</code>。</p>
<p><strong>day3/server.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Server represents an RPC Server
type Server struct &#123;
    service sync.Map
&#125;

&#x2F;&#x2F; Register publishes in the server the set of methods 
func (server *Server) Register(rcvr interface&#123;&#125;) error &#123;
    s :&#x3D; newService(rcvr)
    if _, dup :&#x3D; server.serviceMap.LoadOrStore(s.name, s); dup &#123;
        return errors.New(&quot;rpc: service already defined: &quot;, + s.name)
    &#125;
    return nil
&#125;

&#x2F;&#x2F; Register publishes the receiver&#39;s methods in the DefaultServer
func Register(rcvr interface&#123;&#125;) error &#123;
    return DefaultServer.Register(rcvr)
&#125;</code></pre>
<p>配套实现<code>findService</code>方法，即通过<code>ServiceMethod</code>从
serviceMap 中找到对应的 service。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (server *Server) findService(serviceMethod string) (svc *service, mtype *methodType, err error) &#123;
    dot :&#x3D; strings.LastIndex(serviceMethod, &quot;.&quot;)
    if dot &lt; 0 &#123;
        err :&#x3D; errors.New(&quot;rpc server: service&#x2F;method request ill-formed: &quot; + serviceMethod)
        return
    &#125;
    serviceName, methodName :&#x3D; serviceMethod[:dot], serviceMethod[dot+1:]
    svci, ok :&#x3D; server.serviceMap.Load(serviceName)
    if !ok &#123;
        err :&#x3D; errors.New(&quot;rpc server: can&#39;t find service &quot; + serviceName)
        return
    &#125;
    svc &#x3D; svci.(*service)
    mtype &#x3D; svc.method[methodName]
    if mtype &#x3D;&#x3D; nil &#123;
        err &#x3D; errors.New(&quot;rpc server: can&#39;t find method &quot; + methodName)
    &#125;
    return
&#125;</code></pre>
<p><code>findService</code>的实现看似比较繁琐，但是逻辑还是非常清晰的。因为<code>ServiceMethod</code>的构成是
"Service.Method"，因此先将其分割成2部分，第一部分是 Service
的名称，第二部分即方法名。现在 serviceMap 中找到对应的 service
实例，再从 service 实例的 method 中，找到对应的 methodType。</p>
<p>准备工具已经就绪，我们首先补全 readRequest 方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; request stores all information of a call
type request struct &#123;
    h            *codec.Header &#x2F;&#x2F; header of request
    argv, replyv reflect.Value &#x2F;&#x2F; argv and replyv of request
    mtype        *methodType
    svc          *service
&#125;

func (server *Server) readRequest(cc codec.Codec) (*reqeust, error) &#123;
    h, err :&#x3D; server.readRequest(cc)
    if err !&#x3D; nil &#123;
        return nil, err
    &#125;
    req :&#x3D; &amp;request&#123;h: h&#125;
    req.svc, req.mtype, err &#x3D; server.findService(h.ServiceMethod)
    if err !&#x3D; nil &#123;
        return req, err
    &#125;
    req.argv &#x3D; req.mtype.newArgv()
    req.replyv &#x3D; req.mtype.newReplyv()
    
    &#x2F;&#x2F; make sure that argvi is a pointer, ReadBody need a pointer as parameter
    argvi :&#x3D; req.argv.Interface()
    if req.argv.Type().Kind() !&#x3D; reflect.Ptr &#123;
        argvi &#x3D; req.argv.Addr().Interface()
    &#125;
    if err &#x3D; cc.ReadBody(argvi); err !&#x3D; nil &#123;
        log.Println(&quot;rpc server: read body err: &quot;, err)
        return req, err
    &#125;
    return req, nil
&#125;</code></pre>
<p>readRequest
方法中最重要的部分，即通过<code>newArgv()</code>和<code>newReplyv()</code>两个方法创建出两个入参实例，然后通过<code>cc.ReadBody()</code>将请求报文反序列化为第一个入参
argv，在这里同样要注意 argv
可能是值类型，也可能是指针类型，所以处理方式有点差异。</p>
<p>接下来补全 handleRequest 方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (server *Server) handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;
    defer wg.Done()
    err :&#x3D; req.svc.call(req.mtype, req.argv, req.replyv)
    if err !&#x3D; nil &#123;
        req.h.Error &#x3D; err.Error()
        server.sendResponse(cc, req.h, invalidRequest, sending)
        return
    &#125;
    server.sendResponse(cc, req.h, replyv.Interface(), sending)
&#125;</code></pre>
<p>相对于 readRequest，handleRequest
的实现非常简单，通过<code>req.svc.call</code>完成方法调用，将 replyv
传递给 sendResponse 完成序列化即可。</p>
<p>到这里，今天所有内容已实现完成，成功在服务端实现了服务注册与调用。</p>
<h4 id="demo-1">Demo</h4>
<p>最后，修改下 main 验证成果。</p>
<p><strong>day3/main/main.go</strong></p>
<p>第一步，定义结构体 Foo 和方法 Sum。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
    &quot;geerpc&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

type Foo int

type Args struct&#123; Num1, Num2 int &#125;

func (f Foo) Sum(args Args, reply *int) error &#123;
    *reply &#x3D; args.Num1 + args.Num2
    return nil
&#125;</code></pre>
<p>第二步，注册 Foo 到 Server 中，并启动 RPC 服务。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func startServer(addr chan string) &#123;
    var foo Foo
    if err :&#x3D; geerpc.Register(&amp;foo); err !&#x3D; nil &#123;
        log.Fatal(&quot;register error: &quot;, err)
    &#125;
    &#x2F;&#x2F;pick a free port
    l, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)
    if err !&#x3D; nil &#123;
        log.Fatal(&quot;network error: &quot;, err)
    &#125;
    log.Println(&quot;start rpc server on&quot;, l.Addr())
    addr &lt;- l.Addr().String()
    geerpc.Accept(l)
&#125;</code></pre>
<p>第三步，构造参数，发送 RPC 请求，并打印结果。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
    log.SetFlags(0)
    addr :&#x3D; make(chan string)
    go startServer(addr)
    client, _ :&#x3D; geerpc.Dial(&quot;tcp&quot;, &lt;-addr)
    defer func() &#123;
        _ &#x3D; client.Close()
    &#125;()
    
    time.Sleep(time.Second)
    &#x2F;&#x2F; send request &amp; receive response
    var wg sync.WaitGroup
    for i :&#x3D; 0; i &lt; 5; i++ &#123;
        wg.Add(1)
        go func(i int) &#123;
            defer wg.Done()
            args :&#x3D; &amp;Args&#123;Num1: i, Num2: i * i&#125;
            var reply int
            if err :&#x3D; client.Call(&quot;Foo.Sum&quot;, args, &amp;reply); err !&#x3D; nil &#123;
                log.Fatal(&quot;call Foo.Sum error: &quot;, err)
            &#125;
            log.Printf(&quot;%d + %d &#x3D; %d&quot;, args.Num1, args.Num2, reply)
        &#125;(i)
    &#125;
    wg.Wait()
&#125;</code></pre>
<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">rpc server: register Foo.Sum
start rpc server on [::]:57509
0 + 0 &#x3D; 0
2 + 4 &#x3D; 6
4 + 16 &#x3D; 20
3 + 9 &#x3D; 12
1 + 1 &#x3D; 2</code></pre>
<h3 id="day4.-超时处理">day4. 超时处理</h3>
<h4 id="为什么要超时处理机制">为什么要超时处理机制</h4>
<p>超时处理是 RPC
框架一个比较基本的能力，如果缺少超时处理机制，无论是服务端还是客户端都容易因为网络或其他错误导致挂死，资源耗尽，这些问题的出现大大降低了服务的可用性。因此，我们需要在
RPC 框架中加入超时处理的能力。</p>
<p>纵观整个远程调用的过程，需要客户端处理超时的地方有：</p>
<ul>
<li>与服务端建立连接，导致的超时。</li>
<li>发送请求到服务端，写报文导致的超时。</li>
<li>等待服务端处理时，等待处理导致的潮实
(比如服务端已挂死，迟迟不响应)</li>
<li>从服务端接收响应时，读报文导致的超时。</li>
</ul>
<p>需要服务端处理超时的地方有：</p>
<ul>
<li>读取客户端请求报文时，读报文导致的超时。</li>
<li>发送响应报文时，写报文导致的超时。</li>
<li>调用映射服务的方法时，处理报文导致的超时。</li>
</ul>
<p>GeeRPC 在3个地方添加了超时处理机制。分别是：</p>
<ul>
<li>客户端创建连接时。</li>
<li>客户端<code>Client.Call()</code>整个过程导致的超时
(包含发送报文，等待处理，接收报文所有阶段)。</li>
<li>服务端处理报文，即<code>Server.handleRequest</code>超时。</li>
</ul>
<h4 id="创建连接超时">创建连接超时</h4>
<p>为了实现上的简单，将超时设定放在了 Option
中。<code>ConnectTimeout</code>的默认值为
10s，<code>HandleTimeout</code>默认值为0，即不设限。</p>
<p><strong>day4/server.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Option struct &#123;
    MagicNumber    int &#x2F;&#x2F; MagicNumber marks this&#39;s a geerpc request
    CodecType      codec.Type &#x2F;&#x2F; client may choose different Codec to encode body
    ConnectTimeout time.Duration &#x2F;&#x2F; 0 means no limit
    HandleTimeout  time.Duration
&#125;

var DefaultOption &#x3D; &amp;Option &#123;
    MagicNumber:    MagicNumber,
    CodecType:      codec.GobType,
    ConnectTimeout: time.Second * 10,
&#125;</code></pre>
<p>客户端连接超时，只需要为 Dial 添加一层超时处理的外壳即可。</p>
<p><strong>day4/client.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type clientResult struct &#123;
    client *Client
    err    error
&#125;

type newClientFunc func(conn net.Conn, opt *Option) (client *Client, err error) &#123;
    opt, err :&#x3D; parseOptions(opts...)
    if err !&#x3D; nil &#123;
        return nil, err
    &#125;
    conn, err :&#x3D; net.DialTimeout(network, address, opt.ConnectTimeout)
    if err !&#x3D; nil &#123;
        return nil, err
    &#125;
    &#x2F;&#x2F; close the connection if client is nil
    defer func() &#123;
        if err !&#x3D; nil &#123;
            _ &#x3D; conn.Close()
        &#125;
    &#125;()
    ch :&#x3D; make(chan clientResult)
    go func() &#123;
        client, err :&#x3D; f(conn, opt)
        ch &lt;- clientResult&#123;client: client, err: err&#125;
    &#125;()
    select &#123;
        case &lt;-time.After(opt.ConnectTimeout):
            return nil, fmt.Errorf(&quot;rpc client: connect timeout: expect within %s&quot;, opt.ConnectTimeout)
        case result :&#x3D; &lt;-ch:
            return result.client, result.err
    &#125;
&#125;

&#x2F;&#x2F; Dial connects to an RPC server at the specified network address
func Dial(network, address string, opts ...*Option) (*Client, error) &#123;
    return dialTimeout(NewClient, network, address, opts...)
&#125;</code></pre>
<p>在这里实现了一个超时处理的外壳<code>dialTimeout</code>，这个壳将<code>NewClient</code>作为入参，在2个地方添加了超时处理的机制。</p>
<ol type="1">
<li>将<code>net.Dial</code>替换为<code>net.DialTimeout</code>，如果连接创建超时，将返回错误。</li>
<li>使用子协程执行<code>NewClient</code>，执行完成后则通过信道 ch
发送结果，如果<code>time.After()</code>信道先接收到消息，则说明<code>NewClient</code>执行超时，返回错误。</li>
</ol>
<h4 id="client.call-超时">Client.Call 超时</h4>
<p><code>Client.Call</code>的超时处理机制，使用 context
包实现，控制权交给用户，控制更为灵活。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Call invokes the named function, waits for it to complete,
&#x2F;&#x2F; and returns its error status.
func (client *Client) Call(ctx context.Context, serviceMethod string, args, reply interface&#123;&#125;) error &#123;
    call :&#x3D; client.Go(serviceMethod, args, reply, make(chan *Call, 1))
    select &#123;
    case &lt;-ctx.Done():
        client.removeCall(call.Seq)
        return errors.New(&quot;rpc client: call failed: &quot; + ctx.Err().Error())
    case call :&#x3D; &lt;-call.Done:
        return call.Error
    &#125;
&#125;</code></pre>
<p>用户可以使用<code>context.WithTimeout</code>创建具备超时检测能力的
context 对象来控制，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">ctx, _ :&#x3D; context.WithTimeout(context.Background(), time.Second)
var reply int
err :&#x3D; client.Call(ctx, &quot;Foo.Sum&quot;, &amp;Args&#123;1, 2&#125;, &amp;reply)
...</code></pre>
<h4 id="服务端处理超时">服务端处理超时</h4>
<p>这一部分的实现与客户端很接近，使用<code>time.After()</code>结合<code>select + chan</code>完成。</p>
<p><strong>day4/server.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (server *Server) handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup, timeout time.Duration) &#123;
    defer wg.Done()
    called :&#x3D; make(chan struct&#123;&#125;)
    sent :&#x3D; make(chan struct&#123;&#125;)
    go func() &#123;
        err :&#x3D; req.svc.call(req.mtype, req.argv, req.replyv)
        called &lt;- struct&#123;&#125;&#123;&#125;
        if err !&#x3D; nil &#123;
            req.h.Error &#x3D; err.Error()
            server.sendResponse(cc, req.h, invalidRequest, sending)
            sent &lt;- struct&#123;&#125;&#123;&#125;
            return 
        &#125;
    &#125;()
    
    if timeout &#x3D;&#x3D; 0 &#123;
        &lt;-called
        &lt;-sent
        &#x2F;&#x2F; 从信道获取值，忽略结果(类似于pop())
        return
    &#125;
    select &#123;
    case &lt;-time.After(timeout):
        req.h.Error &#x3D; fmt.Sprintf(&quot;rpc server: request handle timeout: expect within %s&quot;, timeout)
        server.sendResponse(cc, req.h, invalidRequest, sending)
    case &lt;-called:
        &lt;-sent
    &#125;
&#125;</code></pre>
<p>这里需要确保<code>sendResponse</code>仅调用一次，因此将整个过程拆分为<code>called</code>和<code>sent</code>两个阶段，在这段代码中只会发生如下两种情况：</p>
<ul>
<li>called 信道接收到消息，代表处理没有超时，继续执行
<code>sendResponse</code>。</li>
<li><code>time.After()</code>先于 called
接收到消息，说明处理已经超时，called 和 sent
都将被阻塞。在<code>case &lt;-time.After(timeout)</code>处调用<code>sendResponse</code>。</li>
</ul>
<h4 id="测试用例">测试用例</h4>
<p><strong>day4/client_test.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func TestClient_dialTimeout(t *testing.T) &#123;
    t.Parallel()
    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)
    
    f :&#x3D; func(conn net.Conn, opt *Option) (client *Client, err error) &#123;
        _ &#x3D; conn.Close()
        time.Sleep(time.Second * 2)
        return nil, nil
    &#125;
    t.Run(&quot;timeout&quot;, func(t *testing.T) &#123;
        _, err :&#x3D; dialTimeout(f, &quot;tcp&quot;, l.Addr().String(), &amp;Option&#123;ConnectTimeout: time.Second&#125;)
        _assert(err !&#x3D; nil &amp;&amp; strings.Contains(err.Error(), &quot;connect timeout&quot;), &quot;expect a timeout error&quot;)
    &#125;)
    t.Run(&quot;0&quot;, func(t *testing.T) &#123;
        _, err :&#x3D; dialTimeout(f, &quot;tcp&quot;, l.Addr().String(), &amp;Option&#123;ConnectTimeout: 0&#125;)
        _assert(err &#x3D;&#x3D; nil, &quot;0 means no limit&quot;)
    &#125;) 
&#125;</code></pre>
<p>第二个测试用例，用于测试处理超时。<code>Bar.Timeout</code>耗时2s，场景一：客户端设置超时时间为1s，服务端无限制；场景二，服务端设置超时时间为1s，客户端无限制。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Bar int

func (b Bar) Timeout(argv int, reply *int) error &#123;
    time.Sleep(time.Second * 2)
    return nil
&#125;

func startServer(addr chan string) &#123;
    var b Bar
    _ &#x3D; Register(&amp;b)
    &#x2F;&#x2F; pick a free port
    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)
    addr &lt;- l.Addr().String()
    Accept(l)
&#125;

func TestClient_Call(t *testing.T) &#123;
    t.Parallel()
    addrChh :&#x3D; make(chan string)
    go startServer(addrCh)
    addr :&#x3D; &lt;-addrCh
    time.Sleep(time.Second)
    t.Run(&quot;client timeout&quot;, func(t *testing.T) &#123;
        client, _ :&#x3D; Dial(&quot;tcp&quot;, addr)
        ctx, _ :&#x3D; context.WithTimeout(context.Background(), time.Second)
        var reply int
        err :&#x3D; client.Call(ctx, &quot;Bar.Timeout&quot;, 1, &amp;reply)
        _assert(err !&#x3D; nil &amp;&amp; strings.Contains(err.Error(), ctx.Err().Error()), &quot;expect a timeout error&quot;)
    &#125;)
    t.Run(&quot;server handle timeout&quot;, func(t *testing.T) &#123;
        client, _ :&#x3D; Dial(&quot;tcp&quot;, addr, &amp;Option&#123;
            HandleTimeout: time.Second,
        &#125;)
        var reply int
        err :&#x3D; client.Call(context.Background(), &quot;Bar.Timeout&quot;, 1, &amp;reply)
        _assert(err !&#x3D; nil &amp;&amp; strings.Contains(err.Error(), ctx.Err().Error()), &quot;expect a timeout error&quot;)
    &#125;)    
&#125;</code></pre>
<h3 id="day5.-支持http协议">day5. 支持HTTP协议</h3>
<ul>
<li>支持 HTTP 协议</li>
<li>基于 HTTP 实现一个简单的 Debug 页面，代码约 150 行。</li>
</ul>
<h4 id="支持-http-协议需要做什么">支持 HTTP 协议需要做什么？</h4>
<p>Web 开发中，我们经常使用 HTTP 协议中的 HEAD、GET、POST
等方式发送请求，等待响应。但 RPC 的消息格式与标准的 HTTP
协议并不兼容，在这种情况下，就需要一个协议的转换过程。HTTP 协议的
CONNECT 方法恰好提供了这个能力，CONNECT 一般用于代理服务。</p>
<p>假设浏览器与服务器之间的 HTTPS
通信都是加密的，浏览器通过代理服务器发起 HTTPS
请求时，由于请求的站点地址和端口号都是加密保存在 HTTPS
请求报文头中的，代理服务器如何直到往哪里发送请求呢？为了解决这个问题，浏览器通过
HTTP 明文形式向代理服务器发送一个 CONNECT
请求告诉代理服务器目标地址和端口，代理服务器接收到这个请求后，会在对应端口和目标站点建立一个
TCP 连接，连接建立成功后返回 HTTP 200
状态码告诉浏览器与该站点的加密通道已经完成。接下来代理服务器仅需透传浏览器和服务器之间的加密数据包即可，代理服务器无需解析
HTTPS 报文。</p>
<p>举一个简单的例子：</p>
<ol type="1">
<li>浏览器向代理服务器发送 CONNECT 请求。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">CONNECT jaydenchang.top:443 HTTP&#x2F;1.0 </code></pre>
<ol start="2" type="1">
<li>代理服务器返回 HTTP 200 状态码表示连接已经建立。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.0 200 Connection Established</code></pre>
<ol start="3" type="1">
<li>之后浏览器和服务器开始 HTTPS
握手并交换加密数据，代理服务器只负责传输彼此的数据包，并不能读取具体数据内容
(代理服务器也可以选择安装可信根证书解密 HTTPS 报文)。</li>
</ol>
<p>事实上，这个过程其实是通过代理服务器将 HTTP 协议转换为 HTTPS
协议的过程。对 RPC 服务端来说，需要做的事是将 HTTP 协议转换为 RPC
协议，对客户端来说，需要新增通过 HTTP CONNECT 请求创建连接的逻辑。</p>
<h4 id="服务端支持-http-协议">服务端支持 HTTP 协议</h4>
<p>那通信过程应该是这样的：</p>
<ol type="1">
<li>客户端向 RPC 服务器发送 CONNECT 请求</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">CONNECT 10.0.0.1:9999&#x2F;geerpc HTTP&#x2F;1.0 </code></pre>
<ol start="2" type="1">
<li>RPC 服务器返回 HTTP 200 状态码表示连接建立。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.0 200 Connected to Gee RPC</code></pre>
<ol start="3" type="1">
<li>客户端使用创建好的连接发送 RPC 报文，先发送 Option，再发送 N
个请求报文，服务端处理 RPC 请求并响应。</li>
</ol>
<p>在<code>server.go</code>中新增如下的方法：</p>
<p><strong>day5/server.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">const (
    connected        &#x3D; &quot;200 Connected to Gee RPC&quot;
    defaultRPCPath   &#x3D; &quot;&#x2F;geerpc&quot;
    defaultDebugPath &#x3D; &quot;&#x2F;debug&#x2F;geerpc&quot;
)

&#x2F;&#x2F; ServerHTTP implements an http.Handler that answer RPC requests
func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;
    if req.Method !&#x3D; &quot;CONNECT&quot; &#123;
        w.Header().Set(&quot;Content-Type&quot;, &quot;text&#x2F;plain; charset&#x3D;utf-8&quot;)
        w.WriteHeader(http.StatusMethodNotAllowed)
        _, _ &#x3D; io.WriteString(w, &quot;405 must CONNECT\n&quot;)
        return
    &#125;
    conn, _, err :&#x3D; w.(http.Hijacker).Hijack()
    if err !&#x3D; nil &#123;
        log.Print(&quot;rpc hijacking &quot;, req.RemoteAddr, &quot;: &quot;, err.Error())
        return
    &#125;
    _, _ &#x3D; io.WriteString(conn, &quot;HTTP&#x2F;1.0 &quot; + connected + &quot;\n\n&quot;)
    server.ServeConn(conn)
&#125;

&#x2F;&#x2F; HandleHTTP registers an HTTP handler for RPC messages on rpcPath
&#x2F;&#x2F; It is still necessary to invoke http.Serve(), typically in a go statement
func (server *Server) HandleHTTP() &#123;
    http.Handle(defaultRPCPath, server)
&#125;

&#x2F;&#x2F; HandleHTTP is a convenient approach for default server to register HTTP handlers
func HandleHTTP() &#123;
    DefaultServer.HandleHTTP()
&#125;</code></pre>
<p><code>defaultDebugPath</code>是后续 DEBUG 页面预留的地址。</p>
<p>在 GO 中处理 HTTP 请求是非常简单的一件事，Go
标准库中<code>http.Handle</code>的实现如下：</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">package http
&#x2F;&#x2F; Handle registers the handler for the given pattern.
&#x2F;&#x2F; in the DefaultServeMux.
&#x2F;&#x2F; The documentation for ServeMux explains how patterns are matched.
func Handle(pattern string, handler Handler) &#123; DefaultServeMux.Handle(pattern, handler) &#125;</code></pre>
<p>第一个参数是支持统配的字符串
pattern，在这里，我们固定传入<code>/geerpc</code>，第二个参数是 Handler
类型，Handler 是一个接口类型，定义如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Handler interface &#123;
    ServeHTTP(w ResponseWriter, r *Request)
&#125;</code></pre>
<p>也就是说，只需要实现接口 Handler 即可作为一个 HTTP Handler 处理 HTTP
请求。接口 Handler
只定义了一个方法<code>ServeHTTP</code>，实现该方法即可。</p>
<h4 id="客户端支持-http-协议">客户端支持 HTTP 协议</h4>
<p>服务端已经能够接受 CONNECT 请求，并返回了 200
状态码<code>HTTP/1.0 200 Connected to Gee RPC</code>，客户端要做的，发起
CONNECT 请求，检查返回状态码即可成功建立连接。</p>
<p><strong>day5/client.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; NewHTTPClient new a Client instance via HTTP as transport protocol
func NewHTTPClient(conn net.Conn, opt *Option) (*Client, err) &#123;
    _, _ &#x3D; io.WriteString(conn, fmt.Sprintf(&quot;CONNECT %s HTTP&#x2F;1.0\n\n&quot;, defaultRPCPath))
    
    &#x2F;&#x2F; Require successful HTTP reesponse
    &#x2F;&#x2F; before switching to RPC protocol
    resp, err :&#x3D; http.ReadResponse(bufio.NewReader(conn), &amp;http.Request&#123;Method: &quot;CONNECT&quot;&#125;)
    if err &#x3D;&#x3D; nil &amp;&amp; resp.Status &#x3D;&#x3D; connected &#123;
        return NewClient(conn, opt)
    &#125;
    if err &#x3D;&#x3D; nil &#123;
        err &#x3D; errors.New(&quot;unexpected HTTP response: &quot; + resp.Status)
    &#125;
    return nil, err
&#125;

&#x2F;&#x2F; DialHTTP connectd to an HTTP RPC server at the specified network address 
&#x2F;&#x2F; listening on the default HTTP RPC path.
func DialHTTP(network, address string, opts ...*Option) (*Client, error) &#123;
    return dialTimeout(NewHTTPClient, network, address, opts...)
&#125;</code></pre>
<p>通过 HTTP CONNECT 请求建立连接后，后续的通信过程就交给 NewClient
了。</p>
<p>为了简化调用，提供了一个统一入口<code>XDial</code></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; XDial calls different functions to connect to a RPC server
&#x2F;&#x2F; according the first parameter rpcAddr.
&#x2F;&#x2F; rpcAddr is a general format (protocol@addr) to represent a rpc server
&#x2F;&#x2F; eg, http@10.0.0.1:7890, tcp@10.0.0.1:9999, unix@&#x2F;tmp&#x2F;geerpc.sock
func XDial(rpcAddr string, opts ...*Option) (*Client, error) &#123;
    parts :&#x3D; strings.Split(rpcAddr, &quot;@&quot;)
    if len(parts) !&#x3D; 2 &#123;
        return nil, fmt.Errorf(&quot;rpc client err: wrong format &#39;%s&#39;, expect protocol@addr&quot;, rpcAddr)
    &#125;
    protocol, addr :&#x3D; parts[0]. parts[1];
    switch protocol &#123;
    case &quot;http&quot;:
        return DialHTTP(&quot;tcp&quot;, addr, opts...)
    default:
        &#x2F;&#x2F; tcp, unix or other transport protocol
        return Dial(protocol, addr, opts...)
    &#125;
&#125;</code></pre>
<p>添加一个测试用例试一试，这个测试用例使用了 unix 协议创建 socket
连接，适用于本机内部的通信，使用上和 TCP 协议无区别。</p>
<p><strong>day5/client_test.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func TestXDial(t *testing.T) &#123;
    if runtime.GOOS &#x3D;&#x3D; &quot;linux&quot; &#123;
        ch :&#x3D; make(chan struct&#123;&#125;)
        addr :&#x3D; &quot;&#x2F;tmp&#x2F;geerpc.sock&quot;
        go func() &#123;
            _ &#x3D; os.Remove(addr)
            l, err :&#x3D; net.Listen(&quot;unix&quot;, addr)
            if err !&#x3D; nil &#123;
                t.Fatal(&quot;failed to listen unix socket&quot;)
            &#125;
            ch &lt;- struct&#123;&#125;&#123;&#125;
            Accept(l)
        &#125;()
        &lt;-ch
        _, err :&#x3D; XDial(&quot;unix@&quot; + addr)
        _assert(err &#x3D;&#x3D; nil, &quot;failed to connect unix socket&quot;)
    &#125;
&#125;</code></pre>
<h4 id="实现简单的-debug-页面">实现简单的 DEBUG 页面</h4>
<p>支持 HTTP 协议的好处在于，RPC
服务仅仅使用了监听端口的<code>/geerpc</code>路径，在其他路径上我们可以提供诸如日志，统计等更为丰富的功能。接下来我们在<code>/debug/geerpc</code>上展示服务的调用统计视图。</p>
<p><strong>day5/debug.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package geerpc

import (
    &quot;fmt&quot;
    &quot;html&#x2F;template&quot;
    &quot;net&#x2F;http&quot;
)

const debugText &#x3D; &#96;&lt;html&gt;
	&lt;body&gt;
	&lt;title&gt;GeeRPC Services&lt;&#x2F;title&gt;
	&#123;&#123;range .&#125;&#125;
	&lt;hr&gt;
	Service &#123;&#123;.Name&#125;&#125;
	&lt;hr&gt;
		&lt;table&gt;
		&lt;th align&#x3D;center&gt;Method&lt;&#x2F;th&gt;&lt;th align&#x3D;center&gt;Calls&lt;&#x2F;th&gt;
		&#123;&#123;range $name, $mtype :&#x3D; .Method&#125;&#125;
			&lt;tr&gt;
			&lt;td align&#x3D;left font&#x3D;fixed&gt;&#123;&#123;$name&#125;&#125;(&#123;&#123;$mtype.ArgType&#125;&#125;, &#123;&#123;$mtype.ReplyType&#125;&#125;) error&lt;&#x2F;td&gt;
			&lt;td align&#x3D;center&gt;&#123;&#123;$mtype.NumCalls&#125;&#125;&lt;&#x2F;td&gt;
			&lt;&#x2F;tr&gt;
		&#123;&#123;end&#125;&#125;
		&lt;&#x2F;table&gt;
	&#123;&#123;end&#125;&#125;
	&lt;&#x2F;body&gt;
	&lt;&#x2F;html&gt;&#96;

var debug &#x3D; template.Must(template.New(&quot;RPC debug&quot;).Parse(debugText))

type debugHTTP struct &#123;
    *Server
&#125;

type debugService struct &#123;
    Name   string
    Method map[string]*methodType
&#125;

&#x2F;&#x2F; Runs at &#x2F;debug&#x2F;geerpc
func (server debugHTTP) ServerHTTP(w http.ResponseWriter, req *http.Request) &#123;
    &#x2F;&#x2F; build a sorted version of the data
    var services []debugService
    server.serviceMap.Range(func(namei, svci interface&#123;&#125;) bool &#123;
        svc :&#x3D; svci.(*service)
        services &#x3D; append(services, debugService&#123;
            Name:   namei.(string),
            Method: svc.method,
        &#125;)
        return true
    &#125;)
    err :&#x3D; debug.Execute(w, services)
    if err !&#x3D; nil &#123;
        _, _ &#x3D; fmt.Fprintln(w, &quot;rpc: error executing template:&quot;, err.Error())
    &#125;
&#125;</code></pre>
<p>在这里，我们将返回一个 HTML 报文，这个报文将展示注册所有的 service
的每一个方法的调用情况。</p>
<p>将 debugHTTP 实例绑定的地址<code>/debug/geerpc</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (server *Server) HandleHTTP() &#123;
    http.Handle(defaultRPCPath, server)
    http.Handle(defaultDebugPath, debugHTTP&#123;server&#125;)
    log.Println(&quot;rpc server debug path:&quot;, defaultDebugPath)
&#125;</code></pre>
<h4 id="demo-2">Demo</h4>
<p>到此，我们已经迫不及待地想看看最终的效果了。</p>
<p><strong>day5/main/main.go</strong></p>
<p>和之前的例子相比较，将 startServer
中的<code>geerpc.Accept()</code>替换为了<code>geerpc.HandleHTTP()</code>，端口固定为
9999。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Foo int

type Args struct &#123; Num1, Num2 int &#125;

func (f Foo) Sum(args Args, reply *int) error &#123;
    *reply &#x3D; args.Num1 + args.Num2
    return nil
&#125;

func startServer(addrCh chan string) &#123;
    var foo Foo
    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;9999&quot;)
    _ &#x3D; geerpc.Register(&amp;foo)
    geerpc.HandleHTTP()
    addrCh &lt;- l.Addr().String()
    _ &#x3D; http.Serve(l, nil)
&#125;</code></pre>
<p>客户端将<code>Dial</code>替换为<code>DialHTTP</code>，其余地方没有发生改变。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func call(addrCh chan string) &#123;
    client, _ :&#x3D; geerpc.DialHTTP(&quot;tcp&quot;, &lt;-addrCh)
    defer func() &#123; _ &#x3D; client.Close() &#125;()
    
    time.Sleep(time.Second)
    &#x2F;&#x2F; send a request &amp; receive response
    var wg sync.WaitGroup
    for i :&#x3D; 0; i &lt; 5; i++ &#123;
        wg.Add(1)
        go func(i int) &#123;
            defer wg.Done()
            args :&#x3D; &amp;Args&#123;Num1: i, Num2: i * i&#125;
            var reply int
            if err :&#x3D; client.Call(context.Background(), &quot;Foo.Sum&quot;, args, &amp;reply);err !&#x3D; nil &#123;
                log.Fatal(&quot;call Foo.Sum error:&quot;, err)
            &#125;
            log.Fatal(&quot;%d + %d &#x3D; %d&quot;, args.Num1, args.Num2, reply)
        &#125;(i)
    &#125;
    wg.Wait()
&#125;

func main() &#123;
    log.SetFlags(0)
    ch :&#x3D; make(chan string)
    go call(ch)
    startServer(ch)
&#125;</code></pre>
<p>main
函数中，我们在最后调用<code>startServer</code>，服务启动后将一直等待。</p>
<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">main$ go run.
rpc server: register Foo.Sum
rpc server debug path: &#x2F;debug&#x2F;geerpc
4 + 16 &#x3D; 20
3 + 9 &#x3D; 12
0 + 0 &#x3D; 0
2 + 4 &#x3D; 6
1 + 1 &#x3D; 2</code></pre>
<p>服务已经启动，此时我们如果在浏览器中访问
<code>localhost:9999/debug/geerpc</code>，将会看到：</p>
<p><img src="0x0031/0x0031-5.png"></p>
<h3 id="day6.-负载均衡">day6. 负载均衡</h3>
<ul>
<li>通过随机选择和 Round Robin 轮询调度算法实现服务端负载均衡，约 250
行代码。</li>
</ul>
<h4 id="负载均衡策略">负载均衡策略</h4>
<p>假设有多个服务实例，每个实例提供相同的功能，为了提高整个系统的吞吐量，每个实例部署在不同的机器上。客户端可以选择任意一个实例进行调用，获取想要的结果。那如何选择呢？取决了负载均衡的策略。对于
RPC 框架来说，我们可以很容易地想到这么几种策略：</p>
<ul>
<li>随机选择策略 - 从服务列表中随机选择一个。</li>
<li>轮询算法 (Round Robin) - 依次调度不同的服务器，每次调度执行 i = (i +
1) mode n。</li>
<li>加权轮询 (Weight Round Robin) -
在轮询算法的基础上，为每个服务实例设置一个权重，高性能的机器赋予更高的权重，也可以根据服务实例的当前的负载情况做动态的调整，例如考虑最近
5 分钟部署服务器的 CPU 、内存消耗情况。</li>
<li>哈希 / 一致性哈希策略 - 依据请求的某些特征，计算一个 hash 值，根据
hash 值将请求发送到对应的机器，一致性 hash
还可以解决服务实例动态添加情况下，调度抖动的问题。一致性哈希的一个典型应用场景是分布式缓存服务。</li>
</ul>
<h4 id="服务发现">服务发现</h4>
<p>负载均衡的前提是有多个服务实例，那我们首先实现一个最基础的服务发现模块
Discovery。为了与通信部分解耦，这部分的代码统一放置在 xclient
子目录下。</p>
<p>定义 2 个类型：</p>
<ul>
<li>SelectMode 代表不同的负载均衡策略，简单起见，GeeRPC 仅实现 Random 和
RoundRobin 两种策略。</li>
<li>Discovery 是一个接口类型，包含了服务发现所需要的最基本的接口。
<ul>
<li><code>Refresh()</code>从注册中心更新服务列表。</li>
<li><code>Update(servers []string)</code>手动更新服务列表。</li>
<li><code>Get(mode SelectMode)</code>根据负载均衡策略，选择一个服务实例。</li>
<li><code>GetAll()</code>返回所有的服务实例。</li>
</ul></li>
</ul>
<p><strong>day6/xclient/discovery.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package xclient

import (
    &quot;errors&quot;
    &quot;math&quot;
    &quot;math&#x2F;rand&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

type SelectMode int

const (
    RandomSelect SelectMode &#x3D; iota &#x2F;&#x2F; select randomly
    RoundRobinSelect               &#x2F;&#x2F; select using Robbin algorithm
)

type Discovery interface &#123;
    Refresh() error &#x2F;&#x2F; refresh from remote registry
    Update(servers []string) error
    Get(mode SelectMode) (string, error)
    GetAll() ([]string, error)
&#125;</code></pre>
<p>紧接着，我们实现一个不需要注册中心，服务列表由手工维护的服务发现的结构体：MultiServersDiscovery</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type MultiServersDiscovery struct &#123;
    r       *rand.Rand   &#x2F;&#x2F; generate random number
    mu      sync.RWMutex &#x2F;&#x2F; protect following
    servers []string 
    index   int          &#x2F;&#x2F; record the selected position for robin algorithm
&#125;

&#x2F;&#x2F; NewMultiServerDiscovery creates a MultiServersDiscovery instance
func NewMultiServerDiscovery(servers []string) *MultiServersDiscovery &#123;
    d :&#x3D; &amp;MultiServersDiscovery &#123;
        servers: servers,
        r:       rand.New(rand.NewSource(time.Now().UnixNano())),
    &#125;
    d.index &#x3D; d.r.Intn(math.MaxInt32 - 1)
    return d
&#125;</code></pre>
<ul>
<li>r
是一个产生随机数的实例，初始化时使用时间戳设定随机数种子，避免每次产生相同的随机数序列。</li>
<li>index 记录 Round Robin 算法已经轮询到的位置，为了避免每次从 0
开始，初始化时随机设定一个值。</li>
</ul>
<p>然后，实现 Discovery 接口</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var _ Discovery &#x3D; (*MultiServersDiscovery)(nil)

&#x2F;&#x2F; Refresh doesn&#39;t make sense for MultiServersDiscovery, so ignore it
func (d *MultiServersDiscovery) Refresh() error &#123;
    return nil
&#125;

&#x2F;&#x2F; Update the servers of discovery dynamically if needed
func (d *MultiServersDiscovery) Update(servers []string) error &#123;
    d.mu.Lock()
    defer d.mu.Unlock()
    d.servers &#x3D; servers
    return nil
&#125;

&#x2F;&#x2F; Get a server according to mode
func (d *MultiServersDiscovery) Get(mode SelectMode) (string, error) &#123;
    d.mu.Lock()
    defer d.mu.Unlock()
    n :&#x3D; len(d.servers)
    if n &#x3D;&#x3D; 0 &#123;
        return &quot;&quot;, errors.New(&quot;rpc discovery: no available servers&quot;)
    &#125;
    switch mode &#123;
    case RandomSelect:
        return d.servers[d.r.Intn(n)], nil
    case RoundRobinSelect:
        s :&#x3D; d.servers[d.index % n] &#x2F;&#x2F; servers could be updated, so mode n to ensure safety
        d.index &#x3D; (d.index + 1) % n
        return s, nil
    default:
        return &quot;&quot;, errors.New(&quot;rpc discovery: not supported select mode&quot;)
    &#125;
&#125;

&#x2F;&#x2F; returns all servers in discovery
func (d *MultiServersDiscovery) GetAll() ([]string, error) &#123;
    d.mu.RLock()
    defer d.mu.RUnlock()
    &#x2F;&#x2F; return a copy of d.servers
    servers :&#x3D; make([]string, len(d.servers), len(d.servers))
    copy(servers, d.servers)
    return servers, nil
&#125;</code></pre>
<h4 id="支持负载均衡的客户端">支持负载均衡的客户端</h4>
<p>接下来，我们向用户暴露一个支持负载均衡的客户端的 XClient。</p>
<p><strong>day6/xclient/xclient.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package xclient

import (
    &quot;context&quot;
    . &quot;geerpc&quot;
    &quot;io&quot;
    &quot;reflect&quot;
    &quot;sync&quot;
)

type XClient struct &#123;
    d       Discovery
    mode    SelectMode
    opt     *Option
    mu      sync.Mutex &#x2F;&#x2F; protect following
    clients map[string]*Client
&#125;

var _ io.Closer &#x3D; (*XClient)(nil)

func NewXClient(d Discovery, mode SelectMode, opt *Option) *XClient &#123;
    return &amp;XClient&#123;d: d, mode: mode, opt: opt, clients make(map[string]*Client)&#125;
&#125;

func (xc *XClient) Close() error &#123;
    xc.mu.Lock()
    defer xc.mu.Unlock()
    for key, client :&#x3D; range xc.clients &#123;
        &#x2F;&#x2F; I hava no idea how to deal with error, just ignore it.
        _ &#x3D; client.Close()
        delete(xc.clients, key)
    &#125;
    return nil
&#125;</code></pre>
<p>XClient 的构造函数需要传入三个参数，服务发现实例
Discovery、负载均衡模式 SelectMode 以及协议选项
Option。为了尽量地复用已经创建好的 Socket 连接，使用 clients
保存创建成功的 Client 实例，并提供 Close
方法在结束后，关闭已经创建的连接。</p>
<p>接下来，实现客户端最基本的功能<code>Call</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (xc *Client) dial(rpcAddr string) (*Client, error) &#123;
    xc.mu.Lock()
    defer xc.mu.Unlock()
    client, ok :&#x3D; xc.clients[rpcAddr]
    if ok &amp;&amp; !client.IsAvailable() &#123;
        _ &#x3D; client.Close()
        delete(xc.clients, rpcAddr)
        client &#x3D; nil
    &#125;
    if client &#x3D;&#x3D; nil &#123;
        var err error
        client, err &#x3D; XDial(rpcAddr, xc.opt)
        if err !&#x3D; nil &#123;
            return nil, err
        &#125;
        xc.clients[rpcAddr] &#x3D; client
    &#125;
    return client, nil
&#125;

func (xc *XClient) call(rpcAddr string, ctx context.Context, serviceMethod string, args, reply interface&#123;&#125;) error &#123;
    client, err :&#x3D; xc.dial(rpcAddr)
    if err !&#x3D; nil &#123;
        return err
    &#125;
    return client.Call(ctx, serviceMethod, args, reply)
&#125;

&#x2F;&#x2F; Call invokes the named function, waits for it to complete,
&#x2F;&#x2F; and returns its error status.
&#x2F;&#x2F; xc will choose a proper server.
func (xc *XClient) Call(ctx context.Context, serviceMethod string, args, reply interface&#123;&#125;) error &#123;
    rpcAddr, err :&#x3D; xc.d.Get(xc.mode)
    if err !&#x3D; nil &#123;
        return err
    &#125;
    return xc.call(rpcAddr, ctx, serviceMethod, args, reply)
&#125;</code></pre>
<p>我们将复用 Client
的能力封装在方法<code>dial</code>中，<code>dial</code>的处理逻辑如下：</p>
<ol type="1">
<li>检查<code>xc.clients</code>是否有缓存的
Client，如果有，检查是否时可用状态，如果是，则返回缓存的
Client，如果不可用，则从缓存中删除。</li>
<li>如果步骤 1 没有返回缓存的 Client，则说明需要创建新的
Client，缓存并返回。</li>
</ol>
<p>另外，我们为 XClient 添加一个常用功能：<code>Broadcast</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Broadcast invokes the named function for every server registered in discovery
func (xc *XClient) Broadcast(ctx context.Context, serviceMethod string, args, reply interface&#123;&#125;) error &#123;
    servers, err :&#x3D; xc.d.GetAll()
    if err !&#x3D; nil &#123;
        return err
    &#125;
    var wg sync.WaitGroup
    var mu sync.Mutex &#x2F;&#x2F; protect e and replyDone
    var e error
    replyDone :&#x3D; reply &#x3D;&#x3D; nil &#x2F;&#x2F; if reply is nil, don&#39;t need to set value
    ctx, cancel :&#x3D; context.WithCancel(ctx)
    for _, rpcAddr :&#x3D; range servers &#123;
        wg.Add(1)
        go func(rpcAddr string) &#123;
            defer wg.Done()
            var clonedReply interface&#123;&#125;
            if reply !&#x3D; nil &#123;
                clonedReply &#x3D; reflect.New(reflect.ValueOf(reply).Elem().Type()).Interface()                
            &#125;
            err :&#x3D; xc.call(rpcAddr, ctx, serviceMethod, args, clonedReply)
            mu.Lock()
            if err !&#x3D; nil &amp;&amp; e &#x3D;&#x3D; nil &#123;
                e &#x3D; err
                cancel() &#x2F;&#x2F; if any call failed, cancel unfinished calls
            &#125;
            if err &#x3D;&#x3D; nil &amp;&amp; !replyDone &#123;
                reflect.ValueOf(reply).Elem().Set(reflect.ValueOf(clonedReply).Elem())
                replyDone &#x3D; true
            &#125;
            mu.Unlock()
        &#125;(rpcAddr)
    &#125;
    wg.Wait()
    return e
&#125;</code></pre>
<p>Broadcast
将请求广播到所有的服务实例，如果任意一个实例发生错误，则返回其中一个错误；如果调用成功，则返回其中一个的结果。有以下几点需要注意：</p>
<ol type="1">
<li>为了提升性能，请求是并发的。</li>
<li>并发情况下需要使用互斥锁保证 error 和 reply 能被正确赋值。</li>
<li>借助<code>context.WithCancel</code>确保有错误发生时，快速失败。</li>
</ol>
<h4 id="demo-3">Demo</h4>
<p>首先，启动 RPC 服务的代码还是类似的，Sum 时正常的方法，Sleep 用于验证
XClient 的超时机制能否正常运作。</p>
<p><strong>day6/main/main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

import (
    &quot;context&quot;
    &quot;geerpc&quot;
    &quot;geerpc&#x2F;xclient&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

type Foo int

type Args struct&#123; Num1, Num2 int &#125;

func (f Foo) Sum(args Args, reply *int) error &#123;
    time.Sleep(time.Second * time.Duration(args.Num1))
    *reply &#x3D; args.Num1 + args.Num2
    return nil
&#125;

func (f Foo) Sleep(args Args, reply *int) error &#123;
    var foo Foo
    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)
    server :&#x3D; geerpc.NewServer()
    &#x2F;&#x2F; send request &amp; receive response
    var wg sync.WaitGroup
    for i :&#x3D; 0; i &lt; 5; i++ &#123;
        wg.Add(1)
        go func(i int) &#123;
            defer wg.Done()
            foo(xc, context.Background(), &quot;call&quot;, &quot;Foo.Sum&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)
        &#125;(i)
    &#125;
    wg.Wait()
&#125;

func broadcast(addr1, addr2 string) &#123;
    d :&#x3D; xclient.NewMultiServerDiscovery([]string&#123;&quot;tcp&quot; + addr1, &quot;tcp@&quot; + addr2&#125;)
    xc :&#x3D; xclient.NewXClient(d, xclient.RandomSelect, nil)
    defer func() &#123; _ &#x3D; xc.Close() &#125;()
    var wg sync.WaitGroup
    for i :&#x3D; 0; i &lt; 5; i++ &#123;
        wg.Add(1)
        go func(i int) &#123;
            defer wg.Done()
            foo(xc, context.Background(), &quot;broadcast&quot;, &quot;Foo.Sum&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)
            &#x2F;&#x2F; expect 2 - 5 timeout
            ctx, _ :&#x3D; context.WithTimeout(context.Background(), time.Second * 2)
            foo(xc, ctx, &quot;broadcast&quot;, &quot;Foo.Sleep&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)
        &#125;(i)
    &#125;
    wg.Wait()
&#125;

func main() &#123;
    log.SetFlags(0)
    ch1 :&#x3D; make(chan string)
    ch2 :&#x3D; make(chan string)
    &#x2F;&#x2F; start two servers
    go startServer(ch1)
    go startServer(ch2)
    
    addr1 :&#x3D; &lt;-ch1
    addr@ :&#x3D; &lt;-ch2
    
    time.Sleep(time.Second)
    call(addr1, addr2)
    broadcast(addr1, addr2)
&#125;</code></pre>
<p>运行结果如下</p>
<pre class="line-numbers language-none"><code class="language-none">*main.Foo    Sleep
rpc server: register Foo.Sleep
*main.Foo    Sum
rpc server: register Foo.Sum
*main.Foo    Sleep
rpc server: register Foo.Sleep
*main.Foo    Sum
rpc server: register Foo.Sum
call Foo.Sum success: 3 + 9 &#x3D; 12
call Foo.Sum success: 4 + 16 &#x3D; 20
call Foo.Sum success: 2 + 4 &#x3D; 6
call Foo.Sum success: 0 + 0 &#x3D; 0
call Foo.Sum success: 1 + 1 &#x3D; 2
broadcast Foo.Sum success: 4 + 16 &#x3D; 20
broadcast Foo.Sum success: 2 + 4 &#x3D; 6
broadcast Foo.Sum success: 1 + 1 &#x3D; 2
broadcast Foo.Sum success: 0 + 0 &#x3D; 0
broadcast Foo.Sum success: 3 + 9 &#x3D; 12
broadcast Foo.Sleep success: 0 + 0 &#x3D; 0
broadcast Foo.Sleep success: 1 + 1 &#x3D; 2
broadcast Foo.Sleep error: rpc client: call failed: context deadline exceeded
broadcast Foo.Sleep error: rpc client: call failed: context deadline exceeded
broadcast Foo.Sleep error: rpc client: call failed: context deadline exceeded</code></pre>
<h3 id="day7.-服务发现与注册中心">day7. 服务发现与注册中心</h3>
<p>// header 一定要一致，不然一直错</p>
<ul>
<li>实现一个简单的注册中心，支持服务注册，接收心跳等功能。</li>
<li>客户端实现基于注册中心的服务发现机制。</li>
</ul>
<h4 id="注册中心的位置">注册中心的位置</h4>
<p><img src="0x0031/0x0031-7.jpg"></p>
<p>注册中心的位置如上图所示。注册中心的好处在于，客户端和服务端都只需要感知注册中心的存在，而无需感知对方的存在。更具体一点：</p>
<ol type="1">
<li>服务端启动后，向注册中心发送注册信息，注册中心得知该服务已经启动，处于可用状态。一般来说，服务端还需要定期向注册中心发送心跳，证明自己还活着。</li>
<li>客户端向注册中心询问，当前哪天服务是可用的，注册中心将可用的服务列表返回客户端。</li>
<li>客户端根据注册中心得到的服务列表，选择其中一个发起调用。</li>
</ol>
<p>如果没有注册中心，就像 GeeRPC
第六天实现的一样，客户端需要硬编码服务端的地址，而且没有机制保证服务端是否处于可用状态。当然注册中心的功能还有很多，比如配置的动态同步，通知机制等。比较常用的注册中心有
etcd、zookeeper、consul，一般比较出名的微服务或者 RPC
框架，这些主流的注册中心都是支持的。</p>
<h4 id="gee-registry">Gee Registry</h4>
<p>主流的注册中心 etcd、zookeeper
等功能强大，与这类注册中心的对接代码量是比较大的，需要实现的接口很多。GeeRPC
选择自己实现一个简单的支持心跳保活的注册中心。</p>
<p>GeeRegistry 的代码独立放置在子目录 registry 中。</p>
<p>首先定义 GeeRegistry 结构体，默认超时时间设置为 5
min，也就是说，任何注册的服务超过 5 min，即视为不可用状态。</p>
<p><strong>day7/registry/registry.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type GeeRegistry struct &#123;
    timeout time.Duration
    mu      sync.Mutex &#x2F;&#x2F; protect following
    servers map[string]*ServerItem
&#125;

type ServerItem struct &#123;
    Addr string
    start time.Time
&#125;

const (
	defaultPath    &#x3D; &quot;&#x2F;geerpc&#x2F;registry&quot;
    defaultTimeout &#x3D; time.Minute * 5
)

&#x2F;&#x2F; New create a registry instance with timeout setting
func New(timeout time.Duration) *GeeRegistry &#123;
    return &amp;GeeRegistry &#123;
        servers: make(map[string]*ServerItem),
        timeout: timeout,
    &#125;
&#125;

var DefaultGeeRegister &#x3D; New(defaultTimeout)</code></pre>
<p>为 GeeRegistry 实现添加服务实例和返回服务列表的方法。</p>
<ul>
<li>putServer：添加服务实例，如果服务已存在，则更新 start。</li>
<li>aliveServers：返回可用的服务列表，如果存在超时的服务，则删除。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *GeeRegistry) putServer(addr string) &#123;
    r.mu.Lock()
    defer r.mu.Unlock()
    s :&#x3D; r.servers[addr]
    if s &#x3D;&#x3D; nil &#123;
        r.servers[addr] &#x3D; &amp;ServerItem&#123;Addr: addr, start: time.Now()&#125;
    &#125; else &#123;
        s.start &#x3D; time.Now() &#x2F;&#x2F; if exists, update start time to keep alive
    &#125;
&#125;

func (r *GeeRegistry) aliveServers() []string &#123;
    r.mu.Lock()
    defer r.mu.Unlock()
    var alive []string
    for addr, s :&#x3D; range r.servers &#123;
        if r.timeout &#x3D;&#x3D; 0 || s.start.Add(r.timeout).After(time.Now()) &#123;
            alive &#x3D; append(alive, addr)
        &#125; else &#123;
            delete(r.servers, addr)
        &#125;
        sort.Strings(alive)
        return alive
    &#125;
&#125;</code></pre>
<p>为了实现上的简单，GeeRegistry 采用 HTTP
协议提供服务，且所有的有用信息都承载在 HTTP Header 中。</p>
<ul>
<li>Get：返回所有可用的服务列表，通过自定义字段 X-Geerpc-Servers
承载。</li>
<li>Post：添加服务实例或发送心跳，通过自定义字段 X-Geerpc-Server
承载。</li>
</ul>
<blockquote>
<p>这里要注意，Get 和 Post 各自使用的 header
一定要一样，不然就会出现<code>rpc discovery: no available servers</code>的错误</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *GeeRegistry) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;
    switch req.Method &#123;
    case &quot;GET&quot;:
        &#x2F;&#x2F; keep it simple, server is in req.Header
        w.Header().Set(&quot;X-Geerpc-Servers&quot;, strings.Join(r.aliveServers(), &quot;,&quot;))
    case &quot;POST&quot;:
        &#x2F;&#x2F; keep it simple, server is in req.Header
        addr :&#x3D; req.Header.Get(&quot;X-Geerpc-Server&quot;)
        if addr &#x3D;&#x3D; &quot;&quot; &#123;
            w.WriteHeader(http.StatusInternalServerError)
            return
        &#125;
        r.putServer(addr)
    default:
        w.WriteHeader(http.StatusInternalServerError)
    &#125;
&#125;

&#x2F;&#x2F; HandleHTTP registers an HTTP handler for GeeRegistry messages on registryPath
func (r *GeeRegistry) HandleHTTP(registryPath string) &#123;
    http.Handle(registryPath, r)
    log.Println(&quot;rpc registry path:&quot;, registryPath)
&#125;

func HandleHTTP() &#123;
    DefaultGeeRegister.HandleHTTP(defaultPath)
&#125;</code></pre>
<p>另外，提供 Heartbeat
方法，便于服务启动时定时向注册中心发送心跳，默认周期比注册中心设置的过期时间少
1 min。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Heartbeat send a heartbeat message every once in a while
&#x2F;&#x2F; it&#39;s a helper function for a server to register or send heartbeat
func Heartbeat(registry, addr string, duration time.Duration) &#123;
    if duration &#x3D;&#x3D; 0 &#123;
        &#x2F;&#x2F; make sure there is enough time to send heart beat
        &#x2F;&#x2F; before it&#39;s removed from registry
        duration &#x3D; defaultTimeout - time.Duration(1)*time.Minute
    &#125;
    var err error
    err &#x3D; sendHeartbeat(registry, addr)
    go func() &#123;
        t :&#x3D; time.NewTicker(duration)
        for err &#x3D;&#x3D; nil &#123;
            &lt;-t.C
            err &#x3D; sendHeartbeat(registry, addr)
        &#125;
    &#125;()
&#125;

func sendHeartbeat(registry, addr string) error &#123;
    log.Println(addr, &quot;send heart beat to registry&quot;, registry)
    httpClient :&#x3D; &amp;http.Client&#123;&#125;
    req, _ :&#x3D; http.NewRequest(&quot;POST&quot;, registry, nil)
    req.Header.Set(&quot;X-Geerpc-Server&quot;, addr)
    if _, err :&#x3D; httpClient.Do(req); err !&#x3D; nil &#123;
        log.Println(&quot;rpc server: heart beat err:&quot;, err)
        return err
    &#125;
    return nil
&#125;</code></pre>
<h4 id="geeregistrydiscovery">GeeRegistryDiscovery</h4>
<p>在 xclient 中对应实现 Discovery。</p>
<p><strong>day7/xclient/discovery_gee.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package xclient

type GeeRegistryDiscovery struct &#123;
    *MultiServersDiscovery 
    registry   string
    timeout    time.Duration
    lastUpdate time.Time
&#125;

const defaultUpdateTimeout &#x3D; time.Second * 10

func NewGeeRegistryDiscovery(registerAddr string, timeout time.Duration) *GeeRegistryDiscovery &#123;
    if timeout &#x3D;&#x3D; 0 &#123;
        timeout &#x3D; defaultUpdateTimeout
    &#125;
    d :&#x3D; &amp;GeeRegistryDiscovery &#123;
        MultiServerDiscovery: NewMultiServerDiscovery(make([]string, 0))
        registry:             registerAddr,
        timeout:              timeout,
    &#125;
    return d
&#125;</code></pre>
<ul>
<li>GeeRegistryDiscovery 嵌套了
MultiServersDiscovery，很多能力可以复用。</li>
<li>registry 即注册中心的地址。</li>
<li>timeout 服务列表的过期时间。</li>
<li>lastUpdate 是代表最后从注册中心更新服务列表的时间，默认 10s 过期，即
10s 之后，需要从注册中心更新新的列表。</li>
</ul>
<p>实现 Update 和 Refresh 方法，超时重新获取的逻辑在 Refresh
中实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (d *GeeRegistryDiscovery) Update(servers []string) error &#123;
    d.mu.Lock()
    defer d.mu.Unlock()
    d.servers &#x3D; servers
    d.lastUpdate &#x3D; time.Now()
    return nil
&#125;

func (d *GeeRegistryDiscovery) Refresh() error &#123;
    d.mu.Lock()
    defer d.mu.Unlock()
    if d.lastUpdate.Add(d.timeout).After(time.Now()) &#123;
        return nil
    &#125;
    log.Println(&quot;rpc registry: refresh servers form registry&quot;, d.registry)
    resp, err :&#x3D; http.Get(d.registry)
    if err !&#x3D; nil &#123;
        log.Println(&quot;rpc registry refresh err:&quot;, err)
        return err
    &#125;
    servers :&#x3D; strings.Split(resp.Header.Get(&quot;X-Geerpc-Server&quot;, &quot;,&quot;))
    d.server &#x3D; make([]string, 0, len(servers))
    for _, server :&#x3D; range servers &#123;
        if strings.TrimSpace(server) !&#x3D; &quot;&quot; &#123;
            d.servers &#x3D; append(d.servers, strings.TrimSpace(server))
        &#125;
    &#125;
    d.lastUpdate &#x3D; time.Now()
    return nil
&#125;</code></pre>
<p><code>Get</code>和<code>GetAll</code>与<code>MultiServersDiscovery</code>相似，唯一不同的在于，<code>GeeRegistryDiscovery</code>需要先调用
Refresh 确保服务列表没有过期。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (d *GeeRegistryDiscovery) Get(mode SelectMode) (string, error) &#123;
    if err :&#x3D; d.Refresh(); err !&#x3D; nil &#123;
        return &quot;&quot;, err
    &#125;
    return d.MultiServersDiscovery.Get(mode)
&#125;

func (d *GeeRegistryDiscovery) GetAll() ([]string, error) &#123;
    if err :&#x3D; d.Refresh(); err !&#x3D; nil &#123;
        return nil, err
    &#125;
    return d.MultiServersDiscovery.GetAll()
&#125;</code></pre>
<h4 id="demo-4">Demo</h4>
<p>最后，依旧通过简单的 Demo 验证今天的成果。</p>
<p>添加函数 startRegistry，稍微修改
startServer，添加调用注册中心的<code>Heartbeat</code>方法的逻辑，定期向注册中心发送心跳。</p>
<p><strong>day7/main/main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func startRegistry(wg *sync.WaitGroup) &#123;
    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:9999&quot;)
    registry.HandleHTTP()
    wg.Done()
    _ &#x3D; http.Serve(l, nil)
&#125;

func startServer(registryAddr string, wg *sync.WaitGroup) &#123;
    var foo Foo
    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)
    server :&#x3D; geerpc.NewServer()
    _ &#x3D; server.Register(&amp;foo)
    registry.Heartbeat(registryAddr)
    wg.Done()
    server.Accept(l)
&#125;</code></pre>
<p>接下来，将 call 和 broadcast 的 MultiServersDiscovery 替换为
GeeRegistryDiscovery，不再需要硬编码服务列表。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func call(registry string) &#123;
    d :&#x3D; xclient.NewGeeRegistryDiscovery(registry, 0)
    xc :&#x3D; xclient.NewXClient(d, xclient.RandomSelect, nil)
    defer func() &#123; _ &#x3D; xc.Close() &#125;()
    &#x2F;&#x2F; send request &amp; receive response
    var wg sync.WaitGroup
    for i :&#x3D; 0; i &lt; 5; i++ &#123;
        wg.Add(1)
        go func(i int) &#123;
            defer wg.Done()
            foo(xc, context.Background(), &quot;call&quot;, &quot;Foo.Sum&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)
        &#125;(i)
    &#125;
    wg.Wait()
&#125;

func broadcast(registry string) &#123;
    d :&#x3D; xclient.NewGeeRegistryDiscovery(registry, 0)
    xc :&#x3D; xclient.NewXClient(d, xclient.RandomSelect, nil)
    defer func() &#123; _ &#x3D; xc.Close() &#125;()
    var wg sync.WaitGroup
    for i :&#x3D; 0; i &lt; 5; i++ &#123;
        wg.Add(1)
        go func(i int) &#123;
            defer wg.Done()
            foo(xc, context.Background(), &quot;broadcast&quot;, &quot;Foo.Sum&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)
            &#x2F;&#x2F; expect 2- 5 timeout
            ctx, _ :&#x3D; context.WithTimeout(context.Background(), time.Second*2)
            foo(xc, ctx, &quot;broadcast&quot;, &quot;Foo.Sleep&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)
        &#125;(i)
    &#125;
    wg.Wait()
&#125;</code></pre>
<p>最后在 main 函数中，将所有的逻辑串联起来，确保注册中心启动后，再启动
RPC 服务端，最后客户端远程调用。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;
    log.SetFlags(0)
    registryAddr :&#x3D; &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registry&quot;
    var wg sync.WaitGroup
    wg.Add(1)
    go startRegistry(&amp;wg)
    wg.Wait()
    
    time.Sleep(time.Second)
    wg.Add(2)
    go startServer(registryAddr, &amp;wg)
    go startServer(registryAddr, &amp;wg)
    wg.Wait()
    
    time.Sleep(time.Second)
    call(registryAddr)
    broadcast(registryAddr)    
&#125;</code></pre>
<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">rpc registry path: &#x2F;geerpc&#x2F;registry
*main.Foo    Sleep
rpc server: register Foo.Sleep
*main.Foo    Sum
rpc server: register Foo.Sum
tcp@[::]:46043 send heart beat to registry http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registry
*main.Foo    Sleep
rpc server: register Foo.Sleep
*main.Foo    Sum
rpc server: register Foo.Sum
tcp@[::]:45079 send heart beat to registry http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registry
rpc registry: refresh servers from registry http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registry
call Foo.Sum success: 2 + 4 &#x3D; 6
call Foo.Sum success: 4 + 16 &#x3D; 20
call Foo.Sum success: 1 + 1 &#x3D; 2
call Foo.Sum success: 0 + 0 &#x3D; 0
call Foo.Sum success: 3 + 9 &#x3D; 12
rpc registry: refresh servers from registry http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registry
broadcast Foo.Sum success: 3 + 9 &#x3D; 12
broadcast Foo.Sum success: 2 + 4 &#x3D; 6
broadcast Foo.Sum success: 4 + 16 &#x3D; 20
broadcast Foo.Sum success: 1 + 1 &#x3D; 2
broadcast Foo.Sum success: 0 + 0 &#x3D; 0
broadcast Foo.Sleep success: 0 + 0 &#x3D; 0
broadcast Foo.Sleep success: 1 + 1 &#x3D; 2
broadcast Foo.Sleep error: rpc client: call failed: context deadline exceeded
broadcast Foo.Sleep error: rpc client: call failed: context deadline exceeded
broadcast Foo.Sleep error: rpc client: call failed: context deadline exceeded</code></pre>
<p>七天时间，参照 golang 标准库
net/rpc，实现了服务端以及支持并发的客户端，并且支持选择不同的序列化与反序列化方式；为了防止服务挂死，在其中一些关键部分添加蓝超时处理机制；支持
TCP、Unix、HTTP
等多种传输协议；支持多种负载均衡模式，最后还实现了一个简易的服务注册和发现中心。</p>
<h3 id="一些想法">一些想法</h3>
<p>其实我学习这个的目的是为了尝试完成 mit 6.824，它的 lab1
里，要求使用利用 rpc 来完成客户端和服务器之间的通信，但无奈，学习 golang
的时间并不是很长，恰巧留意到 geektutu 有发过 rpc
的七天项目，那么，正好，来敲一敲练练手。并且推进这个小项目的时间也不止七天。</p>
<p>那么来提炼一些个人觉得比较重要的知识。</p>
<h4 id="典型的-rpc-调用过程">典型的 RPC 调用过程</h4>
<p>感觉，这个项目中的 rpc
的一些定义我不是很能理解，那么根据自己在别的网站上学到的，以及在做 6.824
lab1时的一些经验，重新总结下相关 rpc 的基本结构。</p>
<p><strong>server</strong></p>
<p>这里的定义，结合了 6.824 lab1
的实验要求进行总结，当然下面举的例子也只是简要说明下 rpc 的组成。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Task struct &#123;
    FileName string
    TaskType int
&#125;

type Coordinator struct &#123;
    task Task
&#125;</code></pre>
<p><strong>client</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type client struct &#123;
    clientID int
    mapf     func(string, string) []KeyValue
    reducef  func(string, []string) string
&#125;</code></pre>
<p><strong>rpc</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type TaskRequest struct &#123;
    X int
&#125;
&#x2F;&#x2F; 用于获取任务的请求结构体，在 lab1 中不携带信息

type TaskReply struct &#123;
    X int
&#125;
&#x2F;&#x2F; 回复任务的结构体，在 lab1 中不需要携带信息</code></pre>
<p>server 中定义了一个函数 <code>func()</code></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (s *Server)Func() &#123;
    &#x2F;&#x2F; code
&#125;</code></pre>
<p>然后在 client 里有一个 <code>CallGetFunc()</code>，
用于远程调用。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func CallGetFunc() &#123;
    args :&#x3D; TaskRequest&#123;&#125;
    reply :&#x3D; TaskReply&#123;&#125;
    call(&quot;Server.Func&quot;, &amp;args, &amp;reply)
&#125;</code></pre>
<p>然后按照下列方式调用远程调用函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">call(&quot;StructName.FunctionName&quot;, &amp;args, &amp;reply),</code></pre>
<p>这样子，就完成了一个基本的 rpc 调用过程。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Golang/" rel="tag"># Golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/0x0030.html" rel="prev" title="Java swing实现应用程序对数据库的访问">
                  <i class="fa fa-chevron-left"></i> Java swing实现应用程序对数据库的访问
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/0x0032.html" rel="next" title="gin+MySQL简单实现数据库查询">
                  gin+MySQL简单实现数据库查询 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jayden Chang</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">994k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">15:04</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/code-unfold.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"enable","tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"JaydenChang","repo":"jaydenchang.github.io","client_id":"4eefd4ac7c2004ef4002","client_secret":"83b3a65014e1cfa0565541412c12518873e5583f","admin_user":"JaydenChang","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"b904cce55c8297310721c2bf530420b6"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>




</body>
</html>
